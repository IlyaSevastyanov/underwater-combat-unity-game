1 ТЕКСТЫ ПРОГРАММЫ НАСТРОЙКИ ПРОЕКТА

1.1 Текст файла данных «ProjectSettings.asset».
Назначение: файл настроек проекта Unity.
Язык разметки: YAML.
Код разметки:
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!129 &1
PlayerSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 26
  productGUID: 047f48d3e6e772c4a9e061226b553776
  AndroidProfiler: 0
  AndroidFilterTouchesWhenObscured: 0
  AndroidEnableSustainedPerformanceMode: 0
  defaultScreenOrientation: 4
  targetDevice: 2
  useOnDemandResources: 0
  accelerometerFrequency: 60
  companyName: DefaultCompany
  productName: Black Water
  defaultCursor: {fileID: 0}
  cursorHotspot: {x: 0, y: 0}
  m_SplashScreenBackgroundColor: {r: 0.13725491, g: 0.12156863, b: 0.1254902, a: 1}
  m_ShowUnitySplashScreen: 1
  m_ShowUnitySplashLogo: 1
  m_SplashScreenOverlayOpacity: 1
  m_SplashScreenAnimation: 1
  m_SplashScreenLogoStyle: 1
  m_SplashScreenDrawMode: 0
  m_SplashScreenBackgroundAnimationZoom: 1
  m_SplashScreenLogoAnimationZoom: 1
  m_SplashScreenBackgroundLandscapeAspect: 1
  m_SplashScreenBackgroundPortraitAspect: 1
  m_SplashScreenBackgroundLandscapeUvs:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  m_SplashScreenBackgroundPortraitUvs:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  m_SplashScreenLogos: []
  m_VirtualRealitySplashScreen: {fileID: 0}
  m_HolographicTrackingLossScreen: {fileID: 0}
  defaultScreenWidth: 1920
  defaultScreenHeight: 1080
  defaultScreenWidthWeb: 960
  defaultScreenHeightWeb: 600
  m_StereoRenderingPath: 0
  m_ActiveColorSpace: 0
  unsupportedMSAAFallback: 0
  m_SpriteBatchVertexThreshold: 300
  m_MTRendering: 1
  mipStripping: 0
  numberOfMipsStripped: 0
  numberOfMipsStrippedPerMipmapLimitGroup: {}
  m_StackTraceTypes: 010000000100000001000000010000000100000001000000
  iosShowActivityIndicatorOnLoading: -1
  androidShowActivityIndicatorOnLoading: -1
  iosUseCustomAppBackgroundBehavior: 0
  allowedAutorotateToPortrait: 1
  allowedAutorotateToPortraitUpsideDown: 1
  allowedAutorotateToLandscapeRight: 1
  allowedAutorotateToLandscapeLeft: 1
  useOSAutorotation: 1
  use32BitDisplayBuffer: 1
  preserveFramebufferAlpha: 0
  disableDepthAndStencilBuffers: 0
  androidStartInFullscreen: 1
  androidRenderOutsideSafeArea: 1
  androidUseSwappy: 1
  androidBlitType: 0
  androidResizableWindow: 0
  androidDefaultWindowWidth: 1920
  androidDefaultWindowHeight: 1080
  androidMinimumWindowWidth: 400
  androidMinimumWindowHeight: 300
  androidFullscreenMode: 1
  androidAutoRotationBehavior: 1
  androidPredictiveBackSupport: 1
  defaultIsNativeResolution: 1
  macRetinaSupport: 1
  runInBackground: 1
  captureSingleScreen: 0
  muteOtherAudioSources: 0
  Prepare IOS For Recording: 0
  Force IOS Speakers When Recording: 0
  audioSpatialExperience: 0
  deferSystemGesturesMode: 0
  hideHomeButton: 0
  submitAnalytics: 1
  usePlayerLog: 1
  dedicatedServerOptimizations: 0
  bakeCollisionMeshes: 0
  forceSingleInstance: 0
  useFlipModelSwapchain: 1
  resizableWindow: 0
  useMacAppStoreValidation: 0
  macAppStoreCategory: public.app-category.games
  gpuSkinning: 1
  xboxPIXTextureCapture: 0
  xboxEnableAvatar: 0
  xboxEnableKinect: 0
  xboxEnableKinectAutoTracking: 0
  xboxEnableFitness: 0
  visibleInBackground: 1
  allowFullscreenSwitch: 1
  fullscreenMode: 1
  xboxSpeechDB: 0
  xboxEnableHeadOrientation: 0
  xboxEnableGuest: 0
  xboxEnablePIXSampling: 0
  metalFramebufferOnly: 0
  xboxOneResolution: 0
  xboxOneSResolution: 0
  xboxOneXResolution: 3
  xboxOneMonoLoggingLevel: 0
  xboxOneLoggingLevel: 1
  xboxOneDisableEsram: 0
  xboxOneEnableTypeOptimization: 0
  xboxOnePresentImmediateThreshold: 0
  switchQueueCommandMemory: 0
  switchQueueControlMemory: 16384
  switchQueueComputeMemory: 262144
  switchNVNShaderPoolsGranularity: 33554432
  switchNVNDefaultPoolsGranularity: 16777216
  switchNVNOtherPoolsGranularity: 16777216
  switchGpuScratchPoolGranularity: 2097152
  switchAllowGpuScratchShrinking: 0
  switchNVNMaxPublicTextureIDCount: 0
  switchNVNMaxPublicSamplerIDCount: 0
  switchNVNGraphicsFirmwareMemory: 32
  switchMaxWorkerMultiple: 8
  stadiaPresentMode: 0
  stadiaTargetFramerate: 0
  vulkanNumSwapchainBuffers: 3
  vulkanEnableSetSRGBWrite: 0
  vulkanEnablePreTransform: 1
  vulkanEnableLateAcquireNextImage: 0
  vulkanEnableCommandBufferRecycling: 1
  loadStoreDebugModeEnabled: 0
  visionOSBundleVersion: 1.0
  tvOSBundleVersion: 1.0
  bundleVersion: 0.1
  preloadedAssets: []
  metroInputSource: 0
  wsaTransparentSwapchain: 0
  m_HolographicPauseOnTrackingLoss: 1
  xboxOneDisableKinectGpuReservation: 1
  xboxOneEnable7thCore: 1
  vrSettings:
    enable360StereoCapture: 0
  isWsaHolographicRemotingEnabled: 0
  enableFrameTimingStats: 0
  enableOpenGLProfilerGPURecorders: 1
  allowHDRDisplaySupport: 0
  useHDRDisplay: 0
  hdrBitDepth: 0
  m_ColorGamuts: 00000000
  targetPixelDensity: 30
  resolutionScalingMode: 0
  resetResolutionOnWindowResize: 0
  androidSupportedAspectRatio: 1
  androidMaxAspectRatio: 2.1
  applicationIdentifier:
    Android: com.DefaultCompany.BlackWater
    Standalone: com.DefaultCompany.Black-Water
  buildNumber:
    Standalone: 0
    VisionOS: 0
    iPhone: 0
    tvOS: 0
  overrideDefaultApplicationIdentifier: 0
  AndroidBundleVersionCode: 1
  AndroidMinSdkVersion: 32
  AndroidTargetSdkVersion: 36
  AndroidPreferredInstallLocation: 1
  aotOptions: 
  stripEngineCode: 1
  iPhoneStrippingLevel: 0
  iPhoneScriptCallOptimization: 0
  ForceInternetPermission: 0
  ForceSDCardPermission: 0
  CreateWallpaper: 0
  APKExpansionFiles: 0
  keepLoadedShadersAlive: 0
  StripUnusedMeshComponents: 1
  strictShaderVariantMatching: 0
  VertexChannelCompressionMask: 4054
  iPhoneSdkVersion: 988
  iOSSimulatorArchitecture: 0
  iOSTargetOSVersionString: 12.0
  tvOSSdkVersion: 0
  tvOSSimulatorArchitecture: 0
  tvOSRequireExtendedGameController: 0
  tvOSTargetOSVersionString: 12.0
  VisionOSSdkVersion: 0
  VisionOSTargetOSVersionString: 1.0
  uIPrerenderedIcon: 0
  uIRequiresPersistentWiFi: 0
  uIRequiresFullScreen: 1
  uIStatusBarHidden: 1
  uIExitOnSuspend: 0
  uIStatusBarStyle: 0
  appleTVSplashScreen: {fileID: 0}
  appleTVSplashScreen2x: {fileID: 0}
  tvOSSmallIconLayers: []
  tvOSSmallIconLayers2x: []
  tvOSLargeIconLayers: []
  tvOSLargeIconLayers2x: []
  tvOSTopShelfImageLayers: []
  tvOSTopShelfImageLayers2x: []
  tvOSTopShelfImageWideLayers: []
  tvOSTopShelfImageWideLayers2x: []
  iOSLaunchScreenType: 0
  iOSLaunchScreenPortrait: {fileID: 0}
  iOSLaunchScreenLandscape: {fileID: 0}
  iOSLaunchScreenBackgroundColor:
    serializedVersion: 2
    rgba: 0
  iOSLaunchScreenFillPct: 100
  iOSLaunchScreenSize: 100
  iOSLaunchScreenCustomXibPath: 
  iOSLaunchScreeniPadType: 0
  iOSLaunchScreeniPadImage: {fileID: 0}
  iOSLaunchScreeniPadBackgroundColor:
    serializedVersion: 2
    rgba: 0
  iOSLaunchScreeniPadFillPct: 100
  iOSLaunchScreeniPadSize: 100
  iOSLaunchScreeniPadCustomXibPath: 
  iOSLaunchScreenCustomStoryboardPath: 
  iOSLaunchScreeniPadCustomStoryboardPath: 
  iOSDeviceRequirements: []
  iOSURLSchemes: []
  macOSURLSchemes: []
  iOSBackgroundModes: 0
  iOSMetalForceHardShadows: 0
  metalEditorSupport: 1
  metalAPIValidation: 1
  metalCompileShaderBinary: 0
  iOSRenderExtraFrameOnPause: 0
  iosCopyPluginsCodeInsteadOfSymlink: 0
  appleDeveloperTeamID: 
  iOSManualSigningProvisioningProfileID: 
  tvOSManualSigningProvisioningProfileID: 
  VisionOSManualSigningProvisioningProfileID: 
  iOSManualSigningProvisioningProfileType: 0
  tvOSManualSigningProvisioningProfileType: 0
  VisionOSManualSigningProvisioningProfileType: 0
  appleEnableAutomaticSigning: 0
  iOSRequireARKit: 0
  iOSAutomaticallyDetectAndAddCapabilities: 1
  appleEnableProMotion: 0
  shaderPrecisionModel: 0
  clonedFromGUID: c0afd0d1d80e3634a9dac47e8a0426ea
  templatePackageId: com.unity.template.3d@8.1.3
  templateDefaultScene: Assets/Scenes/SampleScene.unity
  useCustomMainManifest: 0
  useCustomLauncherManifest: 0
  useCustomMainGradleTemplate: 0
  useCustomLauncherGradleManifest: 0
  useCustomBaseGradleTemplate: 0
  useCustomGradlePropertiesTemplate: 0
  useCustomGradleSettingsTemplate: 0
  useCustomProguardFile: 0
  AndroidTargetArchitectures: 1
  AndroidTargetDevices: 0
  AndroidSplashScreenScale: 0
  androidSplashScreen: {fileID: 0}
  AndroidKeystoreName: 
  AndroidKeyaliasName: 
  AndroidEnableArmv9SecurityFeatures: 0
  AndroidBuildApkPerCpuArchitecture: 0
  AndroidTVCompatibility: 0
  AndroidIsGame: 1
  AndroidEnableTango: 0
  androidEnableBanner: 1
  androidUseLowAccuracyLocation: 0
  androidUseCustomKeystore: 0
  m_AndroidBanners:
  - width: 320
    height: 180
    banner: {fileID: 0}
  androidGamepadSupportLevel: 0
  chromeosInputEmulation: 1
  AndroidMinifyRelease: 0
  AndroidMinifyDebug: 0
  AndroidValidateAppBundleSize: 1
  AndroidAppBundleSizeToValidate: 150
  m_BuildTargetIcons:
  - m_BuildTarget: 
    m_Icons:
    - serializedVersion: 2
      m_Icon: {fileID: 2800000, guid: aab44c938d5485b459612411d8368dcf, type: 3}
      m_Width: 128
      m_Height: 128
      m_Kind: 0
  m_BuildTargetPlatformIcons:
  - m_BuildTarget: Android
    m_Icons:
    - m_Textures: []
      m_Width: 432
      m_Height: 432
      m_Kind: 2
      m_SubKind: 
    - m_Textures: []
      m_Width: 324
      m_Height: 324
      m_Kind: 2
      m_SubKind: 
    - m_Textures: []
      m_Width: 216
      m_Height: 216
      m_Kind: 2
      m_SubKind: 
    - m_Textures: []
      m_Width: 162
      m_Height: 162
      m_Kind: 2
      m_SubKind: 
    - m_Textures: []
      m_Width: 108
      m_Height: 108
      m_Kind: 2
      m_SubKind: 
    - m_Textures: []
      m_Width: 81
      m_Height: 81
      m_Kind: 2
      m_SubKind: 
    - m_Textures: []
      m_Width: 192
      m_Height: 192
      m_Kind: 1
      m_SubKind: 
    - m_Textures: []
      m_Width: 144
      m_Height: 144
      m_Kind: 1
      m_SubKind: 
    - m_Textures: []
      m_Width: 96
      m_Height: 96
      m_Kind: 1
      m_SubKind: 
    - m_Textures: []
      m_Width: 72
      m_Height: 72
      m_Kind: 1
      m_SubKind: 
    - m_Textures: []
      m_Width: 48
      m_Height: 48
      m_Kind: 1
      m_SubKind: 
    - m_Textures: []
      m_Width: 36
      m_Height: 36
      m_Kind: 1
      m_SubKind: 
    - m_Textures: []
      m_Width: 192
      m_Height: 192
      m_Kind: 0
      m_SubKind: 
    - m_Textures: []
      m_Width: 144
      m_Height: 144
      m_Kind: 0
      m_SubKind: 
    - m_Textures: []
      m_Width: 96
      m_Height: 96
      m_Kind: 0
      m_SubKind: 
    - m_Textures: []
      m_Width: 72
      m_Height: 72
      m_Kind: 0
      m_SubKind: 
    - m_Textures: []
      m_Width: 48
      m_Height: 48
      m_Kind: 0
      m_SubKind: 
    - m_Textures: []
      m_Width: 36
      m_Height: 36
      m_Kind: 0
      m_SubKind: 
  m_BuildTargetBatching:
  - m_BuildTarget: Standalone
    m_StaticBatching: 1
    m_DynamicBatching: 1
  - m_BuildTarget: tvOS
    m_StaticBatching: 1
    m_DynamicBatching: 0
  - m_BuildTarget: Android
    m_StaticBatching: 1
    m_DynamicBatching: 0
  - m_BuildTarget: iPhone
    m_StaticBatching: 1
    m_DynamicBatching: 0
  - m_BuildTarget: WebGL
    m_StaticBatching: 0
    m_DynamicBatching: 0
  m_BuildTargetShaderSettings: []
  m_BuildTargetGraphicsJobs:
  - m_BuildTarget: MacStandaloneSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: Switch
    m_GraphicsJobs: 1
  - m_BuildTarget: MetroSupport
    m_GraphicsJobs: 1
  - m_BuildTarget: AppleTVSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: BJMSupport
    m_GraphicsJobs: 1
  - m_BuildTarget: LinuxStandaloneSupport
    m_GraphicsJobs: 1
  - m_BuildTarget: PS4Player
    m_GraphicsJobs: 1
  - m_BuildTarget: iOSSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: WindowsStandaloneSupport
    m_GraphicsJobs: 1
  - m_BuildTarget: XboxOnePlayer
    m_GraphicsJobs: 1
  - m_BuildTarget: LuminSupport
    m_GraphicsJobs: 0
  - m_BuildTarget: AndroidPlayer
    m_GraphicsJobs: 0
  - m_BuildTarget: WebGLSupport
    m_GraphicsJobs: 0
  m_BuildTargetGraphicsJobMode:
  - m_BuildTarget: PS4Player
    m_GraphicsJobMode: 0
  - m_BuildTarget: XboxOnePlayer
    m_GraphicsJobMode: 0
  m_BuildTargetGraphicsAPIs:
  - m_BuildTarget: AndroidPlayer
    m_APIs: 150000000b000000
    m_Automatic: 1
  - m_BuildTarget: iOSSupport
    m_APIs: 10000000
    m_Automatic: 1
  - m_BuildTarget: AppleTVSupport
    m_APIs: 10000000
    m_Automatic: 1
  - m_BuildTarget: WebGLSupport
    m_APIs: 0b000000
    m_Automatic: 1
  m_BuildTargetVRSettings:
  - m_BuildTarget: Standalone
    m_Enabled: 0
    m_Devices:
    - Oculus
    - OpenVR
  m_DefaultShaderChunkSizeInMB: 16
  m_DefaultShaderChunkCount: 0
  openGLRequireES31: 0
  openGLRequireES31AEP: 0
  openGLRequireES32: 0
  m_TemplateCustomTags: {}
  mobileMTRendering:
    Android: 1
    iPhone: 1
    tvOS: 1
  m_BuildTargetGroupLightmapEncodingQuality:
  - m_BuildTarget: Android
    m_EncodingQuality: 1
  - m_BuildTarget: iPhone
    m_EncodingQuality: 1
  - m_BuildTarget: tvOS
    m_EncodingQuality: 1
  m_BuildTargetGroupHDRCubemapEncodingQuality:
  - m_BuildTarget: Android
    m_EncodingQuality: 1
  - m_BuildTarget: iPhone
    m_EncodingQuality: 1
  - m_BuildTarget: tvOS
    m_EncodingQuality: 1
  m_BuildTargetGroupLightmapSettings: []
  m_BuildTargetGroupLoadStoreDebugModeSettings: []
  m_BuildTargetNormalMapEncoding:
  - m_BuildTarget: Android
    m_Encoding: 1
  - m_BuildTarget: iPhone
    m_Encoding: 1
  - m_BuildTarget: tvOS
    m_Encoding: 1
  m_BuildTargetDefaultTextureCompressionFormat:
  - m_BuildTarget: Android
    m_Format: 3
  - m_BuildTarget: WebGL
    m_Format: 2
  playModeTestRunnerEnabled: 0
  runPlayModeTestAsEditModeTest: 0
  actionOnDotNetUnhandledException: 1
  enableInternalProfiler: 0
  logObjCUncaughtExceptions: 1
  enableCrashReportAPI: 0
  cameraUsageDescription: 
  locationUsageDescription: 
  microphoneUsageDescription: 
  bluetoothUsageDescription: 
  macOSTargetOSVersion: 10.13.0
  switchNMETAOverride: 
  switchNetLibKey: 
  switchSocketMemoryPoolSize: 6144
  switchSocketAllocatorPoolSize: 128
  switchSocketConcurrencyLimit: 14
  switchScreenResolutionBehavior: 2
  switchUseCPUProfiler: 0
  switchEnableFileSystemTrace: 0
  switchLTOSetting: 0
  switchApplicationID: 0x01004b9000490000
  switchNSODependencies: 
  switchCompilerFlags: 
  switchTitleNames_0: 
  switchTitleNames_1: 
  switchTitleNames_2: 
  switchTitleNames_3: 
  switchTitleNames_4: 
  switchTitleNames_5: 
  switchTitleNames_6: 
  switchTitleNames_7: 
  switchTitleNames_8: 
  switchTitleNames_9: 
  switchTitleNames_10: 
  switchTitleNames_11: 
  switchTitleNames_12: 
  switchTitleNames_13: 
  switchTitleNames_14: 
  switchTitleNames_15: 
  switchPublisherNames_0: 
  switchPublisherNames_1: 
  switchPublisherNames_2: 
  switchPublisherNames_3: 
  switchPublisherNames_4: 
  switchPublisherNames_5: 
  switchPublisherNames_6: 
  switchPublisherNames_7: 
  switchPublisherNames_8: 
  switchPublisherNames_9: 
  switchPublisherNames_10: 
  switchPublisherNames_11: 
  switchPublisherNames_12: 
  switchPublisherNames_13: 
  switchPublisherNames_14: 
  switchPublisherNames_15: 
  switchIcons_0: {fileID: 0}
  switchIcons_1: {fileID: 0}
  switchIcons_2: {fileID: 0}
  switchIcons_3: {fileID: 0}
  switchIcons_4: {fileID: 0}
  switchIcons_5: {fileID: 0}
  switchIcons_6: {fileID: 0}
  switchIcons_7: {fileID: 0}
  switchIcons_8: {fileID: 0}
  switchIcons_9: {fileID: 0}
  switchIcons_10: {fileID: 0}
  switchIcons_11: {fileID: 0}
  switchIcons_12: {fileID: 0}
  switchIcons_13: {fileID: 0}
  switchIcons_14: {fileID: 0}
  switchIcons_15: {fileID: 0}
  switchSmallIcons_0: {fileID: 0}
  switchSmallIcons_1: {fileID: 0}
  switchSmallIcons_2: {fileID: 0}
  switchSmallIcons_3: {fileID: 0}
  switchSmallIcons_4: {fileID: 0}
  switchSmallIcons_5: {fileID: 0}
  switchSmallIcons_6: {fileID: 0}
  switchSmallIcons_7: {fileID: 0}
  switchSmallIcons_8: {fileID: 0}
  switchSmallIcons_9: {fileID: 0}
  switchSmallIcons_10: {fileID: 0}
  switchSmallIcons_11: {fileID: 0}
  switchSmallIcons_12: {fileID: 0}
  switchSmallIcons_13: {fileID: 0}
  switchSmallIcons_14: {fileID: 0}
  switchSmallIcons_15: {fileID: 0}
  switchManualHTML: 
  switchAccessibleURLs: 
  switchLegalInformation: 
  switchMainThreadStackSize: 1048576
  switchPresenceGroupId: 
  switchLogoHandling: 0
  switchReleaseVersion: 0
  switchDisplayVersion: 1.0.0
  switchStartupUserAccount: 0
  switchSupportedLanguagesMask: 0
  switchLogoType: 0
  switchApplicationErrorCodeCategory: 
  switchUserAccountSaveDataSize: 0
  switchUserAccountSaveDataJournalSize: 0
  switchApplicationAttribute: 0
  switchCardSpecSize: -1
  switchCardSpecClock: -1
  switchRatingsMask: 0
  switchRatingsInt_0: 0
  switchRatingsInt_1: 0
  switchRatingsInt_2: 0
  switchRatingsInt_3: 0
  switchRatingsInt_4: 0
  switchRatingsInt_5: 0
  switchRatingsInt_6: 0
  switchRatingsInt_7: 0
  switchRatingsInt_8: 0
  switchRatingsInt_9: 0
  switchRatingsInt_10: 0
  switchRatingsInt_11: 0
  switchRatingsInt_12: 0
  switchLocalCommunicationIds_0: 
  switchLocalCommunicationIds_1: 
  switchLocalCommunicationIds_2: 
  switchLocalCommunicationIds_3: 
  switchLocalCommunicationIds_4: 
  switchLocalCommunicationIds_5: 
  switchLocalCommunicationIds_6: 
  switchLocalCommunicationIds_7: 
  switchParentalControl: 0
  switchAllowsScreenshot: 1
  switchAllowsVideoCapturing: 1
  switchAllowsRuntimeAddOnContentInstall: 0
  switchDataLossConfirmation: 0
  switchUserAccountLockEnabled: 0
  switchSystemResourceMemory: 16777216
  switchSupportedNpadStyles: 22
  switchNativeFsCacheSize: 32
  switchIsHoldTypeHorizontal: 0
  switchSupportedNpadCount: 8
  switchEnableTouchScreen: 1
  switchSocketConfigEnabled: 0
  switchTcpInitialSendBufferSize: 32
  switchTcpInitialReceiveBufferSize: 64
  switchTcpAutoSendBufferSizeMax: 256
  switchTcpAutoReceiveBufferSizeMax: 256
  switchUdpSendBufferSize: 9
  switchUdpReceiveBufferSize: 42
  switchSocketBufferEfficiency: 4
  switchSocketInitializeEnabled: 1
  switchNetworkInterfaceManagerInitializeEnabled: 1
  switchDisableHTCSPlayerConnection: 0
  switchUseNewStyleFilepaths: 1
  switchUseLegacyFmodPriorities: 0
  switchUseMicroSleepForYield: 1
  switchEnableRamDiskSupport: 0
  switchMicroSleepForYieldTime: 25
  switchRamDiskSpaceSize: 12
  ps4NPAgeRating: 12
  ps4NPTitleSecret: 
  ps4NPTrophyPackPath: 
  ps4ParentalLevel: 11
  ps4ContentID: ED1633-NPXX51362_00-0000000000000000
  ps4Category: 0
  ps4MasterVersion: 01.00
  ps4AppVersion: 01.00
  ps4AppType: 0
  ps4ParamSfxPath: 
  ps4VideoOutPixelFormat: 0
  ps4VideoOutInitialWidth: 1920
  ps4VideoOutBaseModeInitialWidth: 1920
  ps4VideoOutReprojectionRate: 60
  ps4PronunciationXMLPath: 
  ps4PronunciationSIGPath: 
  ps4BackgroundImagePath: 
  ps4StartupImagePath: 
  ps4StartupImagesFolder: 
  ps4IconImagesFolder: 
  ps4SaveDataImagePath: 
  ps4SdkOverride: 
  ps4BGMPath: 
  ps4ShareFilePath: 
  ps4ShareOverlayImagePath: 
  ps4PrivacyGuardImagePath: 
  ps4ExtraSceSysFile: 
  ps4NPtitleDatPath: 
  ps4RemotePlayKeyAssignment: -1
  ps4RemotePlayKeyMappingDir: 
  ps4PlayTogetherPlayerCount: 0
  ps4EnterButtonAssignment: 1
  ps4ApplicationParam1: 0
  ps4ApplicationParam2: 0
  ps4ApplicationParam3: 0
  ps4ApplicationParam4: 0
  ps4DownloadDataSize: 0
  ps4GarlicHeapSize: 2048
  ps4ProGarlicHeapSize: 2560
  playerPrefsMaxSize: 32768
  ps4Passcode: frAQBc8Wsa1xVPfvJcrgRYwTiizs2trQ
  ps4pnSessions: 1
  ps4pnPresence: 1
  ps4pnFriends: 1
  ps4pnGameCustomData: 1
  playerPrefsSupport: 0
  enableApplicationExit: 0
  resetTempFolder: 1
  restrictedAudioUsageRights: 0
  ps4UseResolutionFallback: 0
  ps4ReprojectionSupport: 0
  ps4UseAudio3dBackend: 0
  ps4UseLowGarlicFragmentationMode: 1
  ps4SocialScreenEnabled: 0
  ps4ScriptOptimizationLevel: 0
  ps4Audio3dVirtualSpeakerCount: 14
  ps4attribCpuUsage: 0
  ps4PatchPkgPath: 
  ps4PatchLatestPkgPath: 
  ps4PatchChangeinfoPath: 
  ps4PatchDayOne: 0
  ps4attribUserManagement: 0
  ps4attribMoveSupport: 0
  ps4attrib3DSupport: 0
  ps4attribShareSupport: 0
  ps4attribExclusiveVR: 0
  ps4disableAutoHideSplash: 0
  ps4videoRecordingFeaturesUsed: 0
  ps4contentSearchFeaturesUsed: 0
  ps4CompatibilityPS5: 0
  ps4AllowPS5Detection: 0
  ps4GPU800MHz: 1
  ps4attribEyeToEyeDistanceSettingVR: 0
  ps4IncludedModules: []
  ps4attribVROutputEnabled: 0
  monoEnv: 
  splashScreenBackgroundSourceLandscape: {fileID: 0}
  splashScreenBackgroundSourcePortrait: {fileID: 0}
  blurSplashScreenBackground: 1
  spritePackerPolicy: 
  webGLMemorySize: 16
  webGLExceptionSupport: 1
  webGLNameFilesAsHashes: 0
  webGLShowDiagnostics: 0
  webGLDataCaching: 1
  webGLDebugSymbols: 0
  webGLEmscriptenArgs: 
  webGLModulesDirectory: 
  webGLTemplate: APPLICATION:Default
  webGLAnalyzeBuildSize: 0
  webGLUseEmbeddedResources: 0
  webGLCompressionFormat: 1
  webGLWasmArithmeticExceptions: 0
  webGLLinkerTarget: 1
  webGLThreadsSupport: 0
  webGLDecompressionFallback: 0
  webGLInitialMemorySize: 128
  webGLMaximumMemorySize: 512
  webGLMemoryGrowthMode: 2
  webGLMemoryLinearGrowthStep: 16
  webGLMemoryGeometricGrowthStep: 0.2
  webGLMemoryGeometricGrowthCap: 96
  webGLPowerPreference: 2
  scriptingDefineSymbols:
    Android: UNITY_POST_PROCESSING_STACK_V2
    EmbeddedLinux: UNITY_POST_PROCESSING_STACK_V2
    GameCoreXboxOne: UNITY_POST_PROCESSING_STACK_V2
    Nintendo Switch: UNITY_POST_PROCESSING_STACK_V2
    PS4: UNITY_POST_PROCESSING_STACK_V2
    PS5: UNITY_POST_PROCESSING_STACK_V2
    QNX: UNITY_POST_PROCESSING_STACK_V2
    Stadia: UNITY_POST_PROCESSING_STACK_V2
    Standalone: UNITY_POST_PROCESSING_STACK_V2
    VisionOS: UNITY_POST_PROCESSING_STACK_V2
    WebGL: UNITY_POST_PROCESSING_STACK_V2
    XboxOne: UNITY_POST_PROCESSING_STACK_V2
    tvOS: UNITY_POST_PROCESSING_STACK_V2
  additionalCompilerArguments: {}
  platformArchitecture: {}
  scriptingBackend: {}
  il2cppCompilerConfiguration: {}
  il2cppCodeGeneration: {}
  managedStrippingLevel:
    EmbeddedLinux: 1
    GameCoreScarlett: 1
    GameCoreXboxOne: 1
    Nintendo Switch: 1
    PS4: 1
    PS5: 1
    QNX: 1
    Stadia: 1
    VisionOS: 1
    WebGL: 1
    Windows Store Apps: 1
    XboxOne: 1
    iPhone: 1
    tvOS: 1
  incrementalIl2cppBuild: {}
  suppressCommonWarnings: 1
  allowUnsafeCode: 0
  useDeterministicCompilation: 1
  additionalIl2CppArgs: 
  scriptingRuntimeVersion: 1
  gcIncremental: 1
  gcWBarrierValidation: 0
  apiCompatibilityLevelPerPlatform: {}
  m_RenderingPath: 1
  m_MobileRenderingPath: 1
  metroPackageName: cccc
  metroPackageVersion: 
  metroCertificatePath: 
  metroCertificatePassword: 
  metroCertificateSubject: 
  metroCertificateIssuer: 
  metroCertificateNotAfter: 0000000000000000
  metroApplicationDescription: cccc
  wsaImages: {}
  metroTileShortName: 
  metroTileShowName: 0
  metroMediumTileShowName: 0
  metroLargeTileShowName: 0
  metroWideTileShowName: 0
  metroSupportStreamingInstall: 0
  metroLastRequiredScene: 0
  metroDefaultTileSize: 1
  metroTileForegroundText: 2
  metroTileBackgroundColor: {r: 0.13333334, g: 0.17254902, b: 0.21568628, a: 0}
  metroSplashScreenBackgroundColor: {r: 0.12941177, g: 0.17254902, b: 0.21568628, a: 1}
  metroSplashScreenUseBackgroundColor: 0
  syncCapabilities: 0
  platformCapabilities: {}
  metroTargetDeviceFamilies: {}
  metroFTAName: 
  metroFTAFileTypes: []
  metroProtocolName: 
  vcxProjDefaultLanguage: 
  XboxOneProductId: 
  XboxOneUpdateKey: 
  XboxOneSandboxId: 
  XboxOneContentId: 
  XboxOneTitleId: 
  XboxOneSCId: 
  XboxOneGameOsOverridePath: 
  XboxOnePackagingOverridePath: 
  XboxOneAppManifestOverridePath: 
  XboxOneVersion: 1.0.0.0
  XboxOnePackageEncryption: 0
  XboxOnePackageUpdateGranularity: 2
  XboxOneDescription: 
  XboxOneLanguage:
  - enus
  XboxOneCapability: []
  XboxOneGameRating: {}
  XboxOneIsContentPackage: 0
  XboxOneEnhancedXboxCompatibilityMode: 0
  XboxOneEnableGPUVariability: 1
  XboxOneSockets: {}
  XboxOneSplashScreen: {fileID: 0}
  XboxOneAllowedProductIds: []
  XboxOnePersistentLocalStorageSize: 0
  XboxOneXTitleMemory: 8
  XboxOneOverrideIdentityName: 
  XboxOneOverrideIdentityPublisher: 
  vrEditorSettings: {}
  cloudServicesEnabled:
    UNet: 1
  luminIcon:
    m_Name: 
    m_ModelFolderPath: 
    m_PortalFolderPath: 
  luminCert:
    m_CertPath: 
    m_SignPackage: 1
  luminIsChannelApp: 0
  luminVersion:
    m_VersionCode: 1
    m_VersionName: 
  hmiPlayerDataPath: 
  hmiForceSRGBBlit: 1
  embeddedLinuxEnableGamepadInput: 1
  hmiLogStartupTiming: 0
  hmiCpuConfiguration: 
  apiCompatibilityLevel: 6
  activeInputHandler: 2
  windowsGamepadBackendHint: 0
  cloudProjectId: 07859ae6-4eec-42fb-bff9-02c1c08c9e2e
  framebufferDepthMemorylessMode: 0
  qualitySettingsNames: []
  projectName: cccc
  organizationId: ilya_sevi
  cloudEnabled: 0
  legacyClampBlendShapeWeights: 0
  hmiLoadingImage: {fileID: 0}
  platformRequiresReadableAssets: 0
  virtualTexturingSupportEnabled: 0
  insecureHttpOption: 0


1.2 Текст файла данных «InputManager.asset».
Назначение: файл настроек проекта Unity.
Язык разметки: YAML.
Код разметки:
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!13 &1
InputManager:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Axes:
  - serializedVersion: 3
    m_Name: Horizontal
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: left
    positiveButton: right
    altNegativeButton: a
    altPositiveButton: d
    gravity: 3
    dead: 0.001
    sensitivity: 3
    snap: 1
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Vertical
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: down
    positiveButton: up
    altNegativeButton: s
    altPositiveButton: w
    gravity: 3
    dead: 0.001
    sensitivity: 3
    snap: 1
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire1
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left ctrl
    altNegativeButton: 
    altPositiveButton: mouse 0
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire2
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left alt
    altNegativeButton: 
    altPositiveButton: mouse 1
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire3
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left shift
    altNegativeButton: 
    altPositiveButton: mouse 2
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Jump
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: space
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Mouse X
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0
    sensitivity: 0.1
    snap: 0
    invert: 0
    type: 1
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Mouse Y
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0
    sensitivity: 0.1
    snap: 0
    invert: 0
    type: 1
    axis: 1
    joyNum: 0
  - serializedVersion: 3
    m_Name: Mouse ScrollWheel
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0
    sensitivity: 0.1
    snap: 0
    invert: 0
    type: 1
    axis: 2
    joyNum: 0
  - serializedVersion: 3
    m_Name: Horizontal
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0.19
    sensitivity: 1
    snap: 0
    invert: 0
    type: 2
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Vertical
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: 
    altNegativeButton: 
    altPositiveButton: 
    gravity: 0
    dead: 0.19
    sensitivity: 1
    snap: 0
    invert: 1
    type: 2
    axis: 1
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire1
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 0
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire2
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 1
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Fire3
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 2
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Jump
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: joystick button 3
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Submit
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: return
    altNegativeButton: 
    altPositiveButton: joystick button 0
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Submit
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: enter
    altNegativeButton: 
    altPositiveButton: space
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Cancel
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: escape
    altNegativeButton: 
    altPositiveButton: joystick button 1
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Enable Debug Button 1
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left ctrl
    altNegativeButton: 
    altPositiveButton: joystick button 8
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Enable Debug Button 2
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: backspace
    altNegativeButton: 
    altPositiveButton: joystick button 9
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Reset
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left alt
    altNegativeButton: 
    altPositiveButton: joystick button 1
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Next
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: page down
    altNegativeButton: 
    altPositiveButton: joystick button 5
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Previous
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: page up
    altNegativeButton: 
    altPositiveButton: joystick button 4
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Validate
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: return
    altNegativeButton: 
    altPositiveButton: joystick button 0
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Persistent
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: right shift
    altNegativeButton: 
    altPositiveButton: joystick button 2
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Multiplier
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: 
    positiveButton: left shift
    altNegativeButton: 
    altPositiveButton: joystick button 3
    gravity: 0
    dead: 0
    sensitivity: 0
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Horizontal
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: left
    positiveButton: right
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Vertical
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: down
    positiveButton: up
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 0
    axis: 0
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Vertical
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: down
    positiveButton: up
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 2
    axis: 6
    joyNum: 0
  - serializedVersion: 3
    m_Name: Debug Horizontal
    descriptiveName: 
    descriptiveNegativeName: 
    negativeButton: left
    positiveButton: right
    altNegativeButton: 
    altPositiveButton: 
    gravity: 1000
    dead: 0.001
    sensitivity: 1000
    snap: 0
    invert: 0
    type: 2
    axis: 5
    joyNum: 0
  m_UsePhysicalKeys: 1


1.3 Текст файла данных «DynamicsManager.asset».
Назначение: файл настроек проекта Unity.
Язык разметки: YAML.
Код разметки:
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!55 &1
PhysicsManager:
  m_ObjectHideFlags: 0
  serializedVersion: 11
  m_Gravity: {x: 0, y: -9.81, z: 0}
  m_DefaultMaterial: {fileID: 0}
  m_BounceThreshold: 2
  m_SleepThreshold: 0.005
  m_DefaultContactOffset: 0.01
  m_DefaultSolverIterations: 6
  m_DefaultSolverVelocityIterations: 1
  m_QueriesHitBackfaces: 0
  m_QueriesHitTriggers: 1
  m_EnableAdaptiveForce: 0
  m_ClothInterCollisionDistance: 0
  m_ClothInterCollisionStiffness: 0
  m_ContactsGeneration: 1
  m_LayerCollisionMatrix: ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
  m_AutoSimulation: 1
  m_AutoSyncTransforms: 0
  m_ReuseCollisionCallbacks: 1
  m_ClothInterCollisionSettingsToggle: 0
  m_ContactPairsMode: 0
  m_BroadphaseType: 0
  m_WorldBounds:
    m_Center: {x: 0, y: 0, z: 0}
    m_Extent: {x: 250, y: 250, z: 250}
  m_WorldSubdivisions: 8
  m_FrictionType: 0
  m_EnableEnhancedDeterminism: 0
  m_EnableUnifiedHeightmaps: 1
  m_DefaultMaxAngluarSpeed: 7


1.4 Текст файла данных «TagManager.asset».
Назначение: файл настроек проекта Unity.
Язык разметки: YAML.
Код разметки:
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!78 &1
TagManager:
  serializedVersion: 2
  tags:
  - Fish
  layers:
  - Default
  - TransparentFX
  - Ignore Raycast
  - Pol
  - Water
  - UI
  - Labirint
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  m_SortingLayers:
  - name: Default
    uniqueID: 0
    locked: 0


1.5 Текст файла данных «TimeManager.asset».
Назначение: файл настроек проекта Unity.
Язык разметки: YAML.
Код разметки:
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!5 &1
TimeManager:
  m_ObjectHideFlags: 0
  Fixed Timestep: 0.02
  Maximum Allowed Timestep: 0.33333334
  m_TimeScale: 1
  Maximum Particle Timestep: 0.03


1.6 Текст файла данных «QualitySettings.asset».
Назначение: файл настроек проекта Unity.
Язык разметки: YAML.
Код разметки:
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!47 &1
QualitySettings:
  m_ObjectHideFlags: 0
  serializedVersion: 5
  m_CurrentQuality: 1
  m_QualitySettings:
  - serializedVersion: 3
    name: Very Low
    pixelLightCount: 0
    shadows: 0
    shadowResolution: 0
    shadowProjection: 1
    shadowCascades: 1
    shadowDistance: 15
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 0
    skinWeights: 1
    globalTextureMipmapLimit: 1
    textureMipmapLimitSettings: []
    anisotropicTextures: 0
    antiAliasing: 0
    softParticles: 0
    softVegetation: 0
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 0
    useLegacyDetailDistribution: 1
    vSyncCount: 0
    realtimeGICPUUsage: 25
    lodBias: 0.3
    maximumLODLevel: 0
    enableLODCrossFade: 1
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 4
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    terrainQualityOverrides: 0
    terrainPixelError: 1
    terrainDetailDensityScale: 1
    terrainBasemapDistance: 1000
    terrainDetailDistance: 80
    terrainTreeDistance: 5000
    terrainBillboardStart: 50
    terrainFadeLength: 5
    terrainMaxTrees: 50
    excludedTargetPlatforms:
    - Server
  - serializedVersion: 3
    name: MobileLow
    pixelLightCount: 1
    shadows: 0
    shadowResolution: 0
    shadowProjection: 0
    shadowCascades: 1
    shadowDistance: 30
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 0
    skinWeights: 4
    globalTextureMipmapLimit: 1
    textureMipmapLimitSettings: []
    anisotropicTextures: 1
    antiAliasing: 0
    softParticles: 0
    softVegetation: 1
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 1
    useLegacyDetailDistribution: 1
    vSyncCount: 0
    realtimeGICPUUsage: 100
    lodBias: 1
    maximumLODLevel: 0
    enableLODCrossFade: 1
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 4096
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    terrainQualityOverrides: 0
    terrainPixelError: 1
    terrainDetailDensityScale: 1
    terrainBasemapDistance: 1000
    terrainDetailDistance: 80
    terrainTreeDistance: 5000
    terrainBillboardStart: 50
    terrainFadeLength: 5
    terrainMaxTrees: 50
    excludedTargetPlatforms:
    - Standalone
    - Server
    - Android
  - serializedVersion: 3
    name: Low
    pixelLightCount: 0
    shadows: 0
    shadowResolution: 0
    shadowProjection: 1
    shadowCascades: 1
    shadowDistance: 20
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 0
    skinWeights: 2
    globalTextureMipmapLimit: 0
    textureMipmapLimitSettings: []
    anisotropicTextures: 0
    antiAliasing: 0
    softParticles: 0
    softVegetation: 0
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 0
    useLegacyDetailDistribution: 1
    vSyncCount: 0
    realtimeGICPUUsage: 25
    lodBias: 0.4
    maximumLODLevel: 0
    enableLODCrossFade: 1
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 16
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    terrainQualityOverrides: 0
    terrainPixelError: 1
    terrainDetailDensityScale: 1
    terrainBasemapDistance: 1000
    terrainDetailDistance: 80
    terrainTreeDistance: 5000
    terrainBillboardStart: 50
    terrainFadeLength: 5
    terrainMaxTrees: 50
    excludedTargetPlatforms:
    - Android
  - serializedVersion: 3
    name: Medium
    pixelLightCount: 1
    shadows: 1
    shadowResolution: 0
    shadowProjection: 1
    shadowCascades: 1
    shadowDistance: 20
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 0
    skinWeights: 2
    globalTextureMipmapLimit: 0
    textureMipmapLimitSettings: []
    anisotropicTextures: 1
    antiAliasing: 0
    softParticles: 0
    softVegetation: 0
    realtimeReflectionProbes: 0
    billboardsFaceCameraPosition: 0
    useLegacyDetailDistribution: 1
    vSyncCount: 1
    realtimeGICPUUsage: 25
    lodBias: 0.7
    maximumLODLevel: 0
    enableLODCrossFade: 1
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 64
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    terrainQualityOverrides: 0
    terrainPixelError: 1
    terrainDetailDensityScale: 1
    terrainBasemapDistance: 1000
    terrainDetailDistance: 80
    terrainTreeDistance: 5000
    terrainBillboardStart: 50
    terrainFadeLength: 5
    terrainMaxTrees: 50
    excludedTargetPlatforms: []
  - serializedVersion: 3
    name: High
    pixelLightCount: 2
    shadows: 2
    shadowResolution: 1
    shadowProjection: 1
    shadowCascades: 2
    shadowDistance: 40
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 1
    skinWeights: 2
    globalTextureMipmapLimit: 0
    textureMipmapLimitSettings: []
    anisotropicTextures: 1
    antiAliasing: 0
    softParticles: 0
    softVegetation: 1
    realtimeReflectionProbes: 1
    billboardsFaceCameraPosition: 1
    useLegacyDetailDistribution: 1
    vSyncCount: 1
    realtimeGICPUUsage: 50
    lodBias: 1
    maximumLODLevel: 0
    enableLODCrossFade: 1
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 256
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    terrainQualityOverrides: 0
    terrainPixelError: 1
    terrainDetailDensityScale: 1
    terrainBasemapDistance: 1000
    terrainDetailDistance: 80
    terrainTreeDistance: 5000
    terrainBillboardStart: 50
    terrainFadeLength: 5
    terrainMaxTrees: 50
    excludedTargetPlatforms: []
  - serializedVersion: 3
    name: Very High
    pixelLightCount: 3
    shadows: 2
    shadowResolution: 2
    shadowProjection: 1
    shadowCascades: 2
    shadowDistance: 70
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 1
    skinWeights: 4
    globalTextureMipmapLimit: 0
    textureMipmapLimitSettings: []
    anisotropicTextures: 2
    antiAliasing: 2
    softParticles: 1
    softVegetation: 1
    realtimeReflectionProbes: 1
    billboardsFaceCameraPosition: 1
    useLegacyDetailDistribution: 1
    vSyncCount: 1
    realtimeGICPUUsage: 50
    lodBias: 1.5
    maximumLODLevel: 0
    enableLODCrossFade: 1
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 1024
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    terrainQualityOverrides: 0
    terrainPixelError: 1
    terrainDetailDensityScale: 1
    terrainBasemapDistance: 1000
    terrainDetailDistance: 80
    terrainTreeDistance: 5000
    terrainBillboardStart: 50
    terrainFadeLength: 5
    terrainMaxTrees: 50
    excludedTargetPlatforms:
    - Standalone
  - serializedVersion: 3
    name: Ultra
    pixelLightCount: 4
    shadows: 2
    shadowResolution: 2
    shadowProjection: 1
    shadowCascades: 4
    shadowDistance: 150
    shadowNearPlaneOffset: 3
    shadowCascade2Split: 0.33333334
    shadowCascade4Split: {x: 0.06666667, y: 0.2, z: 0.46666667}
    shadowmaskMode: 1
    skinWeights: 4
    globalTextureMipmapLimit: 0
    textureMipmapLimitSettings: []
    anisotropicTextures: 2
    antiAliasing: 0
    softParticles: 1
    softVegetation: 1
    realtimeReflectionProbes: 1
    billboardsFaceCameraPosition: 1
    useLegacyDetailDistribution: 1
    vSyncCount: 1
    realtimeGICPUUsage: 100
    lodBias: 2
    maximumLODLevel: 0
    enableLODCrossFade: 1
    streamingMipmapsActive: 0
    streamingMipmapsAddAllCameras: 1
    streamingMipmapsMemoryBudget: 512
    streamingMipmapsRenderersPerFrame: 512
    streamingMipmapsMaxLevelReduction: 2
    streamingMipmapsMaxFileIORequests: 1024
    particleRaycastBudget: 4096
    asyncUploadTimeSlice: 2
    asyncUploadBufferSize: 16
    asyncUploadPersistentBuffer: 1
    resolutionScalingFixedDPIFactor: 1
    customRenderPipeline: {fileID: 0}
    terrainQualityOverrides: 0
    terrainPixelError: 1
    terrainDetailDensityScale: 1
    terrainBasemapDistance: 1000
    terrainDetailDistance: 80
    terrainTreeDistance: 5000
    terrainBillboardStart: 50
    terrainFadeLength: 5
    terrainMaxTrees: 50
    excludedTargetPlatforms: []
  m_TextureMipmapLimitGroupNames: []
  m_PerPlatformDefaultQuality:
    Android: 2
    GameCoreScarlett: 5
    GameCoreXboxOne: 5
    Lumin: 5
    Nintendo 3DS: 5
    Nintendo Switch: 5
    PS4: 5
    PS5: 5
    Server: 0
    Stadia: 5
    Standalone: 5
    WebGL: 1
    Windows Store Apps: 5
    XboxOne: 5
    iPhone: 2
    tvOS: 2


1.7 Текст файла данных «GraphicsSettings.asset».
Назначение: файл настроек проекта Unity.
Язык разметки: YAML.
Код разметки:
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!30 &1
GraphicsSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 15
  m_Deferred:
    m_Mode: 1
    m_Shader: {fileID: 69, guid: 0000000000000000f000000000000000, type: 0}
  m_DeferredReflections:
    m_Mode: 1
    m_Shader: {fileID: 74, guid: 0000000000000000f000000000000000, type: 0}
  m_ScreenSpaceShadows:
    m_Mode: 1
    m_Shader: {fileID: 64, guid: 0000000000000000f000000000000000, type: 0}
  m_DepthNormals:
    m_Mode: 1
    m_Shader: {fileID: 62, guid: 0000000000000000f000000000000000, type: 0}
  m_MotionVectors:
    m_Mode: 1
    m_Shader: {fileID: 75, guid: 0000000000000000f000000000000000, type: 0}
  m_LightHalo:
    m_Mode: 1
    m_Shader: {fileID: 105, guid: 0000000000000000f000000000000000, type: 0}
  m_LensFlare:
    m_Mode: 1
    m_Shader: {fileID: 102, guid: 0000000000000000f000000000000000, type: 0}
  m_VideoShadersIncludeMode: 2
  m_AlwaysIncludedShaders:
  - {fileID: 7, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 15104, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 15105, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 15106, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 10753, guid: 0000000000000000f000000000000000, type: 0}
  - {fileID: 10770, guid: 0000000000000000f000000000000000, type: 0}
  m_PreloadedShaders: []
  m_PreloadShadersBatchTimeLimit: -1
  m_SpritesDefaultMaterial: {fileID: 10754, guid: 0000000000000000f000000000000000, type: 0}
  m_CustomRenderPipeline: {fileID: 11400000, guid: d24f4323f929cbe4c9e86acd634007cd, type: 2}
  m_TransparencySortMode: 0
  m_TransparencySortAxis: {x: 0, y: 0, z: 1}
  m_DefaultRenderingPath: 1
  m_DefaultMobileRenderingPath: 1
  m_TierSettings: []
  m_LightmapStripping: 0
  m_FogStripping: 0
  m_InstancingStripping: 0
  m_BrgStripping: 0
  m_LightmapKeepPlain: 1
  m_LightmapKeepDirCombined: 1
  m_LightmapKeepDynamicPlain: 1
  m_LightmapKeepDynamicDirCombined: 1
  m_LightmapKeepShadowMask: 1
  m_LightmapKeepSubtractive: 1
  m_FogKeepLinear: 1
  m_FogKeepExp: 1
  m_FogKeepExp2: 1
  m_AlbedoSwatchInfos: []
  m_LightsUseLinearIntensity: 1
  m_LightsUseColorTemperature: 1
  m_DefaultRenderingLayerMask: 1
  m_LogWhenShaderIsCompiled: 0
  m_SRPDefaultSettings:
    UnityEngine.Rendering.Universal.UniversalRenderPipeline: {fileID: 11400000, guid: 1b41dc5619744c74783d1b0e87bfea6f, type: 2}
  m_LightProbeOutsideHullStrategy: 0
  m_CameraRelativeLightCulling: 0
  m_CameraRelativeShadowCulling: 0


1.8 Текст файла данных «Physics2DSettings.asset».
Назначение: файл настроек проекта Unity.
Язык разметки: YAML.
Код разметки:
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!19 &1
Physics2DSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 4
  m_Gravity: {x: 0, y: -9.81}
  m_DefaultMaterial: {fileID: 0}
  m_VelocityIterations: 8
  m_PositionIterations: 3
  m_VelocityThreshold: 1
  m_MaxLinearCorrection: 0.2
  m_MaxAngularCorrection: 8
  m_MaxTranslationSpeed: 100
  m_MaxRotationSpeed: 360
  m_BaumgarteScale: 0.2
  m_BaumgarteTimeOfImpactScale: 0.75
  m_TimeToSleep: 0.5
  m_LinearSleepTolerance: 0.01
  m_AngularSleepTolerance: 2
  m_DefaultContactOffset: 0.01
  m_JobOptions:
    serializedVersion: 2
    useMultithreading: 0
    useConsistencySorting: 0
    m_InterpolationPosesPerJob: 100
    m_NewContactsPerJob: 30
    m_CollideContactsPerJob: 100
    m_ClearFlagsPerJob: 200
    m_ClearBodyForcesPerJob: 200
    m_SyncDiscreteFixturesPerJob: 50
    m_SyncContinuousFixturesPerJob: 50
    m_FindNearestContactsPerJob: 100
    m_UpdateTriggerContactsPerJob: 100
    m_IslandSolverCostThreshold: 100
    m_IslandSolverBodyCostScale: 1
    m_IslandSolverContactCostScale: 10
    m_IslandSolverJointCostScale: 10
    m_IslandSolverBodiesPerJob: 50
    m_IslandSolverContactsPerJob: 50
  m_AutoSimulation: 1
  m_QueriesHitTriggers: 1
  m_QueriesStartInColliders: 1
  m_CallbacksOnDisable: 1
  m_ReuseCollisionCallbacks: 1
  m_AutoSyncTransforms: 0
  m_AlwaysShowColliders: 0
  m_ShowColliderSleep: 1
  m_ShowColliderContacts: 0
  m_ShowColliderAABB: 0
  m_ContactArrowScale: 0.2
  m_ColliderAwakeColor: {r: 0.5686275, g: 0.95686275, b: 0.54509807, a: 0.7529412}
  m_ColliderAsleepColor: {r: 0.5686275, g: 0.95686275, b: 0.54509807, a: 0.36078432}
  m_ColliderContactColor: {r: 1, g: 0, b: 1, a: 0.6862745}
  m_ColliderAABBColor: {r: 1, g: 1, b: 0, a: 0.2509804}
  m_LayerCollisionMatrix: ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff


1.9 Текст файла данных «AudioManager.asset».
Назначение: файл настроек проекта Unity.
Язык разметки: YAML.
Код разметки:
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!11 &1
AudioManager:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_Volume: 1
  Rolloff Scale: 1
  Doppler Factor: 1
  Default Speaker Mode: 2
  m_SampleRate: 0
  m_DSPBufferSize: 1024
  m_VirtualVoiceCount: 512
  m_RealVoiceCount: 32
  m_SpatializerPlugin: 
  m_AmbisonicDecoderPlugin: 
  m_DisableAudio: 0
  m_VirtualizeEffects: 1
  m_RequestedDSPBufferSize: 1024


1.10 Текст файла данных «URPProjectSettings.asset».
Назначение: файл настроек проекта Unity.
Язык разметки: YAML.
Код разметки:
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &1
MonoBehaviour:
  m_ObjectHideFlags: 61
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 247994e1f5a72c2419c26a37e9334c01, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_LastMaterialVersion: 7


1.11 Текст файла данных «ShaderGraphSettings.asset».
Назначение: файл настроек проекта Unity.
Язык разметки: YAML.
Код разметки:
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &1
MonoBehaviour:
  m_ObjectHideFlags: 53
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: de02f9e1d18f588468e474319d09a723, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  shaderVariantLimit: 2048
  customInterpolatorErrorThreshold: 32
  customInterpolatorWarningThreshold: 16


2 ТЕКСТЫ ПРОГРАММ СКРИПТОВ

2.1 Текст программы «AudioOptimizer.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEditor;
using UnityEngine;

public static class AudioOptimizer
{
    private const string SkipToken = "_NoOptAudio";

    [MenuItem("Tools/Audio Optimizer/Preview")]
    private static void Preview()
    {
        string[] guids = AssetDatabase.FindAssets("t:AudioClip");
        int count = 0;

        foreach (var guid in guids)
        {
            string path = AssetDatabase.GUIDToAssetPath(guid);
            var importer = AssetImporter.GetAtPath(path) as AudioImporter;
            if (importer == null) continue;
            if (path.Contains(SkipToken)) continue;

            var settings = importer.defaultSampleSettings;

            bool needChange =
                settings.loadType != AudioClipLoadType.Streaming ||
                settings.compressionFormat != AudioCompressionFormat.Vorbis ||
                settings.quality > 0.6f; // 0..1

            if (needChange)
            {
                Debug.Log($"[Preview Audio] {path}  loadType={settings.loadType}  fmt={settings.compressionFormat}  q={settings.quality}");
                count++;
            }
        }

        Debug.Log($"[AudioOptimizer] Preview done. Clips to change: {count}");
    }

    [MenuItem("Tools/Audio Optimizer/Apply Mobile Settings")]
    private static void Apply()
    {
        if (!EditorUtility.DisplayDialog(
                "Audio Optimizer",
                "Оптимизировать аудио под мобилки (Streaming + Vorbis 0.5)?\n" +
                "Сделай бэкап проекта на всякий случай.",
                "Да", "Отмена"))
            return;

        string[] guids = AssetDatabase.FindAssets("t:AudioClip");
        int modified = 0;

        AssetDatabase.StartAssetEditing();
        try
        {
            foreach (var guid in guids)
            {
                string path = AssetDatabase.GUIDToAssetPath(guid);
                var importer = AssetImporter.GetAtPath(path) as AudioImporter;
                if (importer == null) continue;
                if (path.Contains(SkipToken)) continue;

                var settings = importer.defaultSampleSettings;

                bool changed = false;

                // длинные треки → Streaming, короткие SFX можно оставить DecompressOnLoad
                settings.loadType = AudioClipLoadType.Streaming;

                // Vorbis — нормальный формат для музыки/эффектов
                settings.compressionFormat = AudioCompressionFormat.Vorbis;
                settings.quality = 0.5f; // 0..1

                importer.defaultSampleSettings = settings;
                changed = true;

                if (changed)
                {
                    Debug.Log($"[AudioOptimizer] Modified: {path}");
                    AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);
                    modified++;
                }
            }
        }
        finally
        {
            AssetDatabase.StopAssetEditing();
        }

        Debug.Log($"[AudioOptimizer] Done. Modified clips: {modified}");
    }
}


2.2 Текст программы «BatchAddComponents.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using UnityEditor;

public class BatchAddComponents : MonoBehaviour
{
    [MenuItem("Tools/Maze/Add MeshCollider To All Children")]
    private static void AddMeshColliderToChildren()
    {
        // 1. �����, ����� ��� ������� �������� ������ ���������
        if (Selection.activeGameObject == null)
        {
            Debug.LogWarning("������ �������� ������ ��������� � Hierarchy � ����� ������� �������.");
            return;
        }

        GameObject root = Selection.activeGameObject;
        int count = 0;

        // 2. �������� �� ���� ��������
        foreach (Transform child in root.GetComponentsInChildren<Transform>(true))
        {
            // ���������� ��� ������, ���� �� ����� ������� ���
            if (child == root.transform) continue;

            // ������ �: �������������, ��� � ����� ���� MeshFilter + MeshRenderer
            // (�������������� ���� ��� ���� ����)
            /*
            if (child.GetComponent<MeshFilter>() == null)
                child.gameObject.AddComponent<MeshFilter>();
            if (child.GetComponent<MeshRenderer>() == null)
                child.gameObject.AddComponent<MeshRenderer>();
            */

            // ������ �: �������� MeshCollider, ���� ���
            if (child.GetComponent<MeshCollider>() == null)
            {
                var col = child.gameObject.AddComponent<MeshCollider>();
                col.convex = false; // ��� true, ���� ����� ������ ������
                count++;
            }
        }

        Debug.Log($"������. ��������� MeshCollider �� {count} �������� ��� '{root.name}'.");
    }
}


2.3 Текст программы «CombineStaticMeshesByMaterial.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
#if UNITY_EDITOR
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.Rendering;

public class CombineStaticMeshesByMaterial : EditorWindow
{
    [MenuItem("Tools/Vegetation/Combine Static Meshes By Material")]
    static void Open() => GetWindow<CombineStaticMeshesByMaterial>("Combine Static Meshes");

    public bool useSelection = true;
    public Transform parent;
    public bool includeInactive = false;
    public bool keepOriginalsDisabled = true; // ��������� ��������� ����� ��������������
    public bool generateSecondaryUV = false;   // ������������� UV2 ����� ���������������
    public bool setIndexFormatTo32 = true;     // �������� 32-bit ������� ��� �������������
    public bool markCombinedStatic = true;     // �������� ��������������� ������� ��� Static
    public bool removeOriginalRenderers = false; // ������� MeshRenderer � ���������� (������ ����������)

    void OnGUI()
    {
        GUILayout.Label("Targets", EditorStyles.boldLabel);
        useSelection = EditorGUILayout.Toggle("Use Selection", useSelection);
        EditorGUI.BeginDisabledGroup(useSelection);
        parent = (Transform)EditorGUILayout.ObjectField("Parent", parent, typeof(Transform), true);
        EditorGUI.EndDisabledGroup();
        includeInactive = EditorGUILayout.Toggle("Include Inactive", includeInactive);

        EditorGUILayout.Space();
        GUILayout.Label("Options", EditorStyles.boldLabel);
        generateSecondaryUV = EditorGUILayout.Toggle("Generate Secondary UV (UV2)", generateSecondaryUV);
        setIndexFormatTo32 = EditorGUILayout.Toggle("Allow 32-bit indices if needed", setIndexFormatTo32);
        keepOriginalsDisabled = EditorGUILayout.Toggle("Keep originals disabled (undoable)", keepOriginalsDisabled);
        removeOriginalRenderers = EditorGUILayout.Toggle("Remove original MeshRenderers (permanent)", removeOriginalRenderers);
        markCombinedStatic = EditorGUILayout.Toggle("Mark combined objects Static", markCombinedStatic);

        EditorGUILayout.Space();
        if (GUILayout.Button("Combine Now"))
        {
            CombineNow();
        }
    }

    void CombineNow()
    {
        var roots = CollectRoots().ToArray();
        if (roots.Length == 0)
        {
            EditorUtility.DisplayDialog("Combine Static Meshes", "No targets found. Select objects or assign Parent.", "OK");
            return;
        }

        Undo.IncrementCurrentGroup();
        int undoGroup = Undo.GetCurrentGroup();

        int combinedObjects = 0;
        List<GameObject> created = new List<GameObject>();

        foreach (var rootGO in roots)
        {
            var filters = rootGO.GetComponentsInChildren<MeshFilter>(includeInactive)
                              .Where(f => f.sharedMesh != null && f.GetComponent<MeshRenderer>() != null)
                              .ToArray();

            // Build list of (mesh, renderer, transform, submeshIndex) entries so we can group by material
            var entries = new List<MeshEntry>();
            foreach (var mf in filters)
            {
                var mr = mf.GetComponent<MeshRenderer>();
                var mesh = mf.sharedMesh;
                var mats = mr.sharedMaterials;
                for (int sub = 0; sub < Mathf.Min(mesh.subMeshCount, mats.Length); sub++)
                {
                    var mat = mats[sub];
                    if (mat == null) continue;
                    entries.Add(new MeshEntry { mesh = mesh, renderer = mr, filter = mf, transform = mf.transform, submesh = sub, material = mat });
                }
            }

            // Group by material instance ID
            var groups = entries.GroupBy(e => e.material.GetInstanceID());

            foreach (var g in groups)
            {
                var groupList = g.ToList();
                var firstMat = groupList[0].material;
                string combinedName = $"Combined_{firstMat.name}_{rootGO.name}";

                List<CombineInstance> combineInstances = new List<CombineInstance>();
                int totalVertexCount = 0;
                foreach (var e in groupList)
                {
                    var ci = new CombineInstance();
                    ci.mesh = e.mesh;
                    ci.subMeshIndex = e.submesh;
                    // transform relative to root: worldToLocal(root) * localToWorld(source)
                    ci.transform = rootGO.transform.worldToLocalMatrix * e.transform.localToWorldMatrix;
                    combineInstances.Add(ci);
                    totalVertexCount += e.mesh.vertexCount;
                }

                if (combineInstances.Count == 0) continue;

                // Optionally generate UV2 for each source mesh (best effort)
                if (generateSecondaryUV)
                {
                    // We'll replace meshes referenced in combineInstances by copies that have UV2 generated.
                    for (int i = 0; i < groupList.Count; i++)
                    {
                        var e = groupList[i];
                        Mesh src = e.filter.sharedMesh;
                        Mesh temp = Object.Instantiate(src);
                        Unwrapping.GenerateSecondaryUVSet(temp);

                        // replace mesh references in combineInstances where mesh == src
                        for (int k = 0; k < combineInstances.Count; k++)
                        {
                            var tmpCI = combineInstances[k];
                            if (tmpCI.mesh == src)
                            {
                                tmpCI.mesh = temp;
                                combineInstances[k] = tmpCI; // assign back the struct
                            }
                        }
                    }
                }

                // Create combined mesh
                Mesh combinedMesh = new Mesh();
                if (setIndexFormatTo32)
                {
                    if (totalVertexCount > 65534) combinedMesh.indexFormat = IndexFormat.UInt32;
                }

                combinedMesh.CombineMeshes(combineInstances.ToArray(), true, true, true);

                // Create GameObject for combined mesh
                GameObject go = new GameObject(combinedName);
                Undo.RegisterCreatedObjectUndo(go, "Create Combined Mesh");
                go.transform.SetParent(rootGO.transform, false);
                var mfNew = go.AddComponent<MeshFilter>();
                mfNew.sharedMesh = combinedMesh;
                var mrNew = go.AddComponent<MeshRenderer>();
                mrNew.sharedMaterial = firstMat;

                if (markCombinedStatic)
                {
                    GameObjectUtility.SetStaticEditorFlags(go, StaticEditorFlags.BatchingStatic | StaticEditorFlags.OccludeeStatic | StaticEditorFlags.ContributeGI);
                }

                created.Add(go);
                combinedObjects++;

                // disable or remove originals
                foreach (var e in groupList)
                {
                    var origGO = e.transform.gameObject;
                    if (removeOriginalRenderers)
                    {
                        var r = origGO.GetComponent<MeshRenderer>();
                        if (r) Undo.DestroyObjectImmediate(r);
                    }
                    else
                    {
                        if (keepOriginalsDisabled)
                        {
                            Undo.RecordObject(origGO, "Disable original GO");
                            origGO.SetActive(false);
                        }
                        else
                        {
                            Undo.DestroyObjectImmediate(origGO);
                        }
                    }
                }
            }
        }

        Undo.CollapseUndoOperations(undoGroup);

        Debug.Log($"[CombineStatic] Created {combinedObjects} combined objects.");
        EditorUtility.DisplayDialog("Combine Static Meshes", $"Created {combinedObjects} combined objects.", "OK");
    }

    IEnumerable<GameObject> CollectRoots()
    {
        if (useSelection)
        {
            return Selection.gameObjects
                            .Where(g => g != null)
                            .Distinct();
        }
        else if (parent != null)
        {
            return new[] { parent.gameObject };
        }
        else
        {
            return System.Linq.Enumerable.Empty<GameObject>();
        }
    }

    class MeshEntry
    {
        public Mesh mesh;
        public MeshRenderer renderer;
        public MeshFilter filter;
        public Transform transform;
        public int submesh;
        public Material material;
    }
}
#endif


2.4 Текст программы «ListingExporter.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;
using System.IO;
using System.Text;
using System.Linq;
using System.Collections.Generic;

public static class ListingExporter
{
    // ����� ��������� �� ������ �������� � �������
    // ������ ���� ��, ��� ������� ����� � ���� ���������
    static readonly string[] ProjectSettingsFiles =
    {
        "ProjectSettings/ProjectSettings.asset",
        "ProjectSettings/InputManager.asset",
        "ProjectSettings/DynamicsManager.asset",
        "ProjectSettings/TagManager.asset",
        "ProjectSettings/TimeManager.asset",
        "ProjectSettings/QualitySettings.asset",
        "ProjectSettings/GraphicsSettings.asset",
        "ProjectSettings/Physics2DSettings.asset",
        "ProjectSettings/AudioManager.asset",
        "ProjectSettings/URPProjectSettings.asset",          // ���� ����
        "ProjectSettings/ShaderGraphSettings.asset",         // ���� ����
    };

    [MenuItem("Tools/Listing/Export Code Listing")]
    public static void Export()
    {
        // �������� ����� ��������
        string exportRoot = Path.Combine(Application.dataPath, "../ListingExport");
        string settingsOut = Path.Combine(exportRoot, "1_ProjectSettings");
        string scriptsOut  = Path.Combine(exportRoot, "2_Scripts");

        EnsureCleanDir(exportRoot);
        Directory.CreateDirectory(settingsOut);
        Directory.CreateDirectory(scriptsOut);

        // 1) �������� ProjectSettings
        var exportedSettings = new List<string>();
        foreach (var relPath in ProjectSettingsFiles)
        {
            string fullPath = Path.Combine(Application.dataPath, "../", relPath);
            if (!File.Exists(fullPath))
                continue;

            string fileName = Path.GetFileName(relPath);
            string dst = Path.Combine(settingsOut, fileName);

            File.Copy(fullPath, dst, true);
            exportedSettings.Add(fileName);
        }

        // 2) ������� ��� .cs � Assets
        string[] guids = AssetDatabase.FindAssets("t:MonoScript", new[] { "Assets" });

        // ����������� � ���� � ��������� Editor-������� �� �������
        var scriptPaths = guids
            .Select(AssetDatabase.GUIDToAssetPath)
            .Where(p => p.EndsWith(".cs"))
            .OrderBy(p => p)
            .ToList();

        // 3) �������� ������ �������� � ����� 2_Scripts
        var exportedScripts = new List<string>();

        foreach (var assetPath in scriptPaths)
        {
            // ����� ��������� Editor-������� �� "�������" ��������:
            // if (assetPath.Contains("/Editor/")) continue;

            string fileName = Path.GetFileName(assetPath);
            string srcFull = Path.Combine(Application.dataPath, assetPath.Substring("Assets/".Length));
            string dstFull = Path.Combine(scriptsOut, fileName);

            if (!File.Exists(srcFull))
                continue;

            File.Copy(srcFull, dstFull, true);
            exportedScripts.Add(fileName);
        }

        // 4) ���������� ����������
        string tocPath = Path.Combine(exportRoot, "����������.txt");
        File.WriteAllText(tocPath, BuildTOC(exportedSettings, exportedScripts), Encoding.UTF8);

        // 5) ���������� ���� ����� ���� �������� (������ ��� Word)
        string allPath = Path.Combine(exportRoot, "�������_���_�����.txt");
        File.WriteAllText(allPath, BuildCombinedListing(settingsOut, scriptsOut, exportedSettings, exportedScripts), Encoding.UTF8);

        Debug.Log($"[ListingExporter] Done. Export folder: {exportRoot}");
        EditorUtility.RevealInFinder(exportRoot);
    }

    static void EnsureCleanDir(string dir)
    {
        if (Directory.Exists(dir))
            Directory.Delete(dir, true);
        Directory.CreateDirectory(dir);
    }

    static string BuildTOC(List<string> settings, List<string> scripts)
    {
        var sb = new StringBuilder();

        sb.AppendLine("����������");
        sb.AppendLine("1 ������ ��������� ��������� �������");

        for (int i = 0; i < settings.Count; i++)
        {
            sb.AppendLine($"1.{i + 1} ����� ����� ������ �{settings[i]}�.");
        }

        sb.AppendLine("2 ������ �������� ��������");

        for (int i = 0; i < scripts.Count; i++)
        {
            sb.AppendLine($"2.{i + 1} ����� ��������� �{scripts[i]}�.");
        }

        return sb.ToString();
    }

    static string BuildCombinedListing(
        string settingsOut,
        string scriptsOut,
        List<string> settings,
        List<string> scripts)
    {
        var sb = new StringBuilder();

        sb.AppendLine("1 ������ ��������� ��������� �������");

        for (int i = 0; i < settings.Count; i++)
        {
            string file = settings[i];
            string full = Path.Combine(settingsOut, file);

            sb.AppendLine();
            sb.AppendLine($"1.{i + 1} ����� ����� ������ �{file}�.");
            sb.AppendLine("����������: ���� �������� ������� Unity.");
            sb.AppendLine("���� ��������: YAML.");
            sb.AppendLine("��� ��������:");

            if (File.Exists(full))
            {
                sb.AppendLine(File.ReadAllText(full));
            }
        }

        sb.AppendLine();
        sb.AppendLine("2 ������ �������� ��������");

        for (int i = 0; i < scripts.Count; i++)
        {
            string file = scripts[i];
            string full = Path.Combine(scriptsOut, file);

            sb.AppendLine();
            sb.AppendLine($"2.{i + 1} ����� ��������� �{file}�.");
            sb.AppendLine("����������: �������� ��� ���������� �������� �������.");
            sb.AppendLine("���� ����������������: C#.");
            sb.AppendLine("��� ���������:");

            if (File.Exists(full))
            {
                sb.AppendLine(File.ReadAllText(full));
            }
        }

        return sb.ToString();
    }
}
#endif



2.5 Текст программы «ScatterStonesOnSurface.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
#if UNITY_EDITOR
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

public class ScatterStonesOnSurface : EditorWindow
{
    GameObject stonePrefab;
    int count = 100;
    float minScale = 0.6f;
    float maxScale = 1.2f;
    float offsetFromSurface = 0.01f;
    int maxTriesPerStone = 50;
    bool alignToNormal = true;
    bool randomRotation = true;
    bool parentUnderTarget = true;
    bool useSelectedAsTargets = true;

    [MenuItem("Tools/Decor/Scatter Stones On Surface")]
    static void Open() => GetWindow<ScatterStonesOnSurface>("Scatter Stones");

    void OnGUI()
    {
        GUILayout.Label("Scatter stones onto selected meshes", EditorStyles.boldLabel);
        stonePrefab = (GameObject)EditorGUILayout.ObjectField("Stone Prefab", stonePrefab, typeof(GameObject), false);
        count = EditorGUILayout.IntField("Count per target", count);
        minScale = EditorGUILayout.FloatField("Min Scale", minScale);
        maxScale = EditorGUILayout.FloatField("Max Scale", maxScale);
        offsetFromSurface = EditorGUILayout.FloatField("Offset (m)", offsetFromSurface);
        maxTriesPerStone = EditorGUILayout.IntField("Max tries per stone", maxTriesPerStone);
        alignToNormal = EditorGUILayout.Toggle("Align to surface normal", alignToNormal);
        randomRotation = EditorGUILayout.Toggle("Random rotation around normal", randomRotation);
        parentUnderTarget = EditorGUILayout.Toggle("Parent under target", parentUnderTarget);
        useSelectedAsTargets = EditorGUILayout.Toggle("Use Selection as targets", useSelectedAsTargets);

        if (GUILayout.Button("Scatter Now"))
        {
            if (stonePrefab == null)
            {
                EditorUtility.DisplayDialog("Scatter Stones", "Assign stone prefab first.", "OK");
                return;
            }
            Scatter();
        }
    }

    void Scatter()
    {
        var targets = useSelectedAsTargets ? Selection.gameObjects : FindObjectsOfType<GameObject>();
        if (targets == null || targets.Length == 0) { EditorUtility.DisplayDialog("Scatter Stones", "No targets found (select objects).", "OK"); return; }

        Undo.IncrementCurrentGroup();
        int group = Undo.GetCurrentGroup();

        int placedTotal = 0;
        foreach (var t in targets)
        {
            if (t == null) continue;
            var mf = t.GetComponent<MeshFilter>();
            if (mf == null || mf.sharedMesh == null) continue;

            Mesh mesh = mf.sharedMesh;
            var verts = mesh.vertices;
            var tris = mesh.triangles;
            var normals = mesh.normals;

            System.Random rnd = new System.Random(); // deterministic? uses system seed

            for (int i = 0; i < count; i++)
            {
                bool placed = false;
                for (int tries = 0; tries < maxTriesPerStone && !placed; tries++)
                {
                    // pick random triangle
                    int triIndex = rnd.Next(0, tris.Length / 3);
                    int i0 = tris[triIndex * 3 + 0];
                    int i1 = tris[triIndex * 3 + 1];
                    int i2 = tris[triIndex * 3 + 2];

                    Vector3 v0 = verts[i0];
                    Vector3 v1 = verts[i1];
                    Vector3 v2 = verts[i2];

                    // random barycentric coordinates
                    float r1 = (float)rnd.NextDouble();
                    float r2 = (float)rnd.NextDouble();
                    if (r1 + r2 > 1f) { r1 = 1f - r1; r2 = 1f - r2; }

                    Vector3 localPos = v0 + r1 * (v1 - v0) + r2 * (v2 - v0);
                    Vector3 worldPos = t.transform.TransformPoint(localPos);

                    // sample normal (interpolate)
                    Vector3 n0 = normals.Length > 0 ? normals[i0] : Vector3.up;
                    Vector3 n1 = normals.Length > 0 ? normals[i1] : Vector3.up;
                    Vector3 n2 = normals.Length > 0 ? normals[i2] : Vector3.up;
                    Vector3 localNormal = (n0 + n1 + n2).normalized;
                    Vector3 worldNormal = (t.transform.TransformDirection(localNormal)).normalized;

                    // raycast outward a bit to ensure not inside other geometry
                    Ray ray = new Ray(worldPos + worldNormal * 0.1f, -worldNormal);
                    if (Physics.Raycast(ray, out RaycastHit hit, 0.5f))
                    {
                        // optional: check hit.collider.gameObject == t to ensure surface belongs to target
                        // place slightly off surface along normal
                        Vector3 placePos = hit.point + worldNormal * offsetFromSurface;

                        GameObject inst = (GameObject)PrefabUtility.InstantiatePrefab(stonePrefab);
                        Undo.RegisterCreatedObjectUndo(inst, "Scatter Stone");
                        inst.transform.position = placePos;
                        if (parentUnderTarget) inst.transform.SetParent(t.transform, true);

                        float s = Random.Range(minScale, maxScale);
                        inst.transform.localScale = Vector3.one * s;

                        // orientation
                        if (alignToNormal)
                        {
                            inst.transform.rotation = Quaternion.FromToRotation(Vector3.up, worldNormal);
                            if (randomRotation)
                            {
                                inst.transform.Rotate(worldNormal, Random.Range(0f, 360f), Space.World);
                            }
                        }
                        else if (randomRotation)
                        {
                            inst.transform.rotation = Random.rotation;
                        }

                        placed = true;
                        placedTotal++;
                    }
                } // tries
            } // count
        } // targets

        Undo.CollapseUndoOperations(group);
        EditorUtility.DisplayDialog("Scatter Stones", $"Placed ~{placedTotal} stones.", "OK");
    }
}
#endif


2.6 Текст программы «TextureOptimizer.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
// Assets/Editor/TextureOptimizer.cs
using UnityEditor;
using UnityEngine;

public static class TextureOptimizer
{
    /// <summary>
    /// ��������, � �������� ������� ���� ��� �����, ����� ���������.
    /// ��������: UI_Logo_NoOpt.png
    /// </summary>
    private const string SkipToken = "_NoOpt";

    // ������� ���������
    private const int TargetMaxSize = 1024;                 // ������� Max Size
    private const int UiMaxSize = 512;                      // ��� UI-������ ��������
    private const int CompressionQuality = 50;              // 0..100 (Crunched)

    // --- �������� ��� ��������� ---
    [MenuItem("Tools/Texture Optimizer/Preview")]
    private static void PreviewOptimize()
    {
        string[] guids = AssetDatabase.FindAssets("t:Texture2D");
        int count = 0;

        foreach (var guid in guids)
        {
            string path = AssetDatabase.GUIDToAssetPath(guid);

            var importer = AssetImporter.GetAtPath(path) as TextureImporter;
            if (importer == null) continue;

            if (path.Contains(SkipToken))
                continue;

            int currentMax = importer.maxTextureSize;

            bool willChangeMaxSize = currentMax > TargetMaxSize;
            bool willChangeCompression =
                importer.textureCompression == TextureImporterCompression.Uncompressed;

            if (willChangeMaxSize || willChangeCompression)
            {
                Debug.Log($"[Preview] {path}  MaxSize:{currentMax}  Compression:{importer.textureCompression}");
                count++;
            }
        }

        Debug.Log($"[TextureOptimizer] Preview finished. Textures to change: {count}");
    }

    // --- ��������� ������� ����������� ---
    [MenuItem("Tools/Texture Optimizer/Apply Basic Mobile Settings")]
    private static void ApplyOptimize()
    {
        if (!EditorUtility.DisplayDialog(
                "Texture Optimizer",
                "��������� ������� ����������� �������? " +
                "����� ������� ��������� ����� ������� ����� ����.",
                "��, ��������������",
                "������"))
        {
            return;
        }

        string[] guids = AssetDatabase.FindAssets("t:Texture2D");

        int modified = 0;

        AssetDatabase.StartAssetEditing();
        try
        {
            foreach (var guid in guids)
            {
                string path = AssetDatabase.GUIDToAssetPath(guid);

                var importer = AssetImporter.GetAtPath(path) as TextureImporter;
                if (importer == null) continue;

                // ���������� ����������
                if (path.Contains(SkipToken))
                    continue;

                bool isUI =
                    importer.textureType == TextureImporterType.Sprite &&
                    importer.spritePixelsPerUnit >= 100; // ������ ������� ������/UI

                int targetSize = isUI ? UiMaxSize : TargetMaxSize;

                bool changed = false;

                // Max Size
                if (importer.maxTextureSize > targetSize)
                {
                    importer.maxTextureSize = targetSize;
                    changed = true;
                }

                // ��� ������� ������� �������� �������
                if (importer.textureType == TextureImporterType.Default ||
                    importer.textureType == TextureImporterType.NormalMap)
                {
                    if (!importer.mipmapEnabled)
                    {
                        importer.mipmapEnabled = true;
                        changed = true;
                    }
                }

                // ������
                if (importer.textureCompression != TextureImporterCompression.Compressed &&
                    importer.textureCompression != TextureImporterCompression.CompressedHQ)
                {
                    importer.textureCompression = TextureImporterCompression.Compressed;
                    changed = true;
                }

                // Crunched compression ( ��� ��� ����� �� �������, �� �������� ������ )
                if (!importer.crunchedCompression)
                {
                    importer.crunchedCompression = true;
                    importer.compressionQuality = CompressionQuality;
                    changed = true;
                }

                if (changed)
                {
                    Debug.Log($"[TextureOptimizer] Modified: {path}");
                    AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);
                    modified++;
                }
            }
        }
        finally
        {
            AssetDatabase.StopAssetEditing();
        }

        Debug.Log($"[TextureOptimizer] Done. Modified textures: {modified}");
    }
}


2.7 Текст программы «VegetationBatchOptimizer.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
// Assets/Editor/VegetationBatchOptimizer.cs
#if UNITY_EDITOR
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;
using UnityEngine.Rendering;

public class VegetationBatchOptimizer : EditorWindow
{
    [MenuItem("Tools/Vegetation/Batch Optimizer")]
    static void Open() => GetWindow<VegetationBatchOptimizer>("Vegetation Optimizer");

    // Targeting
    public bool useSelection = true;
    public Transform parent;
    public bool includeInactive = true;

    // Actions
    public bool disableShadows = true;
    public bool disableReceiveShadows = true;
    public bool disableLightProbes = true;
    public bool disableReflectionProbes = true;
    public bool removeColliders = true;

    // Static flags
    public bool setBatchingStatic = true;
    public bool setOccludeeStatic = true;
    public bool setOccluderStatic = false;     // ������ �� ����� ��� ��������������
    public bool setContributeGI = false;       // ������� �� �������������

    // UI
    void OnGUI()
    {
        GUILayout.Label("Targets", EditorStyles.boldLabel);
        useSelection = EditorGUILayout.Toggle("Use Selection", useSelection);
        EditorGUI.BeginDisabledGroup(useSelection);
        parent = (Transform)EditorGUILayout.ObjectField("Parent", parent, typeof(Transform), true);
        EditorGUI.EndDisabledGroup();
        includeInactive = EditorGUILayout.Toggle("Include Inactive", includeInactive);

        EditorGUILayout.Space();
        GUILayout.Label("Actions", EditorStyles.boldLabel);
        disableShadows = EditorGUILayout.Toggle("Disable Cast Shadows", disableShadows);
        disableReceiveShadows = EditorGUILayout.Toggle("Disable Receive Shadows", disableReceiveShadows);
        disableLightProbes = EditorGUILayout.Toggle("Disable Light Probes", disableLightProbes);
        disableReflectionProbes = EditorGUILayout.Toggle("Disable Reflection Probes", disableReflectionProbes);
        removeColliders = EditorGUILayout.Toggle("Remove Colliders", removeColliders);

        EditorGUILayout.Space();
        GUILayout.Label("Static Flags", EditorStyles.boldLabel);
        setBatchingStatic = EditorGUILayout.Toggle("Batching Static", setBatchingStatic);
        setOccludeeStatic = EditorGUILayout.Toggle("Occludee Static", setOccludeeStatic);
        setOccluderStatic = EditorGUILayout.Toggle("Occluder Static", setOccluderStatic);
        setContributeGI   = EditorGUILayout.Toggle("Contribute GI", setContributeGI);

        EditorGUILayout.Space();
        if (GUILayout.Button("Optimize Now"))
        {
            OptimizeNow();
        }
    }

    void OptimizeNow()
    {
        var roots = CollectRoots().ToArray();
        if (roots.Length == 0)
        {
            EditorUtility.DisplayDialog("Vegetation Optimizer", "No targets found. Select objects or assign Parent.", "OK");
            return;
        }

        int renderersTouched = 0;
        int collidersRemoved = 0;
        int objectsFlaggedStatic = 0;

        Undo.IncrementCurrentGroup();
        int undoGroup = Undo.GetCurrentGroup();

        foreach (var root in roots)
        {
            var gos = root.GetComponentsInChildren<Transform>(includeInactive)
                          .Select(t => t.gameObject);

            foreach (var go in gos)
            {
                // Renderers: ����/�����
                var rends = go.GetComponents<Renderer>();
                foreach (var r in rends)
                {
                    if (!r) continue;
                    bool changed = false;
                    Undo.RecordObject(r, "Optimize Renderer");

                    if (disableShadows && r.shadowCastingMode != ShadowCastingMode.Off)
                    {
                        r.shadowCastingMode = ShadowCastingMode.Off;
                        changed = true;
                    }
                    if (disableReceiveShadows && r.receiveShadows)
                    {
                        r.receiveShadows = false;
                        changed = true;
                    }
                    if (disableLightProbes && r.lightProbeUsage != LightProbeUsage.Off)
                    {
                        r.lightProbeUsage = LightProbeUsage.Off;
                        changed = true;
                    }
                    if (disableReflectionProbes && r.reflectionProbeUsage != ReflectionProbeUsage.Off)
                    {
                        r.reflectionProbeUsage = ReflectionProbeUsage.Off;
                        changed = true;
                    }

                    if (changed) renderersTouched++;
                }

                // Colliders: �������
                if (removeColliders)
                {
                    var cols = go.GetComponents<Collider>();
                    foreach (var c in cols)
                    {
                        if (!c) continue;
                        collidersRemoved++;
                        Undo.DestroyObjectImmediate(c);
                    }
                }

                // Static flags
                StaticEditorFlags flags = GameObjectUtility.GetStaticEditorFlags(go);
                StaticEditorFlags before = flags;

                if (setBatchingStatic)  flags |= StaticEditorFlags.BatchingStatic;
                if (setOccludeeStatic)  flags |= StaticEditorFlags.OccludeeStatic;
                if (setOccluderStatic)  flags |= StaticEditorFlags.OccluderStatic;
                if (setContributeGI)    flags |= StaticEditorFlags.ContributeGI;

                if (flags != before)
                {
                    Undo.RegisterCompleteObjectUndo(go, "Set Static Flags");
                    GameObjectUtility.SetStaticEditorFlags(go, flags);
                    objectsFlaggedStatic++;
                }
            }
        }

        Undo.CollapseUndoOperations(undoGroup);

        string msg = $"Optimized:\nRenderers changed: {renderersTouched}\nColliders removed: {collidersRemoved}\nObjects flagged static: {objectsFlaggedStatic}";
        Debug.Log($"[Vegetation Optimizer] {msg}");
        ShowNotification(new GUIContent("Optimization complete"));
        EditorUtility.DisplayDialog("Vegetation Optimizer", msg, "OK");
    }

    IEnumerable<GameObject> CollectRoots()
    {
        if (useSelection)
        {
            return Selection.gameObjects
                            .Where(g => g != null)
                            .Distinct();
        }
        else if (parent != null)
        {
            return new[] { parent.gameObject };
        }
        else
        {
            return Enumerable.Empty<GameObject>();
        }
    }
}
#endif


2.8 Текст программы «VegetationPainterWindow.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
// Assets/Editor/VegetationPainterWindow.cs
#if UNITY_EDITOR
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

public class VegetationPainterWindow : EditorWindow
{
    [MenuItem("Tools/Vegetation Painter")]
    static void Open() => GetWindow<VegetationPainterWindow>("Vegetation Painter");

    // What to paint
    public List<GameObject> prefabs = new List<GameObject>();

    // Placement
    public Transform parent;
    public LayerMask paintMask = ~0;
    public float brushRadius = 2f;
    public int countPerStroke = 10;

    // Rotation/scale
    public bool preserveRotation = true;   // не менять ориентацию префаба
    public bool alignToNormal = true;      // выравнивать по нормали (если preserveRotation = false)
    public bool randomYaw = true;          // случайный поворот вокруг оси
    public Vector2 uniformScale = new Vector2(0.8f, 1.2f);

    // Filters
    [Range(0, 90)] public float maxSlope = 60f; // 0..90, работает для верхних и нижних сторон
    public float minSpacing = 0.35f;
    public bool avoidOverlap = true;

    // Ray modes
    public enum RayDirectionMode { Auto, SurfaceNormal, WorldDown, Camera }
    public RayDirectionMode rayMode = RayDirectionMode.Auto;

    // Gizmos
    public Color brushColor = new Color(0f, 1f, 0.6f, 0.25f);

    // runtime
    RaycastHit _hit;
    bool _hasHit;
    readonly List<Transform> _tmpChildren = new List<Transform>(1024);

    void OnEnable()  => SceneView.duringSceneGui += OnSceneGUI;
    void OnDisable() => SceneView.duringSceneGui -= OnSceneGUI;

    void OnGUI()
    {
        var so = new SerializedObject(this);
        EditorGUILayout.PropertyField(so.FindProperty("prefabs"), true);

        parent = (Transform)EditorGUILayout.ObjectField("Parent", parent, typeof(Transform), true);
        paintMask = LayerMaskField("Paint Mask", paintMask);

        brushRadius = EditorGUILayout.Slider("Brush Radius", brushRadius, 0.2f, 20f);
        countPerStroke = EditorGUILayout.IntSlider("Count/Stroke", countPerStroke, 1, 200);

        preserveRotation = EditorGUILayout.Toggle("Preserve Prefab Rotation", preserveRotation);
        EditorGUI.BeginDisabledGroup(preserveRotation);
        alignToNormal = EditorGUILayout.Toggle("Align To Normal", alignToNormal);
        randomYaw     = EditorGUILayout.Toggle("Random Yaw", randomYaw);
        EditorGUI.EndDisabledGroup();

        uniformScale = EditorGUILayout.Vector2Field("Uniform Scale Min/Max", uniformScale);

        maxSlope = EditorGUILayout.Slider("Max Slope", maxSlope, 0, 90);
        minSpacing = EditorGUILayout.Slider("Min Spacing", minSpacing, 0f, 2f);
        avoidOverlap = EditorGUILayout.Toggle("Avoid Overlap", avoidOverlap);

        rayMode = (RayDirectionMode)EditorGUILayout.EnumPopup("Ray Mode", rayMode);

        brushColor = EditorGUILayout.ColorField("Brush Color", brushColor);

        EditorGUILayout.Space();
        EditorGUILayout.HelpBox("Ctrl + LMB: paint\nShift + LMB: erase", MessageType.Info);

        so.ApplyModifiedProperties();
    }

    // Без UnityEditorInternal — совместимо везде
    static LayerMask LayerMaskField(string label, LayerMask selected)
    {
        var names = new List<string>();
        var numbers = new List<int>();
        for (int i = 0; i < 32; i++)
        {
            string n = LayerMask.LayerToName(i);
            if (!string.IsNullOrEmpty(n)) { names.Add(n); numbers.Add(i); }
        }

        int maskNoEmpty = 0;
        for (int i = 0; i < numbers.Count; i++)
            if (((selected.value >> numbers[i]) & 1) == 1)
                maskNoEmpty |= (1 << i);

        maskNoEmpty = EditorGUILayout.MaskField(label, maskNoEmpty, names.ToArray());

        int mask = 0;
        for (int i = 0; i < numbers.Count; i++)
            if ((maskNoEmpty & (1 << i)) != 0)
                mask |= 1 << numbers[i];

        selected.value = mask;
        return selected;
    }

    void OnSceneGUI(SceneView view)
    {
        Event e = Event.current;

        // Ray under mouse
        Ray ray = HandleUtility.GUIPointToWorldRay(e.mousePosition);
        _hasHit = Physics.Raycast(ray, out _hit, 10000f, paintMask, QueryTriggerInteraction.Ignore);

        // Brush gizmo
        if (_hasHit)
        {
            Handles.color = brushColor;
            Handles.DrawSolidDisc(_hit.point, _hit.normal, brushRadius);
            Handles.color = Color.black;
            Handles.DrawWireDisc(_hit.point, _hit.normal, brushRadius);
            view.Repaint();
        }

        bool leftDown = e.type == EventType.MouseDown && e.button == 0;
        bool leftDrag = e.type == EventType.MouseDrag && e.button == 0;
        bool painting = e.control && !e.shift; // Ctrl
        bool erasing  = e.shift;

        // Едим ввод сцены только когда рисуем/стираем
        if (painting || erasing)
            HandleUtility.AddDefaultControl(GUIUtility.GetControlID(FocusType.Passive));

        if (_hasHit && (leftDown || leftDrag) && painting)
        {
            PaintAt(_hit.point, _hit.normal);
            e.Use(); SceneView.RepaintAll();
        }
        else if (_hasHit && (leftDown || leftDrag) && erasing)
        {
            EraseAt(_hit.point);
            e.Use(); SceneView.RepaintAll();
        }
    }

    void PaintAt(Vector3 center, Vector3 normal)
    {
        if (prefabs == null || prefabs.Count == 0) return;

        // basis in hit plane (для разброса точек кисти)
        Vector3 n = normal.normalized;
        Vector3 t = Vector3.Cross(n, Vector3.up);
        if (t.sqrMagnitude < 1e-6f) t = Vector3.Cross(n, Vector3.right);
        t.Normalize();
        Vector3 b = Vector3.Cross(n, t);

        // Быстрый список детей parent (spacing без OverlapSphere)
        _tmpChildren.Clear();
        if (parent)
        {
            for (int i = 0; i < parent.childCount; i++)
                _tmpChildren.Add(parent.GetChild(i));
        }
        float minSpacingSqr = minSpacing * minSpacing;

        // Undo-группа на весь мазок
        Undo.SetCurrentGroupName("Paint Vegetation");
        int undoGroup = Undo.GetCurrentGroup();

        int placed = 0, guard = 0;
        int maxAttempts = Mathf.Max(countPerStroke * 10, 200);

        while (placed < countPerStroke && guard++ < maxAttempts)
        {
            // random point in disc
            float r = brushRadius * Mathf.Sqrt(Random.value);
            float theta = Random.value * Mathf.PI * 2f;
            Vector3 offset = t * (Mathf.Cos(theta) * r) + b * (Mathf.Sin(theta) * r);

            if (!TryHitAt(center, n, offset, out var hit))
                continue;

            // двухсторонний уклон: 0..90
            float upAngle = Vector3.Angle(hit.normal, Vector3.up);
            float slope   = Mathf.Min(upAngle, 180f - upAngle);
            if (slope > maxSlope) continue;

            // spacing только против детей parent
            if (avoidOverlap && parent)
            {
                bool blocked = false;
                for (int i = 0; i < _tmpChildren.Count; i++)
                {
                    var tchild = _tmpChildren[i];
                    if (!tchild) continue;

                    Vector3 p = tchild.position;
                    var rend = tchild.GetComponentInChildren<Renderer>();
                    if (rend) p = rend.bounds.ClosestPoint(hit.point);

                    if ((p - hit.point).sqrMagnitude <= minSpacingSqr)
                    { blocked = true; break; }
                }
                if (blocked) continue;
            }

            // prefab
            var prefab = prefabs[Random.Range(0, prefabs.Count)];
            if (!prefab) continue;

            // instantiate — сразу под parent
            GameObject go = parent
                ? (GameObject)PrefabUtility.InstantiatePrefab(prefab, parent)
                : (GameObject)PrefabUtility.InstantiatePrefab(prefab);

            Undo.RegisterCreatedObjectUndo(go, "Paint Vegetation");

            // position
            go.transform.position = hit.point;

            // rotation
            if (!preserveRotation)
            {
                Quaternion rot = go.transform.rotation; // prefab base
                if (alignToNormal)
                    rot = Quaternion.FromToRotation(Vector3.up, hit.normal) * rot;

                if (randomYaw)
                {
                    Vector3 yawAxis = alignToNormal ? hit.normal : Vector3.up;
                    rot = Quaternion.AngleAxis(Random.Range(0f, 360f), yawAxis) * rot;
                }

                go.transform.rotation = rot;
            }

            // scale
            float s = Random.Range(Mathf.Min(uniformScale.x, uniformScale.y),
                                   Mathf.Max(uniformScale.x, uniformScale.y));
            go.transform.localScale = Vector3.Scale(go.transform.localScale, new Vector3(s, s, s));

            placed++;
        }

        if (placed > 0) Undo.CollapseUndoOperations(undoGroup);
    }

    // Пытаемся «достучаться» до поверхности из разных направлений
    bool TryHitAt(Vector3 center, Vector3 brushNormal, Vector3 offset, out RaycastHit hit)
    {
        float baseUp = Mathf.Max(brushRadius, 2f) + 5f;  // запас над точкой
        float longUp = Mathf.Max(brushRadius * 4f, 20f); // для глубоких ям
        Vector3 p = center + offset;

        // кандидаты на трассировку (origin, dir, dist), порядок зависит от режима
        var list = new List<(Vector3 o, Vector3 d, float dist)>(6);

        void Add(Vector3 o, Vector3 d, float dist)
        {
            // нормализуем направление для надёжной дистанции
            list.Add((o, d.normalized, dist));
        }

        switch (rayMode)
        {
            case RayDirectionMode.SurfaceNormal:
                Add(p + brushNormal * baseUp, -brushNormal, baseUp * 2f + 5f);
                break;

            case RayDirectionMode.WorldDown:
                Add(p + Vector3.up * longUp, Vector3.down, longUp * 2f + 10f);
                Add(p - Vector3.up * longUp, Vector3.up,    longUp * 2f + 10f);
                break;

            case RayDirectionMode.Camera:
            {
                var cam = SceneView.lastActiveSceneView ? SceneView.lastActiveSceneView.camera : null;
                Vector3 fwd = cam ? cam.transform.forward : (SceneView.currentDrawingSceneView ? SceneView.currentDrawingSceneView.camera.transform.forward : Vector3.down);
                float along = longUp;
                Add(p - fwd * along,  fwd, along * 2f + 10f);
                Add(p + fwd * along, -fwd, along * 2f + 10f);
                break;
            }

            case RayDirectionMode.Auto:
            default:
            {
                // 1) по нормали кисти
                Add(p + brushNormal * baseUp, -brushNormal, baseUp * 2f + 5f);
                // 2) вниз по миру (для ям/крутых склонов)
                Add(p + Vector3.up * longUp, Vector3.down, longUp * 2f + 10f);
                // 3) вверх по миру (если красим нижние стороны)
                Add(p - Vector3.up * longUp, Vector3.up,    longUp * 2f + 10f);
                // 4) вдоль камеры (на случай сложных навесов)
                var cam = SceneView.lastActiveSceneView ? SceneView.lastActiveSceneView.camera : null;
                if (cam)
                {
                    Vector3 fwd = cam.transform.forward;
                    float along = longUp;
                    Add(p - fwd * along,  fwd, along * 2f + 10f);
                    Add(p + fwd * along, -fwd, along * 2f + 10f);
                }
                break;
            }
        }

        for (int i = 0; i < list.Count; i++)
        {
            var (o, d, dist) = list[i];
            if (Physics.Raycast(o, d, out hit, dist, paintMask, QueryTriggerInteraction.Ignore))
                return true;
        }

        hit = default;
        return false;
    }

    void EraseAt(Vector3 center)
    {
        float r2 = brushRadius * brushRadius;

        Undo.SetCurrentGroupName("Erase Vegetation");
        int undoGroup = Undo.GetCurrentGroup();
        int deleted = 0;

        if (parent)
        {
            var children = new List<Transform>(parent.childCount);
            for (int i = 0; i < parent.childCount; i++)
                children.Add(parent.GetChild(i));

            foreach (var t in children)
            {
                if (!t) continue;
                Vector3 p = t.position;
                var rend = t.GetComponentInChildren<Renderer>();
                if (rend) p = rend.bounds.ClosestPoint(center);
                if ((p - center).sqrMagnitude <= r2)
                {
                    Undo.DestroyObjectImmediate(t.gameObject);
                    deleted++;
                }
            }
        }
        else
        {
            var cols = Physics.OverlapSphere(center, brushRadius, ~0, QueryTriggerInteraction.Ignore);
            foreach (var c in cols)
            {
                if (!c) continue;
                Undo.DestroyObjectImmediate(c.transform.root.gameObject);
                deleted++;
            }
        }

        if (deleted > 0) Undo.CollapseUndoOperations(undoGroup);
    }
}
#endif


2.9 Текст программы «AutoDespawn.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public class AutoDespawn : MonoBehaviour
{
    public float lifetime = 20f;
    private float timer = 0f;

    void Update()
    {
        timer += Time.deltaTime;
        if (timer >= lifetime)
        {
            Destroy(gameObject);
        }
    }
}


2.10 Текст программы «ButcherSequencer.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using System;
using System.Collections;
using UnityEngine;

public enum HarvestMode { Fillet, Carcass }

public class ButcherSequencer : MonoBehaviour
{
    [Header("Fish root (визуальная рыба)")]
    [Tooltip("Корень, под которым лежат все части рыбы. Если не указать, будет this.transform.")]
    public Transform fishRoot;

    [Header("Parts (assign in prefab)")]
    public GameObject head;           // голова
    public GameObject[] fins;         // плавники
    public GameObject tail;           // хвост
    public GameObject skin;           // тело/кожа (Fish_Body)
    public GameObject bones;          // отдельный видимый меш костей (НЕ Armature!)

    [Header("Innards (fillet result)")]
    [Tooltip("Внутренности/филе. При режиме Филе остаются на месте, остальное отлетает.")]
    public GameObject innards;

    [Header("Debris visual (отрезанные части)")]
    [Tooltip("Куда складывать отлетевшие куски. Если пусто — в корень сцены.")]
    public Transform debrisRoot;

    [Tooltip("Сколько секунд обрезки лежат, после чего удаляются. 0 или меньше — не удалять и событие AllDebrisCleared не сработает.")]
    public float debrisLifetime = 15f;

    [Tooltip("Сила стартового толчка вниз (VelocityChange).")]
    public float dropExtraForce = 3f;

    [Tooltip("Случайный крутящий момент при падении.")]
    public bool randomRotationOnDrop = true;

    [Header("Debris physics")]
    [Tooltip("Через сколько секунд включать/создавать коллайдеры у обломков.")]
    public float debrisColliderDelay = 0.35f;

    [Tooltip("На baked-обломок добавлять MeshCollider (convex). Если false — BoxCollider по bounds меша.")]
    public bool useMeshColliderForDebris = true;

    public PhysicMaterial debrisPhysicMaterial;

    [Tooltip("Слой для обломков. -1 — не менять.")]
    public int debrisLayer = -1;

    [Header("Timing (seconds)")]
    public float stepDelay = 0.25f;
    public float endDelay = 0.3f;

    [Header("Debug")]
    public bool debugLogs = true; // сейчас не используется, можно удалить

    bool running;
    HarvestMode currentMode;

    // Контекст от HarvestUIManager
    [NonSerialized] public FishCatcher catcher;
    [NonSerialized] public FishData fish;
    [NonSerialized] public GameObject fishObj; // инстанс рыбы в мире

    // ==== событие, когда все обломки уничтожены ====
    public event Action AllDebrisCleared;
    int _activeDebris = 0;

    void Awake()
    {
        if (!fishRoot) fishRoot = transform;

        if (innards) innards.SetActive(false);
        // ВАЖНО: НЕ выключать Armature. Поле 'bones' должно ссылаться на отдельный визуальный меш костей (если он есть).
        // if (bones) bones.SetActive(false); // НЕ ДЕЛАТЬ
    }

    /// <summary>Вызвать перед StartButchering, чтобы секвенсер знал, кого разделывает.</summary>
    public void Setup(FishCatcher fc, FishData data, GameObject obj)
    {
        catcher = fc;
        fish = data;
        fishObj = obj;
    }

    // === PUBLIC API =======================================================

    public void StartButchering(HarvestMode mode, Action onDone)
    {
        if (running) return;

        currentMode = mode;

        // ТОЛЬКО выключаем коллайдеры, рендеры не трогаем
        DisableAllCollidersUnderFish();

        running = true;
        StartCoroutine(mode == HarvestMode.Carcass
            ? FlowCarcass(onDone)
            : FlowFillet(onDone));
    }

    IEnumerator FlowCarcass(Action onDone)
    {
        // ТУША: отрубаем голову, тело остаётся (но без коллайдеров)
        CutHead();
        yield return new WaitForSeconds(stepDelay);

        yield return new WaitForSeconds(endDelay);

        running = false;
        onDone?.Invoke();
    }

    IEnumerator FlowFillet(Action onDone)
    {
        // ФИЛЕ: по шагам отрубаем всё, филе/innards остаётся
        CutHead(); yield return new WaitForSeconds(stepDelay);
        CutFins(); yield return new WaitForSeconds(stepDelay);
        CutTail(); yield return new WaitForSeconds(stepDelay);
        RemoveSkin(); yield return new WaitForSeconds(stepDelay);
        ExtractBones(); yield return new WaitForSeconds(endDelay);

        running = false;
        onDone?.Invoke();
    }

    // === STEPS ============================================================

    void CutHead()
    {
        // Кровь/FX в момент отрубания головы
        if (catcher != null && fish != null && fishObj != null)
            catcher.SpawnButcherFX(fish, fishObj);

        DropPart(head);
        head = null;
    }

    void CutFins()
    {
        if (fins != null)
        {
            for (int i = 0; i < fins.Length; i++)
            {
                if (!fins[i]) continue;
                DropPart(fins[i]);
                fins[i] = null;
            }
        }
    }

    void CutTail()
    {
        DropPart(tail);
        tail = null;
    }

    void RemoveSkin()
    {
        // Для ФИЛЕ: кожа/тело падает как обломок, innards остаются на месте
        if (currentMode == HarvestMode.Fillet)
        {
            Transform p = skin ? skin.transform.parent : null;
            Vector3 lp = skin ? skin.transform.localPosition : Vector3.zero;
            Quaternion lr = skin ? skin.transform.localRotation : Quaternion.identity;
            Vector3 ls = skin ? skin.transform.localScale : Vector3.one;

            DropPart(skin);
            skin = null;

            if (innards)
            {
                var t = innards.transform;
                if (p && t.parent != p) t.SetParent(p, false);
                t.localPosition = lp;
                t.localRotation = lr;
                t.localScale = ls;
                innards.SetActive(true);
            }
        }
        else
        {
            // Carcass: туша остаётся, ничего не делаем с skin
        }
    }

    void ExtractBones()
    {
        // В режиме Филе — кости падают как обломок (если есть отдельный визуал костей)
        if (currentMode == HarvestMode.Fillet && bones)
        {
            if (!bones.activeSelf) bones.SetActive(true);
            DropPart(bones);
            bones = null;
        }
    }

    // === COLLIDERS ========================================================

    /// <summary>Полностью отключает все коллайдеры рыбы (чтобы она больше не била сабмарину).</summary>
    void DisableAllCollidersUnderFish()
    {
        Transform root = null;
        if (fishRoot) root = fishRoot;
        else if (fishObj) root = fishObj.transform;
        else root = transform;

        var cols = root.GetComponentsInChildren<Collider>(true);
        foreach (var c in cols)
            c.enabled = false;
    }

    // === DEBRIS MANAGEMENT ================================================

    void RegisterDebris(GameObject g)
    {
        _activeDebris++;
        if (debrisLayer >= 0) g.layer = debrisLayer;
    }

    void DebrisDestroyed()
    {
        _activeDebris = Mathf.Max(0, _activeDebris - 1);
        if (_activeDebris == 0)
            AllDebrisCleared?.Invoke();
    }

    IEnumerator ArmDebrisColliders(GameObject debris)
    {
        if (!debris) yield break;

        float t = debrisColliderDelay;
        while (t > 0f)
        {
            t -= Time.unscaledDeltaTime; // не зависит от Time.timeScale
            yield return null;
        }

        // Включаем или создаём коллайдеры
        var cols = debris.GetComponentsInChildren<Collider>(true);
        if (cols == null || cols.Length == 0)
        {
            var mf = debris.GetComponent<MeshFilter>();
            if (useMeshColliderForDebris && mf && mf.sharedMesh)
            {
                var mc = debris.AddComponent<MeshCollider>();
                mc.sharedMesh = mf.sharedMesh;
                mc.convex = true;
                if (debrisPhysicMaterial) mc.sharedMaterial = debrisPhysicMaterial;
            }
            else
            {
                var bc = debris.AddComponent<BoxCollider>();
                if (mf && mf.sharedMesh)
                {
                    var b = mf.sharedMesh.bounds;
                    bc.center = b.center;
                    bc.size = b.size;
                }
                if (debrisPhysicMaterial) bc.sharedMaterial = debrisPhysicMaterial;
            }
        }
        else
        {
            foreach (var c in cols) c.enabled = true;
        }
    }

    // === DEBRIS VISUAL DROP ===============================================

    // Запекаем skinned-меш в отдельный GO и роняем его
    GameObject BakeSkinnedToDebris(GameObject src)
    {
        if (!src) return null;

        var smr = src.GetComponentInChildren<SkinnedMeshRenderer>(true);
        if (!smr) return null;

        var debris = new GameObject(src.name + "_Debris");
        debris.transform.position = smr.transform.position;
        debris.transform.rotation = smr.transform.rotation;
        debris.transform.localScale = smr.transform.lossyScale;

        var mf = debris.AddComponent<MeshFilter>();
        var mr = debris.AddComponent<MeshRenderer>();

        var baked = new Mesh();
        smr.BakeMesh(baked, true);
        mf.sharedMesh = baked;
        mr.sharedMaterials = smr.sharedMaterials;

        if (debrisRoot) debris.transform.SetParent(debrisRoot, true);

        var rb = debris.AddComponent<Rigidbody>();
        rb.isKinematic = false;
        rb.useGravity = true;
        rb.constraints = RigidbodyConstraints.None;
        rb.velocity = Vector3.zero;
        rb.angularVelocity = Vector3.zero;

        if (dropExtraForce > 0f)
        {
            rb.AddForce(Vector3.down * dropExtraForce, ForceMode.VelocityChange);
            if (randomRotationOnDrop)
                rb.AddTorque(UnityEngine.Random.onUnitSphere * dropExtraForce, ForceMode.VelocityChange);
        }

        smr.enabled = false;

        RegisterDebris(debris);
        StartCoroutine(ArmDebrisColliders(debris));

        if (debrisLifetime > 0f)
            StartCoroutine(DestroyDebrisAfter(debris, debrisLifetime));

        return debris;
    }

    void DropPart(GameObject part)
    {
        if (!part)
        {
            return;
        }

        var baked = BakeSkinnedToDebris(part);
        if (baked) return;

        Transform t = part.transform;

        if (debrisRoot != null)
            t.SetParent(debrisRoot, true);
        else
            t.SetParent(null, true);

        var partColliders = part.GetComponentsInChildren<Collider>(true);
        foreach (var c in partColliders) c.enabled = false;

        Rigidbody rb = part.GetComponent<Rigidbody>();
        if (!rb) rb = part.AddComponent<Rigidbody>();

        rb.constraints = RigidbodyConstraints.None;
        rb.isKinematic = false;
        rb.useGravity = true;

        rb.velocity = Vector3.zero;
        rb.angularVelocity = Vector3.zero;

        if (dropExtraForce > 0f)
        {
            rb.AddForce(Vector3.down * dropExtraForce, ForceMode.VelocityChange);

            if (randomRotationOnDrop)
                rb.AddTorque(UnityEngine.Random.onUnitSphere * dropExtraForce, ForceMode.VelocityChange);
        }

        RegisterDebris(part);
        StartCoroutine(ArmDebrisColliders(part));

        if (debrisLifetime > 0f)
            StartCoroutine(DestroyDebrisAfter(part, debrisLifetime));
    }

    IEnumerator DestroyDebrisAfter(GameObject obj, float lifetime)
    {
        float elapsed = 0f;
        while (obj && elapsed < lifetime)
        {
            elapsed += Time.unscaledDeltaTime;
            yield return null;
        }

        if (obj)
            Destroy(obj);

        DebrisDestroyed();
    }
}


2.11 Текст программы «CausticsScroll.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using UnityEngine.UI;

public class CausticsScroll : MonoBehaviour
{
    public RawImage img;
    public Vector2 scrollSpeed = new Vector2(0.02f, 0.01f);

    void Reset()
    {
        img = GetComponent<RawImage>();
    }

    void Update()
    {
        if (img != null && img.texture != null)
        {
            // ������ ������� uv-����������
            Rect r = img.uvRect;
            r.x += scrollSpeed.x * Time.deltaTime;
            r.y += scrollSpeed.y * Time.deltaTime;
            img.uvRect = r;
        }
    }
}


2.12 Текст программы «CaveChunk.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public class CaveChunk : MonoBehaviour, IChunkGenerator
{
    [Header("Tiles")]
    public GameObject floorPrefab;
    public GameObject wallPrefab;

    [Header("Cave Params")]
    [Range(0, 100)] public int fillPercent = 48;  // ��������� ������������
    public int smoothIterations = 5;              // ����������� ���������� ��������

    [Header("Encounters")]
    [Range(0, 1)] public float encounterChance = 0.04f; // ���� ������ ������� �� ������ ����
    public GameObject encounterPrefab;

    int[,] map; // 1 = wall, 0 = empty

    public void GenerateChunk(int width, int height, int seed)
    {
        // ������ ������
        for (int i = transform.childCount - 1; i >= 0; i--)
            DestroyImmediate(transform.GetChild(i).gameObject);

        var rng = new System.Random(seed);

        // 1) ��������� �����
        map = new int[width, height];
        for (int x = 0; x < width; x++)
            for (int y = 0; y < height; y++)
            {
                bool border = x == 0 || y == 0 || x == width - 1 || y == height - 1;
                map[x, y] = (border || rng.Next(100) < fillPercent) ? 1 : 0;
            }

        // 2) ����������
        for (int i = 0; i < smoothIterations; i++)
        {
            int[,] nm = (int[,])map.Clone();
            for (int x = 1; x < width - 1; x++)
                for (int y = 1; y < height - 1; y++)
                {
                    int walls = 0;
                    for (int ix = x - 1; ix <= x + 1; ix++)
                        for (int iy = y - 1; iy <= y + 1; iy++)
                            if (!(ix == x && iy == y)) walls += map[ix, iy];

                    if (walls > 4) nm[x, y] = 1;
                    else if (walls < 4) nm[x, y] = 0;
                }
            map = nm;
        }

        // 3) ������ �����/���
        for (int x = 0; x < width; x++)
            for (int y = 0; y < height; y++)
            {
                var local = new Vector3(x, y, 0);
                var world = transform.position + local;

                if (map[x, y] == 0) // ������� => ��� + ���� �������
                {
                    var f = Instantiate(floorPrefab, world, Quaternion.identity, transform);

                    // ����� ������� (��������)
                    if (encounterPrefab && Random01(rng) < encounterChance)
                    {
                        Instantiate(encounterPrefab, world, Quaternion.identity, transform);
                    }
                }
                else // �����
                {
                    Instantiate(wallPrefab, world, Quaternion.identity, transform);
                }
            }
    }

    float Random01(System.Random rng) => (float)rng.NextDouble();
}


2.13 Текст программы «ChunkedWorldManager.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using System.Collections.Generic;
using UnityEngine;

public class ChunkedWorldManager : MonoBehaviour
{
    [Header("References")]
    public Transform player;
    public GameObject chunkPrefab; // �� �� ����� ���������, ����������� IChunkGenerator

    [Header("Chunk Settings")]
    public int chunkSize = 32;   // ������ �� X/Y
    public int viewRadius = 1;   // 1 => 3x3 ����� ������ ������
    public int baseSeed = 123456;

    // ���� = ���������� �����, �������� = ������� GO
    private readonly Dictionary<Vector2Int, GameObject> loaded = new();

    void Update()
    {
        if (!player || !chunkPrefab) return;

        Vector2Int center = WorldToChunk(player.position);

        // ��������� �����������
        for (int cx = center.x - viewRadius; cx <= center.x + viewRadius; cx++)
            for (int cy = center.y - viewRadius; cy <= center.y + viewRadius; cy++)
                EnsureChunk(new Vector2Int(cx, cy));

        // ��������� ������
        var toRemove = new List<Vector2Int>();
        foreach (var kv in loaded)
        {
            var c = kv.Key;
            if (Mathf.Abs(c.x - center.x) > viewRadius + 1 ||
                Mathf.Abs(c.y - center.y) > viewRadius + 1)
                toRemove.Add(c);
        }
        foreach (var c in toRemove)
        {
            Destroy(loaded[c]);
            loaded.Remove(c);
        }
    }

    Vector2Int WorldToChunk(Vector3 pos)
    {
        int cx = Mathf.FloorToInt(pos.x / chunkSize);
        int cy = Mathf.FloorToInt(pos.y / chunkSize);
        return new Vector2Int(cx, cy);
    }

    void EnsureChunk(Vector2Int cpos)
    {
        if (loaded.ContainsKey(cpos)) return;

        Vector3 worldPos = new(cpos.x * chunkSize, cpos.y * chunkSize, 0);
        var go = Instantiate(chunkPrefab, worldPos, Quaternion.identity, transform);

        // ���������� seed ��� ������� ����� � �����������������
        int seed = HashSeed(baseSeed, cpos.x, cpos.y);

        var gen = go.GetComponent<IChunkGenerator>();
        if (gen != null)
        {
            gen.GenerateChunk(chunkSize, chunkSize, seed);
        }

        loaded[cpos] = go;
        go.name = $"Chunk_{cpos.x}_{cpos.y}";
    }

    // ������� ����������������� ���-�������
    int HashSeed(int baseSeed, int x, int y)
    {
        unchecked
        {
            int h = baseSeed;
            h = h * 73856093 ^ x;
            h = h * 19349663 ^ y;
            return h;
        }
    }
}


2.14 Текст программы «ClickToStart.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public class ClickToStart : MonoBehaviour
{
    public GameObject overlayPanel; // ������ "�������, ����� ������"

    public void OnClickStart()
    {
        if (overlayPanel) overlayPanel.SetActive(false);

#if UNITY_WEBGL && !UNITY_EDITOR
        WebGLInput.captureAllKeyboardInput = true;
#endif

        // ���� � ���� �������� ����������:
#if UNITY_STANDALONE || UNITY_WEBGL
        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;
#endif
    }
}


2.15 Текст программы «CrewPoisonMessage.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using System.Collections;
using UnityEngine;
using TMPro;

public class CrewPoisonMessage : MonoBehaviour
{
    [Header("UI refs")]
    public TMP_Text messageText;        // ��� ����� (TextMeshPro)

    [Header("Text")]
    [TextArea]
    public string poisonedText = "����� ������� ���������!";

    [Header("Timing")]
    public float showTime = 3f;          // ������� ������� ����� ���������

    void Awake()
    {
        // ���� �� ������ � ���������� � ���� � ����� �� �������
        if (messageText == null)
            messageText = GetComponent<TMP_Text>();

        // ����� ���������� ��������, �� ������ �������
        if (messageText != null)
            messageText.enabled = false;
    }

    public void Show()
    {
        if (messageText == null) return;

        StopAllCoroutines();
        StartCoroutine(ShowRoutine());
    }

    IEnumerator ShowRoutine()
    {
        messageText.text = poisonedText;
        messageText.enabled = true;   // ���������� �����

        yield return new WaitForSeconds(showTime);

        messageText.enabled = false;  // �������� �����, �� ������ ������� ��������
    }
}


2.16 Текст программы «DisableFishEmission.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public class DisableFishEmission : MonoBehaviour
{
    void Awake()
    {
        var rend = GetComponentInChildren<Renderer>();
        if (rend == null) return;

        // ������ ������� ��������� ������ ��� ���� ����
        var mat = rend.material;

        if (mat.IsKeywordEnabled("_EMISSION"))
        {
            mat.DisableKeyword("_EMISSION");
            mat.SetColor("_EmissionColor", Color.black);
        }
    }
}


2.17 Текст программы «FishCatcher.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;

[RequireComponent(typeof(Collider))]
public class FishCatcher : MonoBehaviour
{
    public enum FlowDirection { SubForward, ToCamera }

    // Локальная ось, вдоль которой стреляет твой FX-префаб
    public enum EmitterAxis { ZForward, YUp, XRight }

    [Header("Refs")]
    public SubmarineHealth subHealth;
    private ScoreManager scoreManager;
    public SubmarineController subController;

    [Header("Logic")]
    public HarvestUIManager modalLogic_PC;           // ПК версия
    public HarvestUIManagerMobile modalLogic_Mobile; // Мобильная версия

    [Header("Mobile")]
    public bool forceMobileInEditor = false;

    [Header("Damage feedback / Invuln")]
    public SubmarineInvulnerabilityBlink subInvuln;

    [Header("Fish filter (by tag)")]
    [Tooltip("Тег объектов рыбы, которые можно ловить")]
    public string fishTag = "Fish";

    public static event System.Action OnAnyFishCaught;
    public static event System.Action<bool> OnAnyFishResolved;

    [Header("Audio")]
    [Tooltip("Сюда кинь объект Submarine (на котором висит SubmarineAudio).")]
    public SubmarineAudio audioRef;

    [Header("Catch behaviour")]
    [Tooltip("Задержка перед тем, как снова можно ловить следующую рыбу.")]
    public float recatchDelay = 0.5f;

    [Header("Direction Controls")]
    [Tooltip("Игнорировать высоту укуса и стрелять строго вперёд по сабмарине")]
    public bool alwaysForward = true;

    [Tooltip("Проецировать направление на горизонтальную плоскость (убрать Y-компонент)")]
    public bool flattenVertical = true;

    [Tooltip("Если вертикаль не полностью вырубать: максимум наклона по питчу, градусы")]
    [Range(0f, 89f)] public float maxPitchDegrees = 10f;

    [Header("FX Spawn Point")]
    [Tooltip("Где спавнить кровь/брызги. Пустой объект у носа субмарины, ЧУТЬ впереди камеры.")]
    public Transform fxSpawnPoint;

    [Header("FX Direction (без правки модулей)")]
    [Tooltip("Куда направлять поток партиклов (только поворот, без изменения модулей).")]
    public FlowDirection flowDirection = FlowDirection.SubForward;

    [Tooltip("Доп. поворот в градусах, если эмиттер у тебя смотрит вбок/назад. Например (0,90,0).")]
    public Vector3 fxRotationOffsetEuler = Vector3.zero;

    [Header("FX Axis Mapping")]
    [Tooltip("Какой локальной осью префаб стреляет. Выбери, чтобы переориентировать её в +Z.")]
    public EmitterAxis emitterLocalAxis = EmitterAxis.YUp;

    [Header("FX Defaults (подстраховка)")]
    [Tooltip("Если у конкретной рыбы не задан butcherFXPrefab — возьмём этот.")]
    public ParticleSystem defaultButcherFX;

    [Header("FX Lifetime")]
    [Tooltip("Если > 0, FX будет удалён через это время (сек). Если 0 или меньше — время вычисляется по ParticleSystem.")]
    public float fxLifetimeOverride = 0f;

    Collider catchZoneCollider;

    HarvestUIManager harvestUI;   // итоговый выбранный менеджер (пока не используется)
    bool isMobileLike;

    void Awake()
    {
        catchZoneCollider = GetComponent<Collider>();
        if (catchZoneCollider != null) catchZoneCollider.isTrigger = true;

        // --- определяем, мобильный UX или нет ---
        bool isMobileRuntime = false;

#if UNITY_WEBGL && !UNITY_EDITOR
        // WebGL: смотрим, мобильный ли браузер через JS-плагин
        isMobileRuntime = WebGLBrowserCheck.IsMobileBrowser();
#elif UNITY_ANDROID || UNITY_IOS
        // Нативные мобильные платформы
        isMobileRuntime = true;
#else
        // Остальное — десктоп
        isMobileRuntime = false;
#endif

        // мобильный UX:
        //  - на Android/iOS/мобильном WebGL
        //  - или в редакторе, если включён флаг forceMobileInEditor
        isMobileLike = isMobileRuntime || (Application.isEditor && forceMobileInEditor);

        if (!scoreManager)
            scoreManager = FindObjectOfType<ScoreManager>();

        Debug.Log($"[FishCatcher] platform={Application.platform}, " +
                  $"isMobileRuntime={isMobileRuntime}, " +
                  $"forceMobileInEditor={forceMobileInEditor}, " +
                  $"isMobileLike={isMobileLike}");
    }

    void OnTriggerEnter(Collider other)
    {
        // 0) Если лодка сейчас в инвулне — вообще не ловим рыбу
        if (subInvuln != null && subInvuln.IsInvulnerable)
            return;

        // 1) Проверка по ТЕГУ
        bool isFishByTag =
            other.CompareTag(fishTag) ||
            (other.transform.root != null && other.transform.root.CompareTag(fishTag));

        if (!isFishByTag)
            return;

        // 2) Берём FishData у родителя
        FishData fish = other.GetComponentInParent<FishData>();
        if (fish == null || fish.caught)
            return;

        // помечаем, что рыба уже поймана
        fish.caught = true;
        OnAnyFishCaught?.Invoke();

        // отключаем триггер и управление сабмариной на время UI
        if (catchZoneCollider != null) catchZoneCollider.enabled = false;
        if (subController != null) subController.enabled = false;

        // ПК / мобильный UI
        if (isMobileLike)
        {
            if (modalLogic_Mobile != null)
                modalLogic_Mobile.ShowPrompt(fish, fish.gameObject, this);
        }
        else
        {
            if (modalLogic_PC != null)
                modalLogic_PC.ShowPrompt(fish, fish.gameObject, this);
        }
    }

    public void ResolveCatch(FishData fish, GameObject fishObj, bool butcher)
    {
        if (subController != null) subController.enabled = true;
        StartCoroutine(ReenableCatchZoneAfterDelay());

        // Игрок выбрал "отпустить"
        if (!butcher)
        {
            if (fishObj != null) Destroy(fishObj);

            OnAnyFishResolved?.Invoke(false);
            return;
        }

        // --- ЯДОВИТАЯ РЫБА: включаем инвулн ---
        if (fish != null && fish.istoxic)
        {
            if (subInvuln != null)
                subInvuln.TriggerInvulnerability();
        }

        // ⚠️ FX крови запускается в ButcherSequencer, тут не трогаем

        if (fish != null && fish.isHostile)
        {
            if (scoreManager != null) scoreManager.AddScore(-fish.scorePenalty);
            if (subHealth != null) subHealth.ApplyDamage(fish.healthPenalty);
            if (audioRef != null) audioRef.PlayHostileFish();
        }
        else if (fish != null)
        {
            if (scoreManager != null) scoreManager.AddScore(fish.scoreValue);
            if (subHealth != null && fish.healthHeal > 0f)
                subHealth.currentHealth = Mathf.Min(subHealth.maxHealth, subHealth.currentHealth + fish.healthHeal);
            if (audioRef != null) audioRef.PlayScoreGain();
        }

        OnAnyFishResolved?.Invoke(true);

        if (fishObj != null) Destroy(fishObj);
    }

    public void SpawnButcherFX(FishData fish, GameObject fishObj)
    {
        // 0) префаб FX: у рыбы или дефолтный
        ParticleSystem fxPrefab =
            (fish != null && fish.butcherFXPrefab != null) ? fish.butcherFXPrefab : defaultButcherFX;

        if (fxPrefab == null)
        {
            return;
        }

        // 1) позиция спавна
        Vector3 mouthPos = fxSpawnPoint ? fxSpawnPoint.position : transform.position;
        Vector3 spawnPos = mouthPos;
        if (fishObj != null)
        {
            var col = fishObj.GetComponentInChildren<Collider>();
            spawnPos = col ? col.ClosestPoint(mouthPos) : fishObj.transform.position;
        }

        // 2) направление струи
        Vector3 dir;

        if (flowDirection == FlowDirection.ToCamera && Camera.main != null)
        {
            dir = Camera.main.transform.forward;
        }
        else
        {
            if (alwaysForward)
                dir = (subController ? subController.transform.forward : transform.forward);
            else
                dir = (spawnPos - mouthPos);

            if (dir.sqrMagnitude < 1e-6f)
                dir = (subController ? subController.transform.forward : transform.forward);

            if (flattenVertical)
            {
                dir = Vector3.ProjectOnPlane(dir, Vector3.up);
            }
            else if (maxPitchDegrees < 89f)
            {
                Vector3 flat = Vector3.ProjectOnPlane(dir, Vector3.up);
                if (flat.sqrMagnitude > 1e-6f)
                {
                    flat.Normalize();
                    float pitch = Vector3.Angle(flat, dir.normalized); // 0..90
                    if (pitch > maxPitchDegrees)
                    {
                        float t = Mathf.Clamp01(maxPitchDegrees / Mathf.Max(pitch, 1e-4f));
                        dir = Vector3.Slerp(flat, dir.normalized, t);
                    }
                }
            }

            dir.Normalize();
        }

        // 3) поворот с маппингом локальной оси эмиттера в +Z
        Quaternion aim = Quaternion.LookRotation(dir, Vector3.up);
        Quaternion axisFix = Quaternion.identity;
        switch (emitterLocalAxis)
        {
            default:
            case EmitterAxis.ZForward: axisFix = Quaternion.identity; break;
            case EmitterAxis.YUp: axisFix = Quaternion.FromToRotation(Vector3.up, Vector3.forward); break;
            case EmitterAxis.XRight: axisFix = Quaternion.FromToRotation(Vector3.right, Vector3.forward); break;
        }
        Quaternion rot = aim * axisFix;
        if (fxRotationOffsetEuler != Vector3.zero) rot *= Quaternion.Euler(fxRotationOffsetEuler);

        // 4) инстанс FX (КОРНЕВАЯ система)
        ParticleSystem rootPs = Instantiate(fxPrefab, spawnPos, rot);

        // 5) запускаем ВСЕ ParticleSystem под корнем
        ParticleSystem[] systems = rootPs.GetComponentsInChildren<ParticleSystem>(true);
        float maxLife = 0f;

        foreach (var ps in systems)
        {
            if (!ps) continue;

            ps.Play(true);

            var main = ps.main;
            float duration = main.duration;

            float lifetimeExtra = 0f;
            switch (main.startLifetime.mode)
            {
                case ParticleSystemCurveMode.TwoConstants:
                    lifetimeExtra = Mathf.Max(main.startLifetime.constantMin, main.startLifetime.constantMax);
                    break;
                case ParticleSystemCurveMode.TwoCurves:
                case ParticleSystemCurveMode.Curve:
                    lifetimeExtra = main.startLifetime.constantMax;
                    break;
                case ParticleSystemCurveMode.Constant:
                    lifetimeExtra = main.startLifetime.constant;
                    break;
            }

            float total = duration + lifetimeExtra;
            if (main.loop) total = Mathf.Max(total, 5f);

            if (total > maxLife) maxLife = total;
        }

        float destroyTime = fxLifetimeOverride > 0f ? fxLifetimeOverride : maxLife;
        if (destroyTime <= 0f) destroyTime = 5f;

        Destroy(rootPs.gameObject, destroyTime);
    }

    private IEnumerator ReenableCatchZoneAfterDelay()
    {
        yield return new WaitForSecondsRealtime(recatchDelay);
        if (catchZoneCollider != null) catchZoneCollider.enabled = true;
    }
}


2.18 Текст программы «FishData.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public class FishData : MonoBehaviour
{
    [Header("Identity")]
    public string fishName = "����������� ����";
    [TextArea(2, 5)]
    public string description = "�������� ���� ����...";
    public ParticleSystem butcherFXPrefab;
    [Header("Type")]
    public bool isHostile = false; // �������? ��/���
    public bool istoxic = false; // ��������? ��/���

    [Header("Scoring / effects")]
    public int scoreValue = 10;      // ������� ����� ��� (������ ����)
    public int scorePenalty = 20;    // ������� ����� �������� (������� ����)
    public float healthPenalty = 20; // ������� �� ������� ������� ����
    public float healthHeal = 12;    // ������� �� ��� ������� ���� (0 = �� �����)

    [HideInInspector]
    public bool caught = false; // ����� �� ������������ 2 ����
}


2.19 Текст программы «FishFreezeController.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

public class FishFreezeController : MonoBehaviour
{
    [Header("Behaviour disabling")]
    [Tooltip("��������� ��� MonoBehaviour �� ����, ����� ������ ������.")]
    public bool forceDisableAllBehaviours = true;

    [Tooltip("����, ������� �� ����� ���������.")]
    public string[] whitelistTypeNames = new[]
    {
        "FishFreezeController",
        "FishHighlighter",
        "ButcherSequencer",
        "CutFxPreset"
    };

    [Header("Transform lock")]
    [Tooltip("Ƹ���� ������� ��������� �����, ����� ����� �� �������� ����.")]
    public bool lockRootTransform = true;

    [Header("Physics freeze")]
    [Tooltip("������������ �� Rigidbody (true �� ���������). ����� ��������� �� ���������� ����.")]
    public bool freezeRigidbodies = true;

    // saved states
    struct MBState { public MonoBehaviour mb; public bool enabled; }
    struct RBState
    {
        public Rigidbody rb; public bool isKinematic; public RigidbodyConstraints constraints;
        public Vector3 vel; public Vector3 angVel;
    }
    struct AgentState
    {
        public NavMeshAgent agent; public bool wasEnabled; public bool wasStopped; public bool updPos; public bool updRot;
    }
    struct AnimatorState { public Animator anim; public float speed; public bool applyRootMotion; }

    readonly List<MBState> _behaviourStates = new();
    readonly List<RBState> _rbStates = new();
    readonly List<AgentState> _agentStates = new();
    readonly List<AnimatorState> _animStates = new();

    Vector3 _savedPos;
    Quaternion _savedRot;
    Vector3 _savedScale;

    bool _frozen;

    bool IsWhitelisted(MonoBehaviour mb)
    {
        var t = mb.GetType().Name;
        for (int i = 0; i < whitelistTypeNames.Length; i++)
        {
            if (t == whitelistTypeNames[i]) return true;
        }
        return false;
    }

    public void Freeze()
    {
        if (_frozen) return;

        // --- save root transform
        if (lockRootTransform)
        {
            _savedPos = transform.position;
            _savedRot = transform.rotation;
            _savedScale = transform.localScale;
        }

        // --- freeze ALL rigidbodies
        _rbStates.Clear();
        if (freezeRigidbodies)
        {
            var rbs = GetComponentsInChildren<Rigidbody>(true);
            foreach (var rb in rbs)
            {
                var st = new RBState
                {
                    rb = rb,
                    isKinematic = rb.isKinematic,
                    constraints = rb.constraints,
                    vel = rb.velocity,
                    angVel = rb.angularVelocity
                };
                _rbStates.Add(st);

                rb.velocity = Vector3.zero;
                rb.angularVelocity = Vector3.zero;
                rb.isKinematic = true;
                rb.constraints = RigidbodyConstraints.FreezeAll;
            }
        }

        // --- stop ALL animators
        _animStates.Clear();
        var anims = GetComponentsInChildren<Animator>(true);
        foreach (var a in anims)
        {
            var st = new AnimatorState { anim = a, speed = a.speed, applyRootMotion = a.applyRootMotion };
            _animStates.Add(st);
            a.speed = 0f;
            a.applyRootMotion = false;
        }

        // --- stop ALL navmesh agents
        _agentStates.Clear();
        var agents = GetComponentsInChildren<NavMeshAgent>(true);
        foreach (var ag in agents)
        {
            var st = new AgentState
            {
                agent = ag,
                wasEnabled = ag.enabled,
                wasStopped = ag.isStopped,
                updPos = ag.updatePosition,
                updRot = ag.updateRotation
            };
            _agentStates.Add(st);
            if (ag.enabled)
            {
                ag.isStopped = true;
                ag.updatePosition = false;
                ag.updateRotation = false;
            }
        }

        // --- disable behaviours (except whitelist)
        _behaviourStates.Clear();
        var mbs = GetComponentsInChildren<MonoBehaviour>(true);
        foreach (var mb in mbs)
        {
            if (!mb) continue;
            if (mb == this) continue; // ���� �� �������
            if (forceDisableAllBehaviours && IsWhitelisted(mb)) continue;

            // ���� forceDisableAllBehaviours=false � �������� ������ ����� �������
            bool isMovementLike = false;
            if (!forceDisableAllBehaviours)
            {
                var n = mb.GetType().Name.ToLowerInvariant();
                isMovementLike = n.Contains("move") || n.Contains("swim") || n.Contains("wander") ||
                                 n.Contains("steer") || n.Contains("ai") || n.Contains("path") ||
                                 n.Contains("follow") || n.Contains("seek") || n.Contains("avoid") ||
                                 n.Contains("controller");
            }

            if (forceDisableAllBehaviours || isMovementLike)
            {
                _behaviourStates.Add(new MBState { mb = mb, enabled = mb.enabled });
                mb.enabled = false;
            }
        }

        _frozen = true;
    }

    public void Unfreeze()
    {
        if (!_frozen) return;

        // restore behaviours
        foreach (var st in _behaviourStates)
            if (st.mb) st.mb.enabled = st.enabled;
        _behaviourStates.Clear();

        // restore agents
        foreach (var st in _agentStates)
        {
            var ag = st.agent;
            if (!ag) continue;
            if (st.wasEnabled)
            {
                ag.updatePosition = st.updPos;
                ag.updateRotation = st.updRot;
                ag.isStopped = st.wasStopped;
            }
        }
        _agentStates.Clear();

        // restore animators
        foreach (var st in _animStates)
        {
            var a = st.anim;
            if (!a) continue;
            a.speed = st.speed;
            a.applyRootMotion = st.applyRootMotion;
        }
        _animStates.Clear();

        // restore rigidbodies
        if (freezeRigidbodies)
        {
            foreach (var st in _rbStates)
            {
                var rb = st.rb;
                if (!rb) continue;
                rb.isKinematic = st.isKinematic;
                rb.constraints = st.constraints;
                rb.velocity = st.vel;
                rb.angularVelocity = st.angVel;
            }
        }
        _rbStates.Clear();

        _frozen = false;
    }

    void LateUpdate()
    {
        if (_frozen && lockRootTransform)
        {
            // Ƹ���� ���������� ���� �����
            transform.position = _savedPos;
            transform.rotation = _savedRot;
            transform.localScale = _savedScale;
        }
    }
}


2.20 Текст программы «FishHighlighter.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using System.Collections.Generic;
using UnityEngine;

public class FishHighlighter : MonoBehaviour
{
    [Header("Shader name")]
    public string rimShaderName = "Hidden/Fish/RimOnly";   // важно!

    [Header("Debug")]
    public bool debugLogs = false;
    public bool forceTestRim = false; // можно вообще не использовать, но пусть будет

    private readonly Dictionary<Renderer, Material> added = new Dictionary<Renderer, Material>();

    public void EnableHighlight(Color color, float intensity = 4f, float rimPower = 0.02f)
    {
        DisableHighlight();

        var rendList = GetComponentsInChildren<Renderer>(true);
        Shader rimShader = Shader.Find(rimShaderName);
        if (!rimShader)
        {
            Debug.LogError("[FishHighlighter] Rim shader not found: " + rimShaderName, this);
            return;
        }

        int addedCount = 0;

        foreach (var r in rendList)
        {
            if (!r || !r.enabled) continue;

            var mats = r.sharedMaterials;
            var mat = new Material(rimShader);
            mat.hideFlags = HideFlags.DontSave;

            // ИМЕНА СВОЙСТВ СОВПАДАЮТ С ШЕЙДЕРОМ
            mat.SetColor("_Color", color);
            mat.SetFloat("_Intensity", intensity);
            mat.SetFloat("_RimPower", rimPower);   // толщина

            var newArr = new Material[mats.Length + 1];
            for (int i = 0; i < mats.Length; i++) newArr[i] = mats[i];
            newArr[newArr.Length - 1] = mat;
            r.sharedMaterials = newArr;

            added[r] = mat;
            addedCount++;
        }

        if (debugLogs)
            Debug.Log($"[FishHighlighter] EnableHighlight added={addedCount}", this);
    }

    public void DisableHighlight()
    {
        int removed = 0;

        foreach (var kv in added)
        {
            var r = kv.Key;
            var mat = kv.Value;

            if (!r)
            {
                if (mat) Object.Destroy(mat);
                removed++;
                continue;
            }

            var mats = new List<Material>(r.sharedMaterials);
            if (mats.Remove(mat))
            {
                r.sharedMaterials = mats.ToArray();
                removed++;
            }

            if (mat) Object.Destroy(mat);
        }

        added.Clear();

        if (debugLogs)
            Debug.Log($"[FishHighlighter] DisableHighlight removed={removed}", this);
    }
}


2.21 Текст программы «FishKnowledge.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections.Generic;

public class FishKnowledge : MonoBehaviour
{
    public static FishKnowledge Instance;

    // ����� ���� ��� ���� "���������"
    private HashSet<string> knownFish = new HashSet<string>();

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;

        // ���� ���� ���������� ����� � ��������������:
        // DontDestroyOnLoad(gameObject);
    }

    public bool IsKnown(string fishName)
    {
        return knownFish.Contains(fishName);
    }

    public void MarkKnown(string fishName)
    {
        if (!string.IsNullOrEmpty(fishName))
            knownFish.Add(fishName);
    }
}


2.22 Текст программы «FishSonarHighlight.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class FishSonarHighlight : MonoBehaviour
{
    [Header("Цвета по типу рыбы")]
    public Color edibleColor = Color.cyan;       // съедобная
    public Color hostileColor = Color.yellow;    // агрессивная
    public Color toxicColor = Color.red;         // ядовитая

    [Header("Параметры подсветки")]
    public float defaultDuration = 2f;
    public float emissionIntensity = 2f;         // во сколько раз усиливать эмиссию

    // запись для одного материала
    private class MatEntry
    {
        public Renderer renderer;
        public int materialIndex;
        public string colorProperty;      // "_Color" или "_BaseColor"
        public Color originalColor;

        public bool hasEmission;
        public Color originalEmissionColor;
    }

    List<MatEntry> matEntries = new List<MatEntry>();
    Coroutine currentRoutine;

    FishData fishData;

    void Awake()
    {
        fishData = GetComponentInParent<FishData>();

        matEntries.Clear();

        // Берём все рендереры рыбы (включая детей, скины, плавники и т.п.)
        Renderer[] renderers = GetComponentsInChildren<Renderer>(true);

        foreach (var rend in renderers)
        {
            if (rend == null) continue;

            var mats = rend.materials; // экземпляры материалов, не shared
            for (int i = 0; i < mats.Length; i++)
            {
                var mat = mats[i];
                if (mat == null) continue;

                // --- базовый цвет ---
                string prop = null;
                if (mat.HasProperty("_Color"))
                    prop = "_Color";
                else if (mat.HasProperty("_BaseColor"))
                    prop = "_BaseColor";

                if (prop == null)
                    continue; // материал без обычного цвета — пропускаем

                var entry = new MatEntry
                {
                    renderer = rend,
                    materialIndex = i,
                    colorProperty = prop,
                    originalColor = mat.GetColor(prop),
                    hasEmission = false,
                    originalEmissionColor = Color.black
                };

                // --- эмиссия (если есть) ---
                if (mat.HasProperty("_EmissionColor"))
                {
                    entry.hasEmission = true;
                    entry.originalEmissionColor = mat.GetColor("_EmissionColor");
                }

                matEntries.Add(entry);
            }
        }
    }

    /// <summary>Базовый цвет подсветки для этой рыбы (по типу).</summary>
    public Color GetBaseColor()
    {
        if (fishData != null)
        {
            if (fishData.istoxic)  // поле у тебя уже есть
                return toxicColor;

            if (fishData.isHostile)
                return hostileColor;
        }

        return edibleColor;
    }

    public void Ping(float duration)
    {
        if (duration <= 0f) duration = defaultDuration;

        if (currentRoutine != null)
            StopCoroutine(currentRoutine);

        currentRoutine = StartCoroutine(PingRoutine(duration));
    }

    IEnumerator PingRoutine(float duration)
    {
        float t = 0f;

        while (t < duration)
        {
            t += Time.unscaledDeltaTime;
            float t01 = Mathf.Clamp01(t / duration);

            // гладкий пульс: 0 → 1 → 0
            float pulse = Mathf.Sin(t01 * Mathf.PI);
            pulse = Mathf.Clamp01(pulse);
            pulse = Mathf.SmoothStep(0f, 1f, pulse);

            Color targetColor = GetBaseColor();

            foreach (var entry in matEntries)
            {
                if (entry.renderer == null) continue;

                var mats = entry.renderer.materials;
                if (entry.materialIndex < 0 || entry.materialIndex >= mats.Length) continue;

                var mat = mats[entry.materialIndex];
                if (mat == null || !mat.HasProperty(entry.colorProperty)) continue;

                // цвет
                Color c = Color.Lerp(entry.originalColor, targetColor, pulse);
                mat.SetColor(entry.colorProperty, c);

                // эмиссия (если есть)
                if (entry.hasEmission && mat.HasProperty("_EmissionColor"))
                {
                    Color targetEmission = targetColor * emissionIntensity;
                    Color e = Color.Lerp(entry.originalEmissionColor, targetEmission, pulse);
                    mat.SetColor("_EmissionColor", e);
                    mat.EnableKeyword("_EMISSION");
                }
            }

            yield return null;
        }

        // возвращаем исходные цвета и эмиссию
        foreach (var entry in matEntries)
        {
            if (entry.renderer == null) continue;

            var mats = entry.renderer.materials;
            if (entry.materialIndex < 0 || entry.materialIndex >= mats.Length) continue;

            var mat = mats[entry.materialIndex];
            if (mat == null || !mat.HasProperty(entry.colorProperty)) continue;

            mat.SetColor(entry.colorProperty, entry.originalColor);

            if (entry.hasEmission && mat.HasProperty("_EmissionColor"))
            {
                mat.SetColor("_EmissionColor", entry.originalEmissionColor);
            }
        }

        currentRoutine = null;
    }
}


2.23 Текст программы «FishSpawner.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections.Generic;

public class FishSpawner : MonoBehaviour
{
    [Header("References")]
    public Transform submarine;           // субмарина
    public GameObject[] fishPrefabs;      // префабы рыб (каждая с FishWiggle + FishData)

    [Header("Spawn logic")]
    [Tooltip("Каждые N метров пути лодки делаем попытку спавна.")]
    public float distanceBetweenSpawns = 20f;

    [Tooltip("Максимум живых рыб, чтобы не засорять сцену.")]
    public int maxFishAlive = 30;

    [Header("Where to spawn (базовые хотелки)")]
    [Tooltip("Базовое расстояние ВПЕРЁД по курсу субмарины, куда целимся спавном.")]
    public float aheadDistance = 15f;

    [Tooltip("Разброс влево/вправо от курса (по локальной оси субмарины).")]
    public float sideScatter = 8f;

    [Tooltip("Разброс вверх/вниз от курса (по локальной оси субмарины).")]
    public float upDownScatter = 4f;

    [Header("Corridor safety")]
    [Tooltip("Какие слои считаются препятствием (скалы, стены лабиринта).")]
    public LayerMask obstacleMask;

    [Tooltip("Минимальная дистанция свободного пространства вперёд, чтобы вообще пытаться спавнить.")]
    public float minFreeAhead = 2f;

    [Tooltip("Насколько отступать от стены, чтобы не родить рыбу прям внутри коллайдера.")]
    public float wallBuffer = 1f;

    [Header("Fish params")]
    [Tooltip("Мин. скорость рыбы (FishWiggle.forwardSpeed).")]
    public float minSpeed = 1f;

    [Tooltip("Макс. скорость рыбы (FishWiggle.forwardSpeed).")]
    public float maxSpeed = 3f;

    [Tooltip("Сколько живёт рыба до автоудаления (FishWiggle.maxLifetime).")]
    public float fishLifetime = 20f;

    [Tooltip("На каком расстоянии от подлодки рыба старается держаться.")]
    public float desiredDistanceFromSub = 8f;

    private Vector3 lastSpawnRefPos;
    private bool initialized = false;
    private List<GameObject> alive = new List<GameObject>();

    void Update()
    {
        if (submarine == null || fishPrefabs == null || fishPrefabs.Length == 0)
            return;

        // чистим null'ы (рыб, которые уже уничтожены)
        for (int i = alive.Count - 1; i >= 0; i--)
        {
            if (alive[i] == null)
                alive.RemoveAt(i);
        }

        // не спавним, если мы уже забиты
        if (alive.Count >= maxFishAlive)
            return;

        if (!initialized)
        {
            initialized = true;
            lastSpawnRefPos = submarine.position;
            return;
        }

        float traveled = Vector3.Distance(submarine.position, lastSpawnRefPos);

        if (traveled >= distanceBetweenSpawns)
        {
            lastSpawnRefPos = submarine.position;
            TrySpawnFish();
        }
    }

    void TrySpawnFish()
    {
        // считаем безопасную позицию спавна в лабиринте
        Vector3 spawnPos;
        Quaternion spawnRot;

        if (!ComputeSafeSpawn(out spawnPos, out spawnRot))
        {
            // узкий коридор / сразу стена — не спавним
            return;
        }

        // выберем случайный префаб
        GameObject prefab = fishPrefabs[Random.Range(0, fishPrefabs.Length)];
        if (!prefab) return;

        // создаём рыбу
        GameObject fish = Instantiate(prefab, spawnPos, spawnRot);

        // настроим FishWiggle
        FishWiggle wiggle = fish.GetComponent<FishWiggle>();
        if (wiggle != null)
        {
            wiggle.submarine = submarine;
            wiggle.forwardSpeed = Random.Range(minSpeed, maxSpeed);
            wiggle.desiredDistance = desiredDistanceFromSub;
            wiggle.maxLifetime = fishLifetime;

            // немного разнообразия анимации
            wiggle.frequency *= Random.Range(0.8f, 1.2f);
            wiggle.amplitude *= Random.Range(0.8f, 1.2f);
            wiggle.phaseOffset *= Random.Range(0.8f, 1.2f);
            wiggle.turnSmooth *= Random.Range(0.8f, 1.2f);
        }

        alive.Add(fish);

        // можно включить лог, чтоб понимать где рыба реально спавнится
        // Debug.Log("[FishSpawner] Spawned " + fish.name + " at " + spawnPos);
    }

    bool ComputeSafeSpawn(out Vector3 safePos, out Quaternion safeRot)
    {
        // по умолчанию
        safePos = submarine.position;
        safeRot = Quaternion.identity;

        Vector3 forward = submarine.forward.normalized;
        Vector3 right = submarine.right;
        Vector3 up = submarine.up;

        // 1. проверяем свободное пространство впереди субмарины
        //    рейкастим вперёд до aheadDistance по obstacleMask
        float freeAhead = aheadDistance;
        RaycastHit hit;

        if (Physics.Raycast(
                submarine.position,
                forward,
                out hit,
                aheadDistance,
                obstacleMask,
                QueryTriggerInteraction.Ignore))
        {
            // стена / скала нашлась раньше, чем aheadDistance
            // значит нельзя спавнить за стеной, отступаем немного до неё
            freeAhead = hit.distance - wallBuffer;
        }

        // если прямо перед нами стена вплотную → не спавним сейчас
        if (freeAhead < minFreeAhead)
        {
            return false;
        }

        // 2. боковой и вертикальный разброс
        //    в тесном коридоре (freeAhead маленький) нам нельзя слишком разбрасывать в стороны,
        //    иначе мы снова уйдём в стену. Поэтому адаптивно уменьшаем разброс.
        //
        // идея простая:
        //  - если у нас много свободного вперёд (открытая комната), оставляем полный scatter
        //  - если коридор короткий, режем scatter в 2-3 раза
        //
        float corridorTightness = Mathf.Clamp01(freeAhead / aheadDistance);
        // corridorTightness = 1 → простор, 0 → супер тесно
        // хотим наоборот: чем теснее, тем меньше разброс
        float scatterScale = Mathf.Lerp(0.3f, 1f, corridorTightness);
        float side = Random.Range(-sideScatter, sideScatter) * scatterScale;
        float vertical = Random.Range(-upDownScatter, upDownScatter) * scatterScale;

        // 3. вычисляем итоговую позицию
        safePos =
            submarine.position
            + forward * freeAhead
            + right * side
            + up * vertical;

        // 4. направление рыбы — пусть смотрит примерно куда плывёт субмарина,
        //    чтобы визуально они не стояли боком
        safeRot = Quaternion.LookRotation(forward, Vector3.up);

        return true;
    }
}


2.24 Текст программы «FishSpawnZone.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;

[RequireComponent(typeof(Collider))]
public class FishSpawnZone : MonoBehaviour
{
    [Header("References")]
    [Tooltip("Ссылка на субмарину (игрок).")]
    public Transform submarine;

    [Tooltip("Какие рыбы могут спавниться в этой зоне.")]
    public GameObject[] fishPrefabs;

    [Header("Spawn rules")]
    [Tooltip("Задержка спавна после первого захода (сек).")]
    public float respawnDelayAfterFirstEnter = 30f;

    [Tooltip("В редакторе для теста можно форсировать поведение как у игрока.")]
    public bool debugAllowAnyCollider = false;

    [Header("Spawn area")]
    public Vector3 spawnAreaExtents = new Vector3(5f, 3f, 5f);
    public Vector3 spawnOffset = Vector3.zero;

    [Header("Fish movement params")]
    public float minSpeed = 1f;
    public float maxSpeed = 3f;
    public float fishLifetime = 20f;
    public float desiredDistanceFromSub = 8f;

    [Header("Randomization tweaks")]
    public Vector2 freqRandomMul = new Vector2(0.8f, 1.2f);
    public Vector2 ampRandomMul = new Vector2(0.8f, 1.2f);
    public Vector2 phaseRandomMul = new Vector2(0.8f, 1.2f);
    public Vector2 turnRandomMul = new Vector2(0.8f, 1.2f);

    private Collider triggerZone;

    // --- состояние ---
    private bool firstEnterDone = false;
    private GameObject currentFish;
    private Coroutine pendingSpawnCoroutine;

    void Awake()
    {
        triggerZone = GetComponent<Collider>();
        if (triggerZone != null)
            triggerZone.isTrigger = true;
    }

    void OnTriggerEnter(Collider other)
    {
        if (!IsPlayer(other))
            return;

        // Если рыба уже есть — ничего не делаем
        if (currentFish != null)
            return;

        // Если уже ждём отложенный спавн — тоже не дублируем
        if (pendingSpawnCoroutine != null)
            return;

        if (!firstEnterDone)
        {
            // 1-й заход — спавним сразу
            firstEnterDone = true;
            SpawnOneFish();
        }
        else
        {
            // последующие заходы — спавн через 30 секунд
            pendingSpawnCoroutine = StartCoroutine(SpawnAfterDelay(respawnDelayAfterFirstEnter));
        }
    }

    IEnumerator SpawnAfterDelay(float delay)
    {
        yield return new WaitForSeconds(delay);

        pendingSpawnCoroutine = null;

        // Если за время ожидания рыба появилась (теоретически) — не спавним
        if (currentFish != null)
            yield break;

        SpawnOneFish();
    }

    void SpawnOneFish()
    {
        if (fishPrefabs == null || fishPrefabs.Length == 0)
            return;

        GameObject prefab = fishPrefabs[Random.Range(0, fishPrefabs.Length)];
        if (prefab == null)
            return;

        // случайная точка внутри объёма зоны
        Vector3 localRandom = new Vector3(
            Random.Range(-spawnAreaExtents.x, spawnAreaExtents.x),
            Random.Range(-spawnAreaExtents.y, spawnAreaExtents.y),
            Random.Range(-spawnAreaExtents.z, spawnAreaExtents.z)
        );

        Vector3 spawnPos = transform.position + spawnOffset + localRandom;

        Quaternion spawnRot;
        if (submarine != null)
        {
            Vector3 dir = submarine.forward;
            if (dir.sqrMagnitude < 0.001f) dir = Vector3.forward;
            spawnRot = Quaternion.LookRotation(dir, Vector3.up);
        }
        else
        {
            spawnRot = Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);
        }

        GameObject fishObj = Instantiate(prefab, spawnPos, spawnRot);
        currentFish = fishObj;

        // Привязываем "маячок", чтобы зона знала, когда рыба исчезла
        var marker = fishObj.GetComponent<FishSpawnedMarker>();
        if (marker == null)
            marker = fishObj.AddComponent<FishSpawnedMarker>();
        marker.ownerZone = this;

        // Настройка движения и жизни
        FishWiggle wiggle = fishObj.GetComponent<FishWiggle>();
        if (wiggle != null)
        {
            wiggle.submarine = submarine;
            wiggle.forwardSpeed = Random.Range(minSpeed, maxSpeed);
            wiggle.desiredDistance = desiredDistanceFromSub;
            wiggle.maxLifetime = fishLifetime;

            wiggle.frequency *= Random.Range(freqRandomMul.x, freqRandomMul.y);
            wiggle.amplitude *= Random.Range(ampRandomMul.x, ampRandomMul.y);
            wiggle.phaseOffset *= Random.Range(phaseRandomMul.x, phaseRandomMul.y);
            wiggle.turnSmooth *= Random.Range(turnRandomMul.x, turnRandomMul.y);
        }

        // сбрасываем caught для ловли
        FishData data = fishObj.GetComponent<FishData>();
        if (data != null)
            data.caught = false;
    }

    internal void NotifyFishDestroyed(GameObject fish)
    {
        if (currentFish == fish)
            currentFish = null;
    }

    bool IsPlayer(Collider other)
    {
        if (debugAllowAnyCollider) return true;

        return other.CompareTag("Player") ||
               other.GetComponent<SubmarineController>() != null;
    }

#if UNITY_EDITOR
    void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.cyan;
        Gizmos.matrix = Matrix4x4.TRS(transform.position + spawnOffset, transform.rotation, Vector3.one);
        Gizmos.DrawWireCube(Vector3.zero, spawnAreaExtents * 2f);
    }
#endif
}

/// <summary>
/// Служебный компонент на рыбе: сообщает зоне, когда рыба уничтожена.
/// </summary>
public class FishSpawnedMarker : MonoBehaviour
{
    [HideInInspector] public FishSpawnZone ownerZone;

    void OnDestroy()
    {
        if (ownerZone != null)
            ownerZone.NotifyFishDestroyed(gameObject);
    }
}


2.25 Текст программы «FishWiggle.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

/// <summary>
/// ��� �������� ����
/// </summary>
public enum FishSwimProfile
{
    Simple,     // �������, ��� � ������ ������
    Realistic,  // ����� "�����" ����� �� ����
    Shark       // ����� �����: ������ ���, �������� �����
}
public enum TailSwingPlane
{
    Horizontal, // ����� �����-������ (����)
    Vertical    // ����� �����-���� (��������, ���� � �.�.)
}
public class FishWiggle : MonoBehaviour
{
    [Header("Body wiggle (����� ��������� ���������)")]
    public Transform[] spineBones;
    public float amplitude = 15f;   // ������� ��������� ������ (�������������� ���������)

    [Header("Swim style")]
    public FishSwimProfile swimProfile = FishSwimProfile.Simple;

    // ---------- Realistic (������� ����) ----------
    [Header("Realistic fish settings")]
    public float maxRealisticSpeed = 4f;
    public float minWiggleFrequency = 1f;
    public float maxWiggleFrequency = 4f;
    public float waveLength = 2f;
    public AnimationCurve bendAlongBody =
        AnimationCurve.Linear(0f, 0.2f, 1f, 1f); // ������ ����� �� �����, ����� ������

    // ---------- Shark (�����) ----------
    [Header("Shark settings")]

    [Header("Tail settings")]
    public TailSwingPlane tailSwing = TailSwingPlane.Horizontal;

    [Tooltip("����. ��������, ��� ������� ����� ����� ��� �������")]
    public float sharkMaxSpeed = 6f;
    [Tooltip("���. ������� ������ � �����")]
    public float sharkMinFrequency = 0.8f;
    [Tooltip("����. ������� ������ � �����")]
    public float sharkMaxFrequency = 2.2f;
    [Tooltip("����� ����� ����� ���� (������ = ����� ������� S-�����)")]
    public float sharkWaveLength = 1.3f;
    [Tooltip("������, ��� 0 = ������, 1 = �����. �����, ��� ������ ����� ���� �����.")]
    public AnimationCurve sharkBendCurve =
        new AnimationCurve(
            new Keyframe(0f, 0f),    // ������ ����� ������
            new Keyframe(0.4f, 0.1f),
            new Keyframe(0.7f, 0.6f),
            new Keyframe(1f, 1f)     // ����� ����� �����������
        );
    [Tooltip("��������� ����� ������������ ������ (������ ����)")]
    public float sharkRollAmount = 5f;
    [Tooltip("����� ���� ����� ������������ ������ ������")]
    public float sharkRollPhaseOffset = 0.5f;

    [Header("Simple mode (��� ������ ���������)")]
    public float frequency = 2f;      // ������ simpleFrequency
    public float phaseOffset = 0.5f;  // ������ simplePhaseOffset

    [Header("Swim motion (��� ���� ��������)")]
    public float forwardSpeed = 2f;
    public float turnSmooth = 2f;
    public float wanderAnglePerSec = 10f;

    [Header("Target tracking")]
    public Transform submarine;
    public float desiredDistance = 8f;
    public float approachStrength = 1f;

    [Header("Lifetime")]
    public float maxLifetime = 20f;
    private float lifeTimer = 0f;

    private Quaternion[] baseRot;
    private Vector3 swimDirWorld = Vector3.forward;

    void Start()
    {
        baseRot = new Quaternion[spineBones.Length];
        for (int i = 0; i < spineBones.Length; i++)
            baseRot[i] = spineBones[i].localRotation;

        if (submarine == null)
        {
            swimDirWorld = Random.onUnitSphere;
            swimDirWorld.y *= 0.3f;
            swimDirWorld.Normalize();
        }
    }

    void Update()
    {
        lifeTimer += Time.deltaTime;
        if (lifeTimer >= maxLifetime)
        {
            Destroy(gameObject);
            return;
        }

        AnimateBody();
        ThinkAndSwim();
    }

    void AnimateBody()
    {
        if (spineBones == null || spineBones.Length == 0)
            return;

        switch (swimProfile)
        {
            case FishSwimProfile.Simple:
                AnimateSimple();
                break;
            case FishSwimProfile.Realistic:
                AnimateRealisticFish();
                break;
            case FishSwimProfile.Shark:
                AnimateShark();
                break;
        }
    }

    // --- ������ ������� ����� ---
    void AnimateSimple()
    {
        float t = Time.time * frequency;

        for (int i = 0; i < spineBones.Length; i++)
        {
            float along = (float)i / (spineBones.Length - 1);
            float phase = t + i * phaseOffset;
            float angle = Mathf.Sin(phase) * amplitude * Mathf.Lerp(0.1f, 1f, along);

            spineBones[i].localRotation = baseRot[i] * GetTailRotationDelta(angle);

        }
    }

    // --- ������������ ������� ���� ---
    void AnimateRealisticFish()
    {
        float speedFactor = Mathf.Clamp01(forwardSpeed / Mathf.Max(0.01f, maxRealisticSpeed));
        float currFreq = Mathf.Lerp(minWiggleFrequency, maxWiggleFrequency, speedFactor);
        float time = Time.time * currFreq;

        for (int i = 0; i < spineBones.Length; i++)
        {
            float along = (float)i / (spineBones.Length - 1);
            float phase = time - along * waveLength;
            float wave = Mathf.Sin(phase * Mathf.PI * 2f);

            float localAmp = amplitude * bendAlongBody.Evaluate(along) * (0.5f + speedFactor);
            float angle = wave * localAmp;

            spineBones[i].localRotation = baseRot[i] * GetTailRotationDelta(angle);

        }
    }

    void AnimateShark()
    {
        // ����� � ����� "������": ������� ����, ����� � �������� �����
        float speedFactor = Mathf.Clamp01(forwardSpeed / Mathf.Max(0.01f, sharkMaxSpeed));
        float freq = Mathf.Lerp(sharkMinFrequency, sharkMaxFrequency, speedFactor);
        float time = Time.time * freq;

        for (int i = 0; i < spineBones.Length; i++)
        {
            float along = (float)i / (spineBones.Length - 1); // 0 (������) -> 1 (�����)

            // �����, ������� �� �������� ���� � ������
            float phase = time - along * sharkWaveLength;
            float wave = Mathf.Sin(phase * Mathf.PI * 2f);

            // ��������� ��� ����� ���� ������ �����
            float bend = sharkBendCurve.Evaluate(along);

            float localAmp = amplitude * bend * (0.6f + 0.7f * speedFactor);
            float yaw = wave * localAmp; // "����" ������

            // ����� ���� �������, ����� ����� ���������� �����
            float roll = Mathf.Sin((phase + sharkRollPhaseOffset) * Mathf.PI * 2f)
                         * sharkRollAmount * bend * 0.5f;

            Quaternion bendQ = GetTailRotationDelta(yaw);
            Quaternion rollQ = Quaternion.Euler(0f, 0f, roll);

            spineBones[i].localRotation = baseRot[i] * bendQ * rollQ;
        }
    }


    Quaternion GetTailRotationDelta(float angle)
    {
        // ������� ������ ������ ��������� ���
        switch (tailSwing)
        {
            case TailSwingPlane.Vertical:
                // �����-����: �������� �� ��������� X (pitch)
                return Quaternion.Euler(angle, 0f, 0f);

            case TailSwingPlane.Horizontal:
            default:
                // �����-������: �������� �� ��������� Y (yaw)
                return Quaternion.Euler(0f, angle, 0f);
        }
    }

    void ThinkAndSwim()
    {
        Vector3 targetDir = swimDirWorld;

        if (submarine != null)
        {
            Vector3 toSub = submarine.position - transform.position;
            float dist = toSub.magnitude;

            if (dist > desiredDistance)
            {
                targetDir = Vector3.Lerp(swimDirWorld, toSub.normalized, approachStrength);
            }
            else
            {
                Vector3 perp = Vector3.Cross(toSub.normalized, Vector3.up);
                if (perp == Vector3.zero) perp = Random.onUnitSphere;
                targetDir = Vector3.Lerp(swimDirWorld, perp.normalized, 0.5f);
            }
        }

        Quaternion wanderRot = Quaternion.Euler(
            0f,
            Random.Range(-wanderAnglePerSec, wanderAnglePerSec) * Time.deltaTime,
            0f
        );
        targetDir = wanderRot * targetDir;
        targetDir.Normalize();

        swimDirWorld = targetDir;

        if (swimDirWorld.sqrMagnitude > 0.0001f)
        {
            Quaternion wantRot = Quaternion.LookRotation(swimDirWorld, Vector3.up);
            transform.rotation = Quaternion.Slerp(
                transform.rotation,
                wantRot,
                turnSmooth * Time.deltaTime
            );
        }

        transform.position += transform.forward * forwardSpeed * Time.deltaTime;
    }
}


2.26 Текст программы «HarvestUIManager.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using System;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class HarvestUIManager : MonoBehaviour
{
    [Header("Choice Popup (Да/Нет)")]
    public GameObject promptPanel;
    public TextMeshProUGUI promptText;
    public Button yesButton;
    public Button noButton;

    [Header("Cut Choice Popup (Филе / Туша)")]
    public GameObject cutChoicePanel;
    public TextMeshProUGUI cutChoiceText;
    public Button filletButton;
    public Button carcassButton;

    [Header("Info Panel (описание вида)")]
    public GameObject infoPanel;
    public TextMeshProUGUI infoText;
    public Button infoCloseButton;

    // runtime-ссылки на текущий кэпч
    private FishData pendingFish;
    private GameObject pendingFishObj;
    private FishCatcher catcher;

    // был ли вид известен на момент поимки (чтобы лор показать только один раз)
    private bool wasKnownAtCatch = false;

    // только заморозка (подсветку убрали)
    private FishFreezeController freezeCtrl;

    void Start()
    {
        HidePrompt();
        HideCutChoicePanel();
        HideInfoPanel();

        if (yesButton != null)
        {
            yesButton.onClick.RemoveAllListeners();
            yesButton.onClick.AddListener(OnYes);
        }
        if (noButton != null)
        {
            noButton.onClick.RemoveAllListeners();
            noButton.onClick.AddListener(OnNo);
        }
        if (filletButton != null)
        {
            filletButton.onClick.RemoveAllListeners();
            filletButton.onClick.AddListener(OnFillet);
        }
        if (carcassButton != null)
        {
            carcassButton.onClick.RemoveAllListeners();
            carcassButton.onClick.AddListener(OnCarcass);
        }
        if (infoCloseButton != null)
        {
            infoCloseButton.onClick.RemoveAllListeners();
            infoCloseButton.onClick.AddListener(HideInfoPanel);
        }

        Debug.Log("[HarvestUI] Start: wiring done");
    }

    // === ПУБЛИЧНЫЙ ВХОД ОТ FishCatcher ===
    // Всегда показываем окно; лор — только при первом знакомстве
    public void ShowPrompt(FishData fish, GameObject fishObj, FishCatcher whoCalled)
    {
        pendingFish = fish;
        pendingFishObj = fishObj;
        catcher = whoCalled;

        wasKnownAtCatch = false;
        if (FishKnowledge.Instance != null && fish != null)
            wasKnownAtCatch = FishKnowledge.Instance.IsKnown(fish.fishName);

        // Показать вопрос
        if (promptPanel != null) promptPanel.SetActive(true);
        if (promptText != null && fish != null)
            promptText.text = $"Освежевать водного обитателя?\n{fish.fishName}";

        HideInfoPanel();
        HideCutChoicePanel();

        // Сразу стопаем рыбу, чтобы не уплывала во время выбора
        FreezeFish();

        // Ставим игру на паузу
        Time.timeScale = 0f;

        // В режиме шутера при таком popup курсор нужен
        SetCursorForUI(true);

        Debug.Log("[HarvestUI] Catch: " + (fish != null ? fish.fishName : "null") +
                  " → показать выбор (always), wasKnown=" + wasKnownAtCatch);
    }

    // === КНОПКИ "ДА"/"НЕТ" И ВТОРОЙ ВЫБОР ===============================

    // Игрок нажал "ДА" -> показываем модалку Филе/Туша
    void OnYes()
    {
        Debug.Log("[HarvestUI] YES clicked. pendingFish=" + (pendingFish != null ? pendingFish.fishName : "null"));

        HidePrompt();

        if (cutChoicePanel != null) cutChoicePanel.SetActive(true);
        if (cutChoiceText != null) cutChoiceText.text = "Желаете получить филе или тушу?";
        // Пауза остаётся; рыба заморожена контроллером
        // Курсор уже включён в ShowPrompt()
    }

    // Игрок нажал "НЕТ"
    void OnNo()
    {
        Debug.Log("[HarvestUI] NO clicked. pendingFish=" + (pendingFish != null ? pendingFish.fishName : "null"));

        if (catcher != null && pendingFish != null)
        {
            // butcher=false → рыба просто исчезает, без урона/пользы
            catcher.ResolveCatch(pendingFish, pendingFishObj, false);
        }

        ClearPending(); // снимаем всё и резюмим время
    }

    // === Игрок выбрал "Филе" ====================================
    void OnFillet()
    {
        Debug.Log("[HarvestUI] FILLET clicked. pendingFish=" + (pendingFish != null ? pendingFish.fishName : "null"));

        if (catcher != null && pendingFish != null && pendingFishObj != null)
        {
            var seq = pendingFishObj.GetComponent<ButcherSequencer>();

            // Снимаем паузу, чтобы пошёл секвенсер
            Time.timeScale = 1f;
            if (cutChoicePanel != null) cutChoicePanel.SetActive(false);

            // курсор пока оставляем видимым, игрок только что кликнул по UI,
            // а дальше может показаться панель лора

            // локальные копии для колбэка
            var fish = pendingFish;
            var fishGO = pendingFishObj;
            var fc = catcher;
            bool showLoreAtEnd = (FishKnowledge.Instance != null) ? !FishKnowledge.Instance.IsKnown(fish.fishName) : false;

            Action finish = () =>
            {
                // очки/здоровье и т.д.
                fc.ResolveCatch(fish, fishGO, true);

                if (FishKnowledge.Instance != null)
                    FishKnowledge.Instance.MarkKnown(fish.fishName);

                // 🔸 вот тут показываем hint через HintsPopupUI
                string resultText = $"Вы заполучили филе {fish.fishName}";
                ShowHarvestHint(resultText);

                // лор — отдельно, только описание вида
                if (showLoreAtEnd && !string.IsNullOrEmpty(fish.description))
                    ShowInfoPanelWithText(fish.description);

                ClearPending(); // размораживаем и очищаем (курсор спрячется, если лора нет)
            };

            if (seq != null)
            {
                // важно: чтобы секвенсер знал, кого разделывает
                seq.Setup(fc, fish, fishGO);
                seq.StartButchering(HarvestMode.Fillet, finish);
            }
            else
            {
                finish();
            }
        }
    }

    // === Игрок выбрал "Туша" ====================================
    void OnCarcass()
    {
        Debug.Log("[HarvestUI] CARCASS clicked. pendingFish=" + (pendingFish != null ? pendingFish.fishName : "null"));

        if (catcher != null && pendingFish != null && pendingFishObj != null)
        {
            var seq = pendingFishObj.GetComponent<ButcherSequencer>();

            // Снимаем паузу для последовательности разделки
            Time.timeScale = 1f;
            if (cutChoicePanel != null) cutChoicePanel.SetActive(false);

            var fish = pendingFish;
            var fishGO = pendingFishObj;
            var fc = catcher;
            bool showLoreAtEnd = (FishKnowledge.Instance != null) ? !FishKnowledge.Instance.IsKnown(fish.fishName) : false;

            Action finish = () =>
            {
                fc.ResolveCatch(fish, fishGO, true);

                if (FishKnowledge.Instance != null)
                    FishKnowledge.Instance.MarkKnown(fish.fishName);

                // 🔸 hint для туши
                string resultText = $"Вы заполучили тушу {fish.fishName}";
                ShowHarvestHint(resultText);

                // лор — если первый раз
                if (showLoreAtEnd && !string.IsNullOrEmpty(fish.description))
                    ShowInfoPanelWithText(fish.description);

                ClearPending();
            };

            if (seq != null)
            {
                seq.Setup(fc, fish, fishGO);
                seq.StartButchering(HarvestMode.Carcass, finish);
            }
            else
            {
                finish();
            }
        }
    }

    void ShowInfoPanelWithText(string body)
    {
        if (infoPanel != null) infoPanel.SetActive(true);
        if (infoText != null) infoText.text = body;

        // при показе лора курсор тоже нужен
        SetCursorForUI(true);

        Debug.Log("[HarvestUI] ShowInfoPanel (lore): " + body);
    }

    void ShowHarvestHint(string msg)
    {
        if (HintsPopupUI.I != null)
        {
            // Можно передать своё время показа, например 3 секунды
            HintsPopupUI.I.Enqueue(msg, 3f);
        }
        else
        {
            Debug.Log("[HarvestUI] HintsPopupUI.I is null. Msg: " + msg, this);
        }
    }

    void HideInfoPanel()
    {
        if (infoPanel != null) infoPanel.SetActive(false);

        // Если больше нет UI по разделке — возвращаем шутерный режим
        if ((promptPanel == null || !promptPanel.activeSelf) &&
            (cutChoicePanel == null || !cutChoicePanel.activeSelf))
        {
            SetCursorForUI(false);
        }
    }

    // === СЛУЖЕБНЫЕ ХЕЛПЕРЫ ======================================

    void HidePrompt()
    {
        if (promptPanel != null) promptPanel.SetActive(false);
    }

    void HideCutChoicePanel()
    {
        if (cutChoicePanel != null) cutChoicePanel.SetActive(false);
    }

    // Только фриз/анфриз без подсветки
    void FreezeFish()
    {
        if (!pendingFishObj) return;

        if (!freezeCtrl) freezeCtrl = pendingFishObj.GetComponent<FishFreezeController>();
        if (!freezeCtrl) freezeCtrl = pendingFishObj.AddComponent<FishFreezeController>();

        freezeCtrl.Freeze();

        Debug.Log($"[HarvestUI] Freeze: fish='{pendingFishObj.name}'");
    }

    void UnfreezeFish()
    {
        if (freezeCtrl) freezeCtrl.Unfreeze();
        freezeCtrl = null;
    }

    // Сценарий: была пауза (новая рыба), надо снять паузу и очистить состояние
    void ClearPending()
    {
        // вернуть управление рыбой (если объект ещё жив)
        UnfreezeFish();

        // снять паузу (если стояла)
        Time.timeScale = 1f;

        // скрыть модалки
        if (promptPanel != null) promptPanel.SetActive(false);
        if (cutChoicePanel != null) cutChoicePanel.SetActive(false);

        // очистить ссылки
        pendingFish = null;
        pendingFishObj = null;
        catcher = null;

        // если панель лора НЕ показана — возвращаем шутерный режим
        if (infoPanel == null || !infoPanel.activeSelf)
        {
            SetCursorForUI(false);
        }

        Debug.Log("[HarvestUI] ClearPending -> resume time");
    }

    // Сценарий: рыба уже известна, мы не ставили паузу вообще
    void ClearPending_NoUnpause()
    {
        UnfreezeFish();
        HidePrompt();
        HideCutChoicePanel();

        pendingFish = null;
        pendingFishObj = null;
        catcher = null;

        if (infoPanel == null || !infoPanel.activeSelf)
        {
            SetCursorForUI(false);
        }

        Debug.Log("[HarvestUI] ClearPending_NoUnpause (не было паузы)");
    }

    // --- Управление курсором под шутерный режим ---
    void SetCursorForUI(bool uiActive)
    {
#if UNITY_STANDALONE || UNITY_EDITOR
        if (uiActive)
        {
            Cursor.lockState = CursorLockMode.None;
            Cursor.visible = true;
        }
        else
        {
            Cursor.lockState = CursorLockMode.Locked;
            Cursor.visible = false;
        }
#endif
    }
}


2.27 Текст программы «HarvestUIManagerMobile.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using System;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class HarvestUIManagerMobile : MonoBehaviour
{
    [Header("Choice Popup (Да/Нет)")]
    public GameObject promptPanel;
    public TextMeshProUGUI promptText;
    public Button yesButton;
    public Button noButton;

    [Header("Cut Choice Popup (Филе / Туша)")]
    public GameObject cutChoicePanel;
    public TextMeshProUGUI cutChoiceText;
    public Button filletButton;
    public Button carcassButton;

    [Header("Info Panel (описание вида)")]
    public GameObject infoPanel;
    public TextMeshProUGUI infoText;
    private Button infoPanelButton;

    // runtime-ссылки на текущий кэпч
    private FishData pendingFish;
    private GameObject pendingFishObj;
    private FishCatcher catcher;

    // был ли вид известен на момент поимки (чтобы лор показать только один раз)
    private bool wasKnownAtCatch = false;

    // только заморозка (подсветку убрали)
    private FishFreezeController freezeCtrl;

    void Start()
    {
        HidePrompt();
        HideCutChoicePanel();
        HideInfoPanel();

        if (yesButton != null)
        {
            yesButton.onClick.RemoveAllListeners();
            yesButton.onClick.AddListener(OnYes);
        }
        if (noButton != null)
        {
            noButton.onClick.RemoveAllListeners();
            noButton.onClick.AddListener(OnNo);
        }
        if (filletButton != null)
        {
            filletButton.onClick.RemoveAllListeners();
            filletButton.onClick.AddListener(OnFillet);
        }
        if (carcassButton != null)
        {
            carcassButton.onClick.RemoveAllListeners();
            carcassButton.onClick.AddListener(OnCarcass);
        }
      
        SetupInfoPanelTapToClose();

        Debug.Log("[HarvestUI] Start: wiring done");
    }

    void SetupInfoPanelTapToClose()
    {
        if (infoPanel == null) return;

        // Пытаемся найти уже существующий Button на панели
        infoPanelButton = infoPanel.GetComponent<Button>();

        if (infoPanelButton == null)
        {
            // Если кнопки нет — добавляем
            infoPanelButton = infoPanel.AddComponent<Button>();
            infoPanelButton.transition = Selectable.Transition.None;

            // Попробуем назначить targetGraphic (если есть Image)
            var img = infoPanel.GetComponent<Image>();
            if (img != null)
            {
                infoPanelButton.targetGraphic = img;
            }
        }

        infoPanelButton.onClick.RemoveAllListeners();
        infoPanelButton.onClick.AddListener(HideInfoPanel);
    }
    // === ПУБЛИЧНЫЙ ВХОД ОТ FishCatcher ===
    // Всегда показываем окно; лор — только при первом знакомстве
    public void ShowPrompt(FishData fish, GameObject fishObj, FishCatcher whoCalled)
    {
        pendingFish = fish;
        pendingFishObj = fishObj;
        catcher = whoCalled;

        wasKnownAtCatch = false;
        if (FishKnowledge.Instance != null && fish != null)
            wasKnownAtCatch = FishKnowledge.Instance.IsKnown(fish.fishName);

        // Показать вопрос
        if (promptPanel != null) promptPanel.SetActive(true);
        if (promptText != null && fish != null)
            promptText.text = $"Освежевать водного обитателя?\n{fish.fishName}";

        HideInfoPanel();
        HideCutChoicePanel();

        // Сразу стопаем рыбу, чтобы не уплывала во время выбора
        FreezeFish();

        // Ставим игру на паузу
        Time.timeScale = 0f;

        Debug.Log("[HarvestUI] Catch: " + (fish != null ? fish.fishName : "null") +
                  " → показать выбор (always), wasKnown=" + wasKnownAtCatch);
    }

    // === КНОПКИ "ДА"/"НЕТ" И ВТОРОЙ ВЫБОР ===============================

    // Игрок нажал "ДА" -> показываем модалку Филе/Туша
    void OnYes()
    {
        Debug.Log("[HarvestUI] YES clicked. pendingFish=" + (pendingFish != null ? pendingFish.fishName : "null"));

        HidePrompt();

        if (cutChoicePanel != null) cutChoicePanel.SetActive(true);
        if (cutChoiceText != null) cutChoiceText.text = "Желаете получить филе или тушу?";
        // Пауза остаётся; рыба заморожена контроллером
    }

    // Игрок нажал "НЕТ"
    void OnNo()
    {
        Debug.Log("[HarvestUI] NO clicked. pendingFish=" + (pendingFish != null ? pendingFish.fishName : "null"));

        if (catcher != null && pendingFish != null)
        {
            // butcher=false → рыба просто исчезает, без урона/пользы
            catcher.ResolveCatch(pendingFish, pendingFishObj, false);
        }

        ClearPending(); // снимаем всё и резюмим время
    }

    // === Игрок выбрал "Филе" ====================================
    void OnFillet()
    {
        Debug.Log("[HarvestUI] FILLET clicked. pendingFish=" + (pendingFish != null ? pendingFish.fishName : "null"));

        if (catcher != null && pendingFish != null && pendingFishObj != null)
        {
            var seq = pendingFishObj.GetComponent<ButcherSequencer>();

            // Снимаем паузу, чтобы пошёл секвенсер
            Time.timeScale = 1f;
            if (cutChoicePanel != null) cutChoicePanel.SetActive(false);

            // локальные копии для колбэка
            var fish = pendingFish;
            var fishGO = pendingFishObj;
            var fc = catcher;
            bool showLoreAtEnd = (FishKnowledge.Instance != null) ? !FishKnowledge.Instance.IsKnown(fish.fishName) : false;

            Action finish = () =>
            {
                // очки/здоровье и т.д.
                fc.ResolveCatch(fish, fishGO, true);

                if (FishKnowledge.Instance != null)
                    FishKnowledge.Instance.MarkKnown(fish.fishName);

                // 🔸 вот тут показываем hint через HintsPopupUI
                string resultText = $"Вы заполучили филе {fish.fishName}";
                ShowHarvestHint(resultText);

                // лор — отдельно, только описание вида
                if (showLoreAtEnd && !string.IsNullOrEmpty(fish.description))
                    ShowInfoPanelWithText(fish.description);

                ClearPending(); // размораживаем и очищаем
            };

            if (seq != null)
            {
                // важно: чтобы секвенсер знал, кого разделывает
                seq.Setup(fc, fish, fishGO);
                seq.StartButchering(HarvestMode.Fillet, finish);
            }
            else
            {
                finish();
            }
        }
    }

    // === Игрок выбрал "Туша" ====================================
    void OnCarcass()
    {
        Debug.Log("[HarvestUI] CARCASS clicked. pendingFish=" + (pendingFish != null ? pendingFish.fishName : "null"));

        if (catcher != null && pendingFish != null && pendingFishObj != null)
        {
            var seq = pendingFishObj.GetComponent<ButcherSequencer>();

            // Снимаем паузу для последовательности разделки
            Time.timeScale = 1f;
            if (cutChoicePanel != null) cutChoicePanel.SetActive(false);

            var fish = pendingFish;
            var fishGO = pendingFishObj;
            var fc = catcher;
            bool showLoreAtEnd = (FishKnowledge.Instance != null) ? !FishKnowledge.Instance.IsKnown(fish.fishName) : false;

            Action finish = () =>
            {
                fc.ResolveCatch(fish, fishGO, true);

                if (FishKnowledge.Instance != null)
                    FishKnowledge.Instance.MarkKnown(fish.fishName);

                // 🔸 hint для туши
                string resultText = $"Вы заполучили тушу {fish.fishName}";
                ShowHarvestHint(resultText);

                // лор — если первый раз
                if (showLoreAtEnd && !string.IsNullOrEmpty(fish.description))
                    ShowInfoPanelWithText(fish.description);

                ClearPending();
            };

            if (seq != null)
            {
                seq.Setup(fc, fish, fishGO);
                seq.StartButchering(HarvestMode.Carcass, finish);
            }
            else
            {
                finish();
            }
        }
    }


    void ShowInfoPanelWithText(string body)
    {
        if (infoPanel != null) infoPanel.SetActive(true);
        if (infoText != null) infoText.text = body;
        Debug.Log("[HarvestUI] ShowInfoPanel (lore): " + body);
    }
    void ShowHarvestHint(string msg)
    {
        if (HintsPopupUI.I != null)
        {
            // Можно передать своё время показа, например 3 секунды
            HintsPopupUI.I.Enqueue(msg, 3f);
        }
        else
        {
            Debug.Log("[HarvestUI] HintsPopupUI.I is null. Msg: " + msg, this);
        }
    }

    void HideInfoPanel()
    {
        if (infoPanel != null) infoPanel.SetActive(false);
    }

    // === СЛУЖЕБНЫЕ ХЕЛПЕРЫ ======================================

    void HidePrompt()
    {
        if (promptPanel != null) promptPanel.SetActive(false);
    }

    void HideCutChoicePanel()
    {
        if (cutChoicePanel != null) cutChoicePanel.SetActive(false);
    }

    // Только фриз/анфриз без подсветки
    void FreezeFish()
    {
        if (!pendingFishObj) return;

        if (!freezeCtrl) freezeCtrl = pendingFishObj.GetComponent<FishFreezeController>();
        if (!freezeCtrl) freezeCtrl = pendingFishObj.AddComponent<FishFreezeController>();

        freezeCtrl.Freeze();

        Debug.Log($"[HarvestUI] Freeze: fish='{pendingFishObj.name}'");
    }

    void UnfreezeFish()
    {
        if (freezeCtrl) freezeCtrl.Unfreeze();
        freezeCtrl = null;
    }

    // Сценарий: была пауза (новая рыба), надо снять паузу и очистить состояние
    void ClearPending()
    {
        // вернуть управление рыбой (если объект ещё жив)
        UnfreezeFish();

        // снять паузу
        Time.timeScale = 1f;

        // скрыть модалки
        if (promptPanel != null) promptPanel.SetActive(false);
        if (cutChoicePanel != null) cutChoicePanel.SetActive(false);

        // очистить ссылки
        pendingFish = null;
        pendingFishObj = null;
        catcher = null;

        Debug.Log("[HarvestUI] ClearPending -> resume time");
    }

    // Сценарий: рыба уже известна, мы не ставили паузу вообще
    void ClearPending_NoUnpause()
    {
        UnfreezeFish();
        HidePrompt();
        HideCutChoicePanel();

        pendingFish = null;
        pendingFishObj = null;
        catcher = null;

        Debug.Log("[HarvestUI] ClearPending_NoUnpause (не было паузы)");
    }
}


2.28 Текст программы «HintsPopupUI.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using TMPro;

public class HintsPopupUI : MonoBehaviour
{
    public static HintsPopupUI I;          // singleton ��� ������� �������

    [Header("UI")]
    public CanvasGroup canvasGroup;        // alpha
    public TextMeshProUGUI label;          // ����� ���������

    [Header("Timings (���)")]
    public float fadeIn = 0.15f;
    public float hold = 2.2f;
    public float fadeOut = 0.25f;

    Queue<(string msg, float hold)> q = new Queue<(string, float)>();
    Coroutine runner;
    string lastMsg = null;

    void Awake()
    {
        I = this;
        if (canvasGroup) canvasGroup.alpha = 0f;
    }

    /// ��������� ��������� � ������� (���� ����� �� ��� �� ������ � �� ���������).
    public void Enqueue(string msg, float customHold = -1f)
    {
        if (string.IsNullOrWhiteSpace(msg)) return;
        if (label && lastMsg == msg && canvasGroup && canvasGroup.alpha > 0.5f) return; // ����-����
        q.Enqueue((msg, customHold > 0 ? customHold : hold));
        if (runner == null) runner = StartCoroutine(Run());
    }

    IEnumerator Run()
    {
        while (q.Count > 0)
        {
            var (msg, h) = q.Dequeue();
            lastMsg = msg;
            if (label) label.text = msg;

            // fade in
            float t = 0;
            while (t < fadeIn)
            {
                t += Time.unscaledDeltaTime;
                if (canvasGroup) canvasGroup.alpha = Mathf.SmoothStep(0, 1, t / fadeIn);
                yield return null;
            }
            if (canvasGroup) canvasGroup.alpha = 1;

            // hold
            float w = 0;
            while (w < h) { w += Time.unscaledDeltaTime; yield return null; }

            // fade out
            t = 0;
            while (t < fadeOut)
            {
                t += Time.unscaledDeltaTime;
                if (canvasGroup) canvasGroup.alpha = Mathf.SmoothStep(1, 0, t / fadeOut);
                yield return null;
            }
            if (canvasGroup) canvasGroup.alpha = 0;
        }
        runner = null;
        lastMsg = null;
    }
    // � HintsPopupUI.cs
    public void ShowSticky(string msg)
    {
        StopAllCoroutines();
        if (label) label.text = msg;
        if (canvasGroup) canvasGroup.alpha = 1f;   // ���������� � ������
    }

    public void HideImmediate()
    {
        StopAllCoroutines();
        if (canvasGroup) canvasGroup.alpha = 0f;   // ������ �����
    }

}


2.29 Текст программы «HintsPref.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public static class HintsPref
{
    const string Key = "HintsEnabled";
    public static bool Get() => PlayerPrefs.GetInt(Key, 1) == 1;     // �� ��������� ���
    public static void Set(bool v) { PlayerPrefs.SetInt(Key, v ? 1 : 0); PlayerPrefs.Save(); }
}


2.30 Текст программы «HintsRuntime.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using System.Collections.Generic;
using UnityEngine;

public static class HintsRuntime
{
    // �������� �� ������
    static readonly Dictionary<string, float> lastShown = new Dictionary<string, float>();

    /// �������� ��������� (��������� ������-����� HintsPref)
    public static void Show(string msg, float hold = -1f, string cooldownKey = null, float cooldownSec = 0f)
    {
        if (!HintsPref.Get()) return;

        if (!string.IsNullOrEmpty(cooldownKey) && cooldownSec > 0f)
        {
            float now = Time.unscaledTime;
            if (lastShown.TryGetValue(cooldownKey, out var last) && now - last < cooldownSec) return;
            lastShown[cooldownKey] = now;
        }

        if (HintsPopupUI.I) HintsPopupUI.I.Enqueue(msg, hold);
    }

    /// �������� ������ ���� ��� (������������ � PlayerPrefs �� �����)
    public static void ShowOnce(string key, string msg, float hold = -1f)
    {
        if (!HintsPref.Get()) return;
        string pkey = "hint_once_" + key;
        if (PlayerPrefs.GetInt(pkey, 0) == 1) return;
        PlayerPrefs.SetInt(pkey, 1);
        PlayerPrefs.Save();
        if (HintsPopupUI.I) HintsPopupUI.I.Enqueue(msg, hold);
    }
}


2.31 Текст программы «HintsToggleWithSave.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(Toggle))]
public class HintsToggleWithSave : MonoBehaviour
{
    [Header("UI")]
    public Toggle toggle;          // ���� Toggle "�������� ���������?"
    public Button saveButton;      // ������ "���������" (���������� ���������)
    public Button cancelButton;    // (���.) "��������"

    bool initialValue;

    void Awake()
    {
        toggle ??= GetComponent<Toggle>();

        // ��������� ���������� ��������
        initialValue = HintsPref.Get();
        toggle.isOn = initialValue;

        if (saveButton) { saveButton.interactable = false; saveButton.onClick.AddListener(Save); }
        if (cancelButton) cancelButton.onClick.AddListener(Cancel);

        toggle.onValueChanged.AddListener(_ => OnChanged());
    }

    void OnDestroy()
    {
        toggle.onValueChanged.RemoveAllListeners();
        if (saveButton) saveButton.onClick.RemoveAllListeners();
        if (cancelButton) cancelButton.onClick.RemoveAllListeners();
    }

    void OnChanged()
    {
        if (saveButton) saveButton.interactable = (toggle.isOn != initialValue);
    }

    public void Save()
    {
        HintsPref.Set(toggle.isOn);
        initialValue = toggle.isOn;
        if (saveButton) saveButton.interactable = false;
    }

    public void Cancel()
    {
        toggle.isOn = initialValue;
        if (saveButton) saveButton.interactable = false;
    }
}


2.32 Текст программы «IChunkGenerator.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
public interface IChunkGenerator
{
    // ������������� ���������� ����� � ��� ��������� ������������.
    void GenerateChunk(int width, int height, int seed);
}


2.33 Текст программы «IHarvestUI.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public interface IHarvestUI
{
    void ShowPrompt(FishData fish, GameObject fishObj, FishCatcher whoCalled);
}


2.34 Текст программы «LightFlicker.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
public class LightFlicker : MonoBehaviour
{
    public Light targetLight;
    public float baseIntensity = 3f;
    public float flickerAmount = 0.2f;
    public float flickerSpeed = 2f;

    void Update()
    {
        if (!targetLight) return;

        float noise = Mathf.PerlinNoise(Time.time * flickerSpeed, 0f);
        targetLight.intensity = baseIntensity + (noise - 0.5f) * flickerAmount;
    }
}


2.35 Текст программы «MainMenuUI.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using UnityEngine.SceneManagement;

public class MainMenuUI : MonoBehaviour
{
    [Header("Scenes")]
    // ��� ����� � ��������� (���� ������ �� Start)
    public string gameSceneName = "Game";

    [Header("UI Panels")]
    // ������ � �������� "������ / ����� / ���������"
    public GameObject mainPanel;
    // ������ "���������"
    public GameObject settingsPanel;

    [Header("Audio")]
    // ������ �� ������ � ������� ���� (MenuAudio � ����������� MenuMusic)
    public MenuMusic menuMusic;

    void Start()
    {
        // �������� ������� ���� � �������� ���������
        if (mainPanel != null) mainPanel.SetActive(true);
        if (settingsPanel != null) settingsPanel.SetActive(false);
    }

    // ������ "������ ����"
    public void StartGame()
    {
        // ����� ��������� � ���� � ���������� � ���������� ������ ����
        if (menuMusic != null)
        {
            menuMusic.StopAndDestroy();
        }

        SceneManager.LoadScene(gameSceneName);
    }

    // ������ "���������"
    public void OpenSettings()
    {
        if (mainPanel != null) mainPanel.SetActive(false);
        if (settingsPanel != null) settingsPanel.SetActive(true);
    }

    // ������ "�����" � ����������
    public void CloseSettings()
    {
        if (settingsPanel != null) settingsPanel.SetActive(false);
        if (mainPanel != null) mainPanel.SetActive(true);
    }

    // ������ "�����"
    public void QuitGame()
    {
        Application.Quit();
        Debug.Log("Quit requested");
    }
}


2.36 Текст программы «MenuIntroFade.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;

public class MenuIntroFade : MonoBehaviour
{
    public CanvasGroup group;
    public float fadeTime = 0.5f;
    public float startDelay = 0.2f;
    public Vector3 startScale = new Vector3(1.05f, 1.05f, 1f);

    void Reset()
    {
        group = GetComponent<CanvasGroup>();
    }

    void Awake()
    {
        if (group == null) group = GetComponent<CanvasGroup>();
        group.alpha = 0f;
        transform.localScale = startScale;
    }

    void OnEnable()
    {
        StartCoroutine(PlayIntro());
    }

    IEnumerator PlayIntro()
    {
        yield return new WaitForSeconds(startDelay);

        float t = 0f;
        Vector3 scaleFrom = transform.localScale;
        Vector3 scaleTo = Vector3.one;
        float alphaFrom = 0f;
        float alphaTo = 1f;

        while (t < fadeTime)
        {
            t += Time.deltaTime;
            float k = t / fadeTime;
            // ������, �� �� ������� ��-�������� � ease out
            float ease = 1f - Mathf.Pow(1f - k, 3f);

            group.alpha = Mathf.Lerp(alphaFrom, alphaTo, ease);
            transform.localScale = Vector3.Lerp(scaleFrom, scaleTo, ease);

            yield return null;
        }

        group.alpha = 1f;
        transform.localScale = Vector3.one;
    }
}


2.37 Текст программы «MenuMusic.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public class MenuMusic : MonoBehaviour
{
    private AudioSource src;

    void Awake()
    {
        src = GetComponent<AudioSource>();
        if (!src)
        {
            Debug.LogWarning("[MenuMusic] AudioSource �� ������ �� ������� MenuAudio.");
        }
    }

    // �������, ����� �������� ����.
    public void StopAndDestroy()
    {
        if (src)
        {
            src.Stop();
        }

        // ������� ������, ����� ������ �� �������� ������ ����� �������
        Destroy(gameObject);
    }
}


2.38 Текст программы «MobileMoveJoystick.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using UnityEngine.EventSystems;

public class MobileMoveJoystick : MonoBehaviour, IPointerDownHandler, IDragHandler, IPointerUpHandler
{
    [Header("UI")]
    public RectTransform handle;   // ���������� �����

    [Header("���������")]
    public float maxRadius = 80f;  // ������ ���� �����
    public float deadZone = 0.1f; // ������ ���� �� ������

    private Vector2 input;         // -1..1 �� X/Y
    private Vector2 startPos;

    public float Horizontal
    {
        get
        {
            float v = Mathf.Abs(input.x) < deadZone ? 0f : input.x;
            Debug.Log($"[Joystick] H={v:F2}");
            return v;
        }
    }

    public float Vertical
    {
        get
        {
            float v = Mathf.Abs(input.y) < deadZone ? 0f : input.y;
            Debug.Log($"[Joystick] V={v:F2}");
            return v;
        }
    }

    private void Awake()
    {
        Debug.Log("[Joystick] Awake");

        if (!handle)
        {
            if (transform.childCount > 0)
                handle = transform.GetChild(0) as RectTransform;
        }

        if (!handle)
        {
            Debug.LogWarning("[Joystick] Handle �� ��������!");
        }
        else
        {
            startPos = handle.anchoredPosition;
        }
    }

    private void OnEnable()
    {
        Debug.Log("[Joystick] OnEnable");
    }

    public void OnPointerDown(PointerEventData eventData)
    {
        Debug.Log("[Joystick] OnPointerDown");
        OnDrag(eventData);
    }

    public void OnDrag(PointerEventData eventData)
    {
        RectTransform rt = (RectTransform)transform;

        Vector2 localPoint;
        if (!RectTransformUtility.ScreenPointToLocalPointInRectangle(
                rt, eventData.position, eventData.pressEventCamera, out localPoint))
            return;

        // ����� ��������� � ���, ��� ����� ���� ����������
        Vector2 center = startPos;

        // �������� �� ������
        Vector2 offset = localPoint - center;

        // ������������ ������
        if (offset.magnitude > maxRadius)
            offset = offset.normalized * maxRadius;

        // ������� �����
        if (handle)
            handle.anchoredPosition = center + offset;

        // ��������������� �������� -1..1
        input = offset / maxRadius;

        Debug.Log($"[Joystick] Drag input={input}");
    }


    public void OnPointerUp(PointerEventData eventData)
    {
        Debug.Log("[Joystick] OnPointerUp");

        input = Vector2.zero;

        if (handle)
            handle.anchoredPosition = startPos;
    }
}


2.39 Текст программы «MobilePerfBootstrap.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public class MobilePerfBootstrap : MonoBehaviour
{
    void Awake()
    {
#if UNITY_WEBGL && !UNITY_EDITOR
        if (WebGLBrowserCheck.IsMobileBrowser())
        {
            Application.targetFrameRate = 30;
        }
#elif UNITY_ANDROID || UNITY_IOS
        Application.targetFrameRate = 30;
#endif
    }
}


2.40 Текст программы «MobileShaderSimplifier.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

/// <summary>
/// На мобилках заменяет только указанные "тяжёлые" шейдеры на простые.
/// Повесь на один объект в сцене (например, System).
/// </summary>
public class MobileShaderReplacer : MonoBehaviour
{
    [System.Serializable]
    public class ShaderMapping
    {
        [Tooltip("Исходный ТЯЖЁЛЫЙ шейдер, который хотим заменить (например, подводный эффект и т.п.)")]
        public Shader sourceShader;

        [Tooltip("Более простой шейдер для мобилок (например, Unlit/Texture или Mobile/Diffuse)")]
        public Shader mobileShader;
    }

    [Header("Какие шейдеры заменяем на мобилках")]
    public ShaderMapping[] mappings;

    [Header("Область действия")]
    [Tooltip("Обрабатывать всех Renderer во всей сцене (FindObjectsOfType). " +
             "Если выключено — только детей этого объекта.")]
    public bool affectWholeScene = true;

    [Header("Отладка")]
    [Tooltip("В редакторе принудительно включать мобильный режим (для проверки).")]
    public bool forceInEditor = false;

    [Tooltip("Писать в лог, какие материалы были заменены.")]
    public bool logChanges = true;


    void Awake()
    {
        if (!ShouldRun())
        {
            enabled = false;
            return;
        }

        if (mappings == null || mappings.Length == 0)
        {
            Debug.LogWarning("[MobileShaderReplacer] Нет настроенных маппингов шейдеров, ничего не делаю.");
            enabled = false;
            return;
        }

        ReplaceShaders();
    }

    bool ShouldRun()
    {
        // Здесь можно завязаться на твой WebGLBrowserCheck
#if UNITY_WEBGL && !UNITY_EDITOR
        // Если используешь JS-плагин:
        // return WebGLBrowserCheck.IsMobileBrowser();
        return Application.isMobilePlatform;
#elif UNITY_ANDROID || UNITY_IOS
        return true;
#else
        // В редакторе только если включён forceInEditor
        return Application.isEditor && forceInEditor;
#endif
    }

    void ReplaceShaders()
    {
        Renderer[] renderers;

        if (affectWholeScene)
            renderers = FindObjectsOfType<Renderer>(true);
        else
            renderers = GetComponentsInChildren<Renderer>(true);

        int replacedCount = 0;

        foreach (var rend in renderers)
        {
            if (!rend) continue;

            var mats = rend.sharedMaterials;
            if (mats == null || mats.Length == 0) continue;

            for (int i = 0; i < mats.Length; i++)
            {
                var mat = mats[i];
                if (!mat || mat.shader == null) continue;

                // Проверяем, попадает ли шейдер в список маппингов
                ShaderMapping mapping = FindMappingFor(mat.shader);
                if (mapping == null || mapping.mobileShader == null)
                    continue;

                // уже заменён?
                if (mat.shader == mapping.mobileShader)
                    continue;

                if (logChanges)
                {
                    Debug.Log($"[MobileShaderReplacer] {rend.name} / {mat.name}: " +
                              $"{mat.shader.name} → {mapping.mobileShader.name}", rend);
                }

                mat.shader = mapping.mobileShader;
                replacedCount++;
            }
        }

        Debug.Log($"[MobileShaderReplacer] Заменены шейдеры у {replacedCount} материалов.");
    }

    ShaderMapping FindMappingFor(Shader src)
    {
        if (src == null || mappings == null) return null;

        foreach (var m in mappings)
        {
            if (m != null && m.sourceShader == src)
                return m;
        }
        return null;
    }
}


2.41 Текст программы «MobileVerticalThruster.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using UnityEngine.EventSystems;

public class MobileVerticalThruster : MonoBehaviour, IPointerDownHandler, IDragHandler, IPointerUpHandler
{
    [Header("UI")]
    public RectTransform handle;

    [Header("���������")]
    public float maxDistance = 80f;   // ������� �������� ����� ����� ������� �����/����
    public float deadZone = 0.15f; // ������ ���� �� ������

    float rawValue;       // -1..1 �� ����� deadZone
    Vector2 startPos;

    // ��, ��� ����� ������ �������:
    // > 0 � �����, < 0 � ����, 0 � ��������
    public float Value
    {
        get
        {
            if (Mathf.Abs(rawValue) < deadZone)
                return 0f;
            return rawValue;
        }
    }

    void Awake()
    {
        if (handle == null)
            handle = transform.GetChild(0) as RectTransform;

        startPos = handle.anchoredPosition;
    }

    public void OnPointerDown(PointerEventData eventData)
    {
        OnDrag(eventData);
    }

    public void OnDrag(PointerEventData eventData)
    {
        RectTransform rt = (RectTransform)transform;

        Vector2 localPoint;
        if (!RectTransformUtility.ScreenPointToLocalPointInRectangle(
                rt, eventData.position, eventData.pressEventCamera, out localPoint))
            return;

        // ��� ���������� ������ Y
        float y = Mathf.Clamp(localPoint.y, -maxDistance, maxDistance);

        handle.anchoredPosition = new Vector2(startPos.x, startPos.y + y);
        rawValue = y / maxDistance; // -1..1
    }

    public void OnPointerUp(PointerEventData eventData)
    {
        // �������� �� ������: ��� ���������� ����� ������ ������������ � 0
        rawValue = 0f;
        handle.anchoredPosition = startPos;
    }
}


2.42 Текст программы «PauseMenuController.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

public class PauseMenuController : MonoBehaviour
{
    [Header("Desktop UI")]
    public GameObject desktopPauseMenuPanel;     // System/PauseSystem/DesktopRoot/PauseMenuPanel
    public GameObject desktopSettingsPanel;      // System/PauseSystem/DesktopRoot/SettingsPanel
    public Button desktopResumeButton;           // ResumeButton
    public Button desktopMainMenuButton;         // MainMenuButton
    public Button desktopQuitButton;             // QuitButton
    public Button desktopSettingsButton;         // SettingsButton (������ PauseMenuPanel)

    [Header("Mobile UI")]
    public GameObject mobilePauseMenuPanel;      // System/PauseSystem/MobileRoot/PauseMenuPanel
    public GameObject mobileSettingsPanel;       // System/PauseSystem/MobileRoot/SettingsPanel
    public Button mobileResumeButton;
    public Button mobileMainMenuButton;
    public Button mobileQuitButton;              // ����� �� ���������
    public Button mobileSettingsButton;

    [Header("Common")]
    [Tooltip("��� ����� �������� ����.")]
    public string mainMenuSceneName = "MainMenu";

    [Tooltip("� ��������� ������������ ��������� UI (��� �������).")]
    public bool forceMobileUiInEditor = false;

    [Header("Player")]
    [Tooltip("������ �� ���������� ��������� (Player). ���� �� ������� � ������� �� ���� Player.")]
    public SubmarineController submarineController;

    // --- ���������� ������ �� �������� ��� UI ---
    GameObject pauseMenuPanel;
    GameObject settingsPanel;
    Button resumeButton;
    Button mainMenuButton;
    Button quitButton;
    Button settingsButton;

    bool isPaused;
    bool isMobileLike;

    void Awake()
    {
        // 1) ����������, ����� UI ������ ��������������
        bool isMobileRuntime = false;

#if UNITY_WEBGL && !UNITY_EDITOR
        // WebGL: ���������� JS-������, ��������� �� �������
        isMobileRuntime = WebGLBrowserCheck.IsMobileBrowser();
#elif UNITY_ANDROID || UNITY_IOS
        // �������� ��������� ���������
        isMobileRuntime = true;
#else
        // ��������� � �������
        isMobileRuntime = false;
#endif

        isMobileLike = isMobileRuntime || (Application.isEditor && forceMobileUiInEditor);

        Debug.Log($"[PauseMenu] platform={Application.platform}, " +
                  $"isMobileRuntime={isMobileRuntime}, " +
                  $"forceMobileUiInEditor={forceMobileUiInEditor}, " +
                  $"isMobileLike={isMobileLike}");

        // 2) ����� ��� ������ �� ������ (� �������, � ������)
        if (desktopPauseMenuPanel) desktopPauseMenuPanel.SetActive(false);
        if (desktopSettingsPanel) desktopSettingsPanel.SetActive(false);
        if (mobilePauseMenuPanel) mobilePauseMenuPanel.SetActive(false);
        if (mobileSettingsPanel) mobileSettingsPanel.SetActive(false);

        // 3) �������� �������� ����� UI
        if (isMobileLike && mobilePauseMenuPanel != null)
        {
            pauseMenuPanel = mobilePauseMenuPanel;
            settingsPanel = mobileSettingsPanel;
            resumeButton = mobileResumeButton;
            mainMenuButton = mobileMainMenuButton;
            quitButton = mobileQuitButton;
            settingsButton = mobileSettingsButton;
        }
        else
        {
            pauseMenuPanel = desktopPauseMenuPanel;
            settingsPanel = desktopSettingsPanel;
            resumeButton = desktopResumeButton;
            mainMenuButton = desktopMainMenuButton;
            quitButton = desktopQuitButton;
            settingsButton = desktopSettingsButton;
        }

        if (pauseMenuPanel) pauseMenuPanel.SetActive(false);
        if (settingsPanel) settingsPanel.SetActive(false);

        WireButtons();
        CacheSubmarine();
    }

    void WireButtons()
    {
        if (resumeButton)
        {
            resumeButton.onClick.RemoveAllListeners();
            resumeButton.onClick.AddListener(OnResume);
        }

        if (mainMenuButton)
        {
            mainMenuButton.onClick.RemoveAllListeners();
            mainMenuButton.onClick.AddListener(OnMainMenu);
        }

        if (quitButton)
        {
            quitButton.onClick.RemoveAllListeners();

            // ������ ������ ����� ����� ������ � Standalone ������ (��)
#if UNITY_STANDALONE && !UNITY_EDITOR
            quitButton.gameObject.SetActive(true);
            quitButton.onClick.AddListener(OnQuit);
#else
            // �� Android / iOS / WebGL / � ��������� � ������
            quitButton.gameObject.SetActive(false);
#endif
        }

        if (settingsButton)
        {
            settingsButton.onClick.RemoveAllListeners();
            settingsButton.onClick.AddListener(OpenSettings);
        }
    }


    void CacheSubmarine()
    {
        if (!submarineController)
        {
            var player = GameObject.FindGameObjectWithTag("Player");
            if (player) submarineController = player.GetComponent<SubmarineController>();
        }
    }

    void Update()
    {
        // ESC �� �� = Back �� Android (�� �������� WebGL ��� ����� �� ���������, �� �� ������)
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Debug.Log("[PauseMenu] Escape pressed");

            if (!isPaused)
            {
                OnPause();
            }
            else
            {
                // ���� ������� ������ �������� � ��������� �, ������� � �����
                if (settingsPanel && settingsPanel.activeSelf)
                    CloseSettings();
                else
                    OnResume();
            }
        }
    }

    /// <summary>
    /// ������� �� ������ Pause (� �� ��, � �� �������).
    /// </summary>
    public void TogglePause()
    {
        Debug.Log("[PauseMenu] TogglePause()");
        if (isPaused) OnResume();
        else OnPause();
    }

    public void OnPause()
    {
        Debug.Log("[PauseMenu] OnPause()");
        if (isPaused) return;
        isPaused = true;

        // ��� ����� � ����� ��������� ������ ������
        if (settingsPanel) settingsPanel.SetActive(false);
        if (pauseMenuPanel) pauseMenuPanel.SetActive(true);

        Time.timeScale = 0f;
        ToggleSubmarineControl(false);

#if UNITY_STANDALONE || UNITY_EDITOR
        Cursor.lockState = CursorLockMode.None;
        Cursor.visible = true;
#endif
    }


    public void OnResume()
    {
        Debug.Log("[PauseMenu] OnResume()");
        if (!isPaused) return;
        isPaused = false;

        if (pauseMenuPanel) pauseMenuPanel.SetActive(false);
        if (settingsPanel) settingsPanel.SetActive(false);

        Time.timeScale = 1f;
        ToggleSubmarineControl(true);

#if UNITY_STANDALONE || UNITY_EDITOR
        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;
#endif
    }

    // --- ��������� ---

    public void OpenSettings()
    {
        Debug.Log("[PauseMenu] OpenSettings()");
        if (!isPaused) return; // ��������� �������� ������ �� ����� �����

        if (pauseMenuPanel) pauseMenuPanel.SetActive(false);
        if (settingsPanel)
        {
            settingsPanel.SetActive(true);
            settingsPanel.transform.SetAsLastSibling(); // ������ � Canvas
        }
    }
    public void CloseSettings()
    {
        Debug.Log("[PauseMenu] CloseSettings()");
        if (settingsPanel) settingsPanel.SetActive(false);
        if (pauseMenuPanel) pauseMenuPanel.SetActive(true);
    }

    // --- �������� / ����� ---

    public void OnMainMenu()
    {
        Time.timeScale = 1f;
        SceneManager.LoadScene(mainMenuSceneName);
    }

    public void OnQuit()
    {
        Application.Quit();
        Debug.Log("[PauseMenu] Quit requested");
    }

    void ToggleSubmarineControl(bool enabled)
    {
        CacheSubmarine();
        if (submarineController)
            submarineController.enabled = enabled;
    }
}


2.43 Текст программы «PauseMenuUI.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using UnityEngine.SceneManagement;

public class PauseMenuUI : MonoBehaviour
{
    public void BackToMainMenu()
    {
        SceneManager.LoadScene("MainMenu");
    }
}


2.44 Текст программы «PlatformDetector.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public static class PlatformDetector
{
    public static bool IsMobileLike()
    {
#if UNITY_ANDROID || UNITY_IOS
        return true;
#elif UNITY_WEBGL && !UNITY_EDITOR
        // настоящая проверка: мобильный ли браузер
        return WebGLBrowserCheck.IsMobileBrowser();
#else
        return false;
#endif
    }

    // Вспомогательный метод для логов (можно удалить позже)
    public static bool IsMobileLikeWithLog(string who)
    {
        bool result = IsMobileLike();
        Debug.Log($"[PlatformDetector] {who}: " +
                  $"platform={Application.platform}, " +
                  $"screen={Screen.width}x{Screen.height}, " +
                  $"isMobileLike={result}");
        return result;
    }
}


2.45 Текст программы «PlatformLayoutSwitcher.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public class PlatformRootSwitcher : MonoBehaviour
{
    [SerializeField] private GameObject desktopRoot;
    [SerializeField] private GameObject mobileRoot;

    void Awake()
    {
        bool isMobileRuntime = false;

#if UNITY_WEBGL && !UNITY_EDITOR
        // WebGL: �������, ��������� �� �������
        isMobileRuntime = WebGLBrowserCheck.IsMobileBrowser();
#elif UNITY_ANDROID || UNITY_IOS
        // �������� �������
        isMobileRuntime = true;
#else
        // ��������� � �������
        isMobileRuntime = false;
#endif

        if (desktopRoot) desktopRoot.SetActive(!isMobileRuntime);
        if (mobileRoot) mobileRoot.SetActive(isMobileRuntime);

        Debug.Log($"[PlatformRootSwitcher] platform={Application.platform}, " +
                  $"isMobileRuntime={isMobileRuntime}, " +
                  $"desktopActive={desktopRoot?.activeInHierarchy}, " +
                  $"mobileActive={mobileRoot?.activeInHierarchy}");
    }
}


2.46 Текст программы «PropellerBubbles.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

[RequireComponent(typeof(ParticleSystem))]
public class PropellerBubbles : MonoBehaviour
{
    [Range(0f, 1f)]
    public float throttle; // �������� ������ �������� (0..1)

    public float minRate = 0f;    // ����������� ����� ���������
    public float maxRate = 60f;   // ������������ ����� ��������� ��� ������ ����

    ParticleSystem ps;
    ParticleSystem.EmissionModule emission;

    void Awake()
    {
        ps = GetComponent<ParticleSystem>();
        emission = ps.emission;
    }

    void Update()
    {
        float rate = Mathf.Lerp(minRate, maxRate, throttle);
        emission.rateOverTime = rate;
    }

    public void SetThrottle(float t)
    {
        throttle = Mathf.Clamp01(t);
    }
}


2.47 Текст программы «PropellerRotate.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public class PropellerRotate : MonoBehaviour
{
    [Header("Speed control")]
    public float maxSpinSpeed = 1200f;
    public float accel = 5f;
    public float decel = 3f;

    [Range(0f, 1f)]
    public float throttleInput = 0f;

    [Header("Axis")]
    public Vector3 localAxis = Vector3.forward;

    [Header("Bubble emitter (prefab)")]
    [Tooltip("������ ParticleSystem, ������� ����� ������ ��� ������ ����������.")]
    public ParticleSystem bubbleEmitterPrefab;

    [Tooltip("������� ��� ��������.")]
    public float minEmissionRate = 0f;
    [Tooltip("������� ��� ������ ����.")]
    public float maxEmissionRate = 200f;

    // �������� ������� � �����
    private ParticleSystem bubbleEmitterInstance;

    private float currentSpinSpeed = 0f;

    private void Start()
    {
        // ���� ���� ������ � ������������ ��� ��� �����������
        if (bubbleEmitterPrefab != null)
        {
            bubbleEmitterInstance = Instantiate(
                bubbleEmitterPrefab,
                transform.position,
                transform.rotation,
                transform // ������ �������� ����������
            );

            var emission = bubbleEmitterInstance.emission;
            emission.enabled = true;
            if (!bubbleEmitterInstance.isPlaying)
                bubbleEmitterInstance.Play();
        }
    }

    void Update()
    {
        float targetSpeed = throttleInput * maxSpinSpeed;

        if (currentSpinSpeed < targetSpeed)
        {
            currentSpinSpeed = Mathf.Lerp(
                currentSpinSpeed,
                targetSpeed,
                accel * Time.deltaTime
            );
        }
        else
        {
            currentSpinSpeed = Mathf.Lerp(
                currentSpinSpeed,
                targetSpeed,
                decel * Time.deltaTime
            );
        }

        transform.Rotate(localAxis, currentSpinSpeed * Time.deltaTime, Space.Self);

        UpdateBubbles();
    }

    private void UpdateBubbles()
    {
        if (bubbleEmitterInstance == null) return;

        float t = 0f;
        if (maxSpinSpeed > 0f)
            t = Mathf.Clamp01(Mathf.Abs(currentSpinSpeed) / maxSpinSpeed);

        var emission = bubbleEmitterInstance.emission;
        emission.enabled = t > 0.01f;
        emission.rateOverTime = Mathf.Lerp(minEmissionRate, maxEmissionRate, t);

        if (emission.enabled)
        {
            if (!bubbleEmitterInstance.isPlaying)
                bubbleEmitterInstance.Play();
        }
        else
        {
            if (bubbleEmitterInstance.isPlaying)
                bubbleEmitterInstance.Stop(true, ParticleSystemStopBehavior.StopEmitting);
        }
    }

    public void SetThrottle(float t)
    {
        throttleInput = Mathf.Clamp01(t);
    }
}


2.48 Текст программы «ScoreManager.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;   // ← вот это нужно для MonoBehaviour, Header и т.п.
using TMPro;        // ← а это для TextMeshProUGUI

public class ScoreManager : MonoBehaviour
{
    [Header("Score")]
    public int score = 0;

    [Header("UI")]
    [Tooltip("Текст очков на ПК UI (Score12).")]
    public TextMeshProUGUI desktopScoreText;

    [Tooltip("Текст очков на мобильном UI (Score11).")]
    public TextMeshProUGUI mobileScoreText;

    void Start()
    {
        RefreshUI();
    }

    public void AddScore(int amount)
    {
        score += amount;
        if (score < 0) score = 0;
        RefreshUI();
    }

    void RefreshUI()
    {
        string text = "ОЧКИ: " + score;

        if (desktopScoreText != null)
            desktopScoreText.text = text;

        if (mobileScoreText != null)
            mobileScoreText.text = text;
    }
}


2.49 Текст программы «SliderHint.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using TMPro;
using UnityEngine.EventSystems;

/// <summary>
/// �������� �� ������� (��� �� ��� ������/�������).
/// ��� ��������� / ������ ���������� ����� � ����� label-�.
/// </summary>
public class SliderHint : MonoBehaviour,
    IPointerEnterHandler, IPointerExitHandler,
    ISelectHandler, IDeselectHandler
{
    [Header("����� ��������� ��� ����� ��������")]
    [TextArea(2, 4)]
    public string hintText;

    [Header("���� �������� ���������")]
    public TextMeshProUGUI targetLabel;

    void Show()
    {
        if (targetLabel != null)
            targetLabel.text = hintText;
    }

    void Clear()
    {
        if (targetLabel != null)
            targetLabel.text = "";
    }

    // ���� ������ �� �������
    public void OnPointerEnter(PointerEventData eventData) => Show();

    // ���� ����
    public void OnPointerExit(PointerEventData eventData) => Clear();

    // ����� � ���������� / ��������
    public void OnSelect(BaseEventData eventData) => Show();
    public void OnDeselect(BaseEventData eventData) => Clear();
}


2.50 Текст программы «SmoothFollow.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public class SmoothFollow : MonoBehaviour
{
    public Transform target;                // ���������
    public Vector3 offset = new Vector3(0, 2, -6);
    public float followSmooth = 3f;         // ��� ����, ��� ����� ����� ����������

    private Vector3 velocity;

    void LateUpdate()
    {
        if (!target) return;

        // �������� ������� �� ����������
        Vector3 desiredPos = target.position
                           + target.transform.TransformDirection(offset);

        // ������ ��������
        transform.position = Vector3.SmoothDamp(
            transform.position,
            desiredPos,
            ref velocity,
            1f / followSmooth
        );

        // ������ �������������� ����� � �����/�����������
        Quaternion desiredRot = Quaternion.LookRotation(
            target.position - transform.position,
            Vector3.up
        );
        transform.rotation = Quaternion.Slerp(
            transform.rotation,
            desiredRot,
            Time.deltaTime * followSmooth * 0.5f
        );
    }
}


2.51 Текст программы «SonarRadarUI.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class SonarRadarUI : MonoBehaviour
{
    public static SonarRadarUI I { get; private set; }

    [Header("UI refs")]
    [Tooltip("Круглый фон радара (RectTransform).")]
    public RectTransform radarRect;

    [Tooltip("Префаб точки на радаре (Image/Graphic).")]
    public RectTransform dotPrefab;

    [Header("Настройки")]
    [Tooltip("Максимальная дистанция сканирования (мировые метры).")]
    public float worldRadius = 50f;

    List<GameObject> activeDots = new List<GameObject>();
    Coroutine hideRoutine;

    void Awake()
    {
        I = this;
        if (radarRect == null)
            radarRect = GetComponent<RectTransform>();

        ClearDots();

        // 🔹 Радар скрыт по умолчанию
        if (radarRect != null)
            radarRect.gameObject.SetActive(false);
    }

    /// <summary>
    /// Показать пинг: точки по направлениям на рыб относительно сабмарины.
    /// </summary>
    public void ShowPing(Transform submarine, List<FishSonarHighlight> fishes, float duration)
    {
        if (submarine == null || radarRect == null || dotPrefab == null)
            return;

        ClearDots();
        radarRect.gameObject.SetActive(true);

        float radiusPx = Mathf.Min(radarRect.rect.width, radarRect.rect.height) * 0.5f;

        foreach (var f in fishes)
        {
            if (f == null) continue;

            // направление и расстояние в мире
            Vector3 toFish = f.transform.position - submarine.position;
            toFish.y = 0f;

            float dist = toFish.magnitude;
            if (dist < 0.1f || dist > worldRadius) continue;

            Vector3 dirWorld = toFish.normalized;

            // переводим в локальные координаты субмарины,
            // чтобы "вверх" на радаре = нос лодки
            Vector3 dirLocal = Quaternion.Inverse(submarine.rotation) * dirWorld;
            Vector2 dir2 = new Vector2(dirLocal.x, dirLocal.z);
            if (dir2.sqrMagnitude < 0.0001f) continue;
            dir2.Normalize();

            // 0 в центре, worldRadius на краю круга
            float dist01 = Mathf.Clamp01(dist / worldRadius);
            float dotRadius = radiusPx * dist01;

            RectTransform dot = Instantiate(dotPrefab, radarRect);
            dot.anchoredPosition = dir2 * dotRadius;

            var graphic = dot.GetComponent<Graphic>();
            if (graphic != null)
                graphic.color = f.GetBaseColor();   // цвет по типу рыбы

            activeDots.Add(dot.gameObject);
        }

        if (hideRoutine != null) StopCoroutine(hideRoutine);
        hideRoutine = StartCoroutine(HideDotsAfter(duration));
    }


    IEnumerator HideDotsAfter(float duration)
    {
        float t = 0f;
        while (t < duration)
        {
            t += Time.unscaledDeltaTime;
            yield return null;
        }

        ClearDots();

        // 🔹 После окончания пинга полностью скрываем радар
        if (radarRect != null)
            radarRect.gameObject.SetActive(false);

        hideRoutine = null;
    }

    void ClearDots()
    {
        if (activeDots == null) return;
        foreach (var go in activeDots)
        {
            if (go != null) Destroy(go);
        }
        activeDots.Clear();
    }
}


2.52 Текст программы «SoundPref.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public static class SoundPref
{
    private const string KEY = "SoundEnabled";

    // �� ��������� ���� ��� (1)
    public static bool Get()
    {
        return PlayerPrefs.GetInt(KEY, 1) == 1;
    }

    public static void Set(bool value)
    {
        PlayerPrefs.SetInt(KEY, value ? 1 : 0);
        PlayerPrefs.Save();
    }
}


2.53 Текст программы «SoundSettings.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public static class SoundSettings
{
    const string KEY_MASTER = "Sound_Master";
    const string KEY_MUSIC = "Sound_Music";
    const string KEY_ENGINE = "Sound_Engine";
    const string KEY_SFX = "Sound_SFX";
    const string KEY_SONAR = "Sound_Sonar";

    static float GetClamped(string key, float def)
    {
        return Mathf.Clamp01(PlayerPrefs.GetFloat(key, def));
    }

    static void SetClamped(string key, float value)
    {
        PlayerPrefs.SetFloat(key, Mathf.Clamp01(value));
        PlayerPrefs.Save();
    }

    public static float GetMaster() => GetClamped(KEY_MASTER, 1f);
    public static float GetMusic() => GetClamped(KEY_MUSIC, 1f);
    public static float GetEngine() => GetClamped(KEY_ENGINE, 1f);
    public static float GetSfx() => GetClamped(KEY_SFX, 1f);
    public static float GetSonar() => GetClamped(KEY_SONAR, 1f);

    public static void SetMaster(float v) => SetClamped(KEY_MASTER, v);
    public static void SetMusic(float v) => SetClamped(KEY_MUSIC, v);
    public static void SetEngine(float v) => SetClamped(KEY_ENGINE, v);
    public static void SetSfx(float v) => SetClamped(KEY_SFX, v);
    public static void SetSonar(float v) => SetClamped(KEY_SONAR, v);
}


2.54 Текст программы «SoundToggleWithSave.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(Toggle))]
public class SoundToggleWithSave : MonoBehaviour
{
    [Header("UI")]
    public Toggle toggle;      // Toggle "����"
    public Button saveButton;  // "���������"
    public Button cancelButton; // "��������" (�����������)

    bool initialValue;

    void Awake()
    {
        toggle ??= GetComponent<Toggle>();

        // ��������� ���������� ��������
        initialValue = SoundPref.Get();
        toggle.isOn = initialValue;

        if (saveButton)
        {
            saveButton.interactable = false;
            saveButton.onClick.AddListener(Save);
        }

        if (cancelButton)
            cancelButton.onClick.AddListener(Cancel);

        toggle.onValueChanged.AddListener(_ => OnChanged());
    }

    void OnDestroy()
    {
        toggle.onValueChanged.RemoveAllListeners();
        if (saveButton) saveButton.onClick.RemoveAllListeners();
        if (cancelButton) cancelButton.onClick.RemoveAllListeners();
    }

    void OnChanged()
    {
        if (saveButton)
            saveButton.interactable = (toggle.isOn != initialValue);
    }

    public void Save()
    {
        SoundPref.Set(toggle.isOn);
        initialValue = toggle.isOn;
        if (saveButton) saveButton.interactable = false;

        // ����� �������� �� ���� ������
        ApplyToAllAudio();
    }

    public void Cancel()
    {
        toggle.isOn = initialValue;
        if (saveButton) saveButton.interactable = false;
    }

    void ApplyToAllAudio()
    {
        bool enabled = SoundPref.Get();
        var all = FindObjectsOfType<SubmarineAudio>();
        foreach (var sa in all)
            sa.ApplySoundEnabled(enabled);
    }

}


2.55 Текст программы «SubmarineAudio.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;

public class SubmarineAudio : MonoBehaviour
{
    [Header("����������� ����� (PlayOneShot)")]
    [Tooltip("�������� SFX. AudioSource ��� Loop, ��� PlayOnAwake.")]
    public AudioSource sfxSource;

    [Header("���������� ���� ������")]
    [Tooltip("��������� AudioSource ��� ������� ������ (�� ��������/��������� ����� ���).")]
    public AudioSource sonarSource;

    [Header("���� ���������")]
    [Tooltip("��������� AudioSource ��� ����� ��������� (� Loop = true).")]
    public AudioSource engineSource;

    [Tooltip("����������� ���� ��������� ��� �������� ����.")]
    public float engineMinPitch = 0.8f;
    [Tooltip("������������ ���� ��������� ��� ������ ��������.")]
    public float engineMaxPitch = 1.4f;

    [Tooltip("����������� ��������� ��������� (�� ��������� �� ��������� ������������).")]
    public float engineMinVolume = 0.2f;
    [Tooltip("������������ ��������� ��������� (�� ��������� �� ��������� ������������).")]
    public float engineMaxVolume = 1.0f;

    [Header("������� ������")]
    [Tooltip("��������� AudioSource ��� ������� ������.")]
    public AudioSource musicSource;
    [Tooltip("�������� ����������� ���� (����).")]
    public AudioClip mainMusicLoop;
    [Tooltip("������� ��������� ������ (�� ��������� �� ��������� ������������).")]
    [Range(0f, 1f)]
    public float baseMusicVolume = 0.5f;

    [Header("������� ��������� ������� (���������)")]
    [Range(0f, 1f)] public float baseSfxVolume = 1.0f;
    [Range(0f, 1f)] public float baseSonarVolume = 0.5f;

    [Header("�����")]
    [Tooltip("���� ������/������������.")]
    public AudioClip sonarPing;

    [Tooltip("������ ���� ������� (������������ � ����/������).")]
    public AudioClip hullHit;

    [Tooltip("��������� ���� ��� ������ �� ����� �������/������.")]
    public AudioClip boundaryHit;

    [Tooltip("���������� ����: ������ ������� ���� / ������� ����.")]
    public AudioClip scoreGain;

    [Tooltip("���� ������ ����: ������ ������� / �������� / ��������.")]
    public AudioClip hostileFishClip;

    [Header("��������� ������")]
    [Tooltip("������� ������ �������� ���� ������ ����� �������.")]
    public float sonarDuration = 2f;

    [Tooltip("������� ��������� ����� ������ (�� ��������� �� ��������� ������������).")]
    public float sonarVolume = 0.5f;

    private Coroutine sonarRoutine;

    void Start()
    {
        // --- ��������� ---
        if (engineSource != null)
        {
            engineSource.loop = true;
            if (!engineSource.isPlaying)
            {
                engineSource.Play();
            }

            // ��������� �������� ���������/�����. ��������� ����� ����� ���������������� �����������.
            engineSource.pitch = engineMinPitch;
            engineSource.volume = engineMinVolume * GetEngineFactor();
        }

        // --- ������ ---
        if (musicSource != null && mainMusicLoop != null)
        {
            musicSource.clip = mainMusicLoop;
            musicSource.loop = true;
            musicSource.volume = baseMusicVolume * GetMusicFactor();
            if (!musicSource.isPlaying)
            {
                musicSource.Play();
            }
        }

        // �� ������ �������������� �� � �������� �����������
        ApplyVolumeSettings();
    }

    // === ��������������� ������� ===

    float GetMasterFactor() => SoundSettings.GetMaster();

    float GetMusicFactor() => SoundSettings.GetMusic() * GetMasterFactor();
    float GetEngineFactor() => SoundSettings.GetEngine() * GetMasterFactor();
    float GetSfxFactor() => SoundSettings.GetSfx() * GetMasterFactor();
    float GetSonarFactor() => SoundSettings.GetSonar() * GetMasterFactor();

    // ����� �������� �� UI �������� ����� ��������� ���������
    public void ApplyVolumeSettings()
    {
        // ������
        if (musicSource != null)
        {
            musicSource.volume = baseMusicVolume * GetMusicFactor();
        }

        // ���� ����� ��� ������ � ������� ���������
        if (sonarSource != null && sonarSource.isPlaying)
        {
            sonarSource.volume = sonarVolume * baseSonarVolume * GetSonarFactor();
        }

        // ���������: ��������� ����� ����������� � SetEngineLoad,
        // �� ����� ������ �������� ����-���������
        if (engineSource != null)
        {
            // ����� ������ ��������� "��������� ����", � ������ ��� �������� SetEngineLoad �� ���������
            engineSource.volume = engineMinVolume * GetEngineFactor();
        }

        // SFX ����� ��������� ������ ��� PlayOneShot
    }

    // === ��������� ������ ��� ������ �������� ===

    // ���������� ����� ��������� �� ����������� ��������
    // ���������� �� SubmarineController.UpdatePropellersAndAudio()
    public void SetEngineLoad(float throttle, float speed)
    {
        if (engineSource == null) return;

        // ����������� �������� ������� �� 0..1 (�������� maxSpeed ��� ���� ����)
        float maxSpeedForSound = 10f;
        float speedNorm = Mathf.Clamp01(speed / maxSpeedForSound);

        // ����������� ��� � �������� � ����� "load" 0..1
        float load = Mathf.Clamp01(0.6f * throttle + 0.4f * speedNorm);

        float baseVol = Mathf.Lerp(engineMinVolume, engineMaxVolume, load);
        engineSource.pitch = Mathf.Lerp(engineMinPitch, engineMaxPitch, load);
        engineSource.volume = baseVol * GetEngineFactor();
    }

    // �������� ����� �� ������
    public void TriggerSonar()
    {
        if (sonarRoutine == null)
        {
            sonarRoutine = StartCoroutine(SonarRoutine());
        }
    }

    IEnumerator SonarRoutine()
    {
        if (sonarSource && sonarPing)
        {
            sonarSource.clip = sonarPing;
            sonarSource.volume = sonarVolume * baseSonarVolume * GetSonarFactor();
            sonarSource.loop = true;
            sonarSource.Play();
        }

        yield return new WaitForSeconds(sonarDuration);

        if (sonarSource)
        {
            sonarSource.Stop();
            sonarSource.loop = false;
            sonarSource.clip = null;
        }

        sonarRoutine = null;
    }

    // ������������ � ������ �������� � ����� �������
    public void PlayHullHit()
    {
        if (sfxSource && hullHit)
        {
            // ��������� ��������� SFX-������
            float v = 1f * baseSfxVolume * GetSfxFactor();
            sfxSource.PlayOneShot(hullHit, v);
        }
    }

    // ������� �� ������� ������� � ��������� ������
    public void PlayBoundaryHit()
    {
        if (sfxSource && boundaryHit)
        {
            float v = 0.8f * baseSfxVolume * GetSfxFactor();
            sfxSource.PlayOneShot(boundaryHit, v);
        }
    }

    // ������� ���� / ������� / ���� ����
    public void PlayScoreGain()
    {
        if (sfxSource && scoreGain)
        {
            float v = 0.7f * baseSfxVolume * GetSfxFactor();
            sfxSource.PlayOneShot(scoreGain, v);
        }
    }

    // ������ ���� / ����� / �� / ���������
    public void PlayHostileFish()
    {
        float v = 1f * baseSfxVolume * GetSfxFactor();

        // 1. �������� ���� ������ ����
        if (sfxSource && hostileFishClip)
        {
            sfxSource.PlayOneShot(hostileFishClip, v);
            return;
        }

        // 2. fallback, ���� ����� ������ ��������� hostileFishClip
        if (sfxSource && hullHit)
        {
            sfxSource.PlayOneShot(hullHit, v);
        }
    }
    // ���������� ���������/���������� ����� ��� ���� ������� ����� SubmarineAudio
    public void ApplySoundEnabled(bool enabled)
    {
        bool mute = !enabled;

        // ������� ������
        if (musicSource != null)
            musicSource.mute = mute;

        // ���������
        if (engineSource != null)
            engineSource.mute = mute;

        // ������� SFX
        if (sfxSource != null)
            sfxSource.mute = mute;

        // �����
        if (sonarSource != null)
        {
            sonarSource.mute = mute;

            // ���� �������� ���� � ����� ������ ������ � ����� ���������
            if (mute && sonarSource.isPlaying)
            {
                sonarSource.Stop();
                sonarSource.loop = false;
                sonarSource.clip = null;
            }
        }
    }
}


2.56 Текст программы «SubmarineCollisionDamage.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class SubmarineCollisionDamage : MonoBehaviour
{
    [Header("Урон при столкновении")]
    public float minImpactSpeed = 2f;   // скорость удара, порог
    public float damagePerHit = 10f;    // урон за удар

    [Header("Слои, которые наносят урон")]
    public LayerMask damagingLayers = ~0;
    // По умолчанию: все слои. В инспекторе выбери только стены/пол итд.

    private SubmarineHealth health;
    private SubmarineAudio audioRef;

    void Awake()
    {
        health = GetComponent<SubmarineHealth>();
        if (health == null)
        {
            Debug.LogWarning("[SubmarineCollisionDamage] Нет SubmarineHealth!");
        }

        audioRef = GetComponent<SubmarineAudio>();
        if (audioRef == null)
        {
            Debug.LogWarning("[SubmarineCollisionDamage] Нет SubmarineAudio!");
        }
    }

    void OnCollisionEnter(Collision collision)
    {
        if (health == null) return;

        // --- ПРОВЕРКА СЛОЯ ---
        int otherLayer = collision.gameObject.layer;
        if ((damagingLayers.value & (1 << otherLayer)) == 0)
        {
            // слой не входит в маску damagingLayers — игнорируем столкновение для урона
            return;
        }

        float impactSpeed = collision.relativeVelocity.magnitude;

        if (impactSpeed >= minImpactSpeed)
        {
            health.ApplyDamage(damagePerHit);

#if UNITY_EDITOR
            Debug.Log("Удар о " + collision.collider.name + " : -" + damagePerHit + " HP");
#endif

            if (audioRef != null)
            {
                audioRef.PlayHullHit();
            }
        }
    }

    // Если хочешь урон при "трении", можешь добавить это:
    /*
    void OnCollisionStay(Collision collision)
    {
        if (health == null) return;

        int otherLayer = collision.gameObject.layer;
        if ((damagingLayers.value & (1 << otherLayer)) == 0)
            return;

        float impactSpeed = collision.relativeVelocity.magnitude;
        if (impactSpeed >= minImpactSpeed)
        {
            health.ApplyDamage(damagePerHit * Time.deltaTime);
        }
    }
    */
}


2.57 Текст программы «SubmarineController.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using System.Collections.Generic;
using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class SubmarineController : MonoBehaviour
{
    [Header("References")]
    public SubmarineAudio audioRef;
    public PropellerRotate[] propellers;

    private Rigidbody rb;

    [Header("Movement")]
    public float forwardThrust = 15f;
    public float verticalThrust = 10f;

    [Header("Rotation Rates (deg/sec)")]
    public float yawRate = 60f;     // скорость поворота влево/вправо
    public float pitchRate = 50f;   // скорость наклона вверх/вниз

    [Tooltip("Ограничение угла тангажа (вверх/вниз).")]
    public float maxPitchAngle = 60f;

    [Header("Smoothing")]
    [Tooltip("Сглаживание линейной скорости.")]
    public float movementSmoothing = 0.1f;

    [Tooltip("Сглаживание поворота (чем больше, тем быстрее догоняет цель).")]
    public float rotationLerpSpeed = 8f;

    private Vector3 smoothVelocity;

    [Header("Speed Limits")]
    public float maxForwardSpeed = 15f;
    public float maxVerticalSpeed = 8f;

    [Header("Desktop Input Settings")]
    public string verticalAxis = "Vertical";       // W/S
    public string horizontalAxis = "Horizontal";   // A/D
    public KeyCode ascendKey = KeyCode.Space;
    public KeyCode descendKey = KeyCode.R;
    public KeyCode pitchUpKey = KeyCode.I;
    public KeyCode pitchDownKey = KeyCode.K;

    [Header("Mobile Input")]
    public bool forceMobileInEditor = false;
    public MobileMoveJoystick mobileMoveJoystick;
    public MobileVerticalThruster mobileVerticalThruster;

    private bool isUsingMobileInput;

    [Header("Stabilization")]
    [Tooltip("Жёстко запретить крен (самый стабильный вариант).")]
    public bool lockRollWithConstraints = false;

    [Tooltip("Если roll не заблокирован, то насколько активно возвращать крен к нулю.")]
    public float rollAutoLevelStrength = 6f;

    [Tooltip("Максимальная угловая скорость Rigidbody (защита от резких ударов).")]
    public float maxAngularVelocity = 2f;

    [Tooltip("Сопротивление воды.")]
    public float waterDrag = 0.5f;

    [Tooltip("Угловое сопротивление.")]
    public float angularDrag = 2f;

    [Header("Debug")]
    public bool showDebugInfo = true;

    [Header("Sonar Scan")]
    public float sonarWorldRadius = 50f;
    public float sonarHighlightDuration = 2f;
    public float sonarRadarDuration = 2f;
    public bool sonarOnlyUncaughtFish = true;

    // Внутренние переменные ввода
    private float moveInput;
    private float yawInput;
    private float upInput;
    private float pitchInput;

    private float throttleForward;

    // Целевые углы
    private float desiredYaw;
    private float desiredPitch;

    // Кэш списка для сонара (чтобы меньше мусора)
    private readonly List<FishSonarHighlight> sonarInRange = new List<FishSonarHighlight>(64);

    // Геттеры для туториала
    public float MoveAxis => moveInput;
    public float YawAxis => yawInput;
    public float UpAxis => upInput;
    public float PitchAxis => pitchInput;

    void Awake()
    {
        rb = GetComponent<Rigidbody>();
        if (!rb)
        {
            enabled = false;
            return;
        }

        if (!audioRef)
            audioRef = GetComponent<SubmarineAudio>();

        rb.drag = waterDrag;
        rb.angularDrag = angularDrag;
        rb.maxAngularVelocity = maxAngularVelocity;

        // --- решаем, мобильное ли управление ---
        bool isMobileRuntime = false;

#if UNITY_WEBGL && !UNITY_EDITOR
        isMobileRuntime = WebGLBrowserCheck.IsMobileBrowser();
#elif UNITY_ANDROID || UNITY_IOS
        isMobileRuntime = true;
#else
        isMobileRuntime = false;
#endif
        isUsingMobileInput = isMobileRuntime || (Application.isEditor && forceMobileInEditor);

        // Инициализируем целевые углы из текущего поворота
        Vector3 e = rb.rotation.eulerAngles;
        desiredYaw = e.y;

        desiredPitch = e.x;
        if (desiredPitch > 180f) desiredPitch -= 360f;
        desiredPitch = Mathf.Clamp(desiredPitch, -maxPitchAngle, maxPitchAngle);

        // Опционально жёстко запрещаем крен
        if (lockRollWithConstraints)
        {
            rb.constraints |= RigidbodyConstraints.FreezeRotationZ;
        }

        Debug.Log($"[SubmarineController] platform={Application.platform}, " +
                  $"isMobileRuntime={isMobileRuntime}, " +
                  $"forceMobileInEditor={forceMobileInEditor}, " +
                  $"isUsingMobileInput={isUsingMobileInput}");
    }

    void Update()
    {
        ReadInput();

        // накопление целевых углов по вводу
        desiredYaw += yawInput * yawRate * Time.deltaTime;
        desiredPitch += pitchInput * pitchRate * Time.deltaTime;
        desiredPitch = Mathf.Clamp(desiredPitch, -maxPitchAngle, maxPitchAngle);

        // sonar по E (на мобилке вызывается кнопкой)
        if (Input.GetKeyDown(KeyCode.E))
        {
            OnSonarButtonPressed();
        }
    }

    void FixedUpdate()
    {
        if (!rb) return;

        rb.drag = waterDrag;
        rb.angularDrag = angularDrag;

        ApplyMovementWithSmoothing();
        ApplyRotationStable();
        LimitLinearSpeeds();

        UpdatePropellersAndAudio();
    }

    void OnDrawGizmos()
    {
        if (!showDebugInfo) return;

        if (!rb)
            rb = GetComponent<Rigidbody>();
        if (!rb) return;

        Gizmos.color = Color.blue;
        Gizmos.DrawRay(transform.position, rb.velocity);

        Gizmos.color = Color.green;
        Gizmos.DrawRay(transform.position, transform.forward * 3f);
    }

    // ---------- Input ----------

    void ReadInput()
    {
        if (isUsingMobileInput && mobileMoveJoystick != null)
            ReadMobileInput();
        else
            ReadDesktopInput();

        throttleForward = Mathf.Clamp01(Mathf.Abs(moveInput));
    }

    void ReadDesktopInput()
    {
        moveInput = Input.GetAxis(verticalAxis);
        yawInput = Input.GetAxis(horizontalAxis);

        upInput = 0f;
        if (Input.GetKey(ascendKey)) upInput += 1f;
        if (Input.GetKey(descendKey)) upInput -= 1f;

        pitchInput = 0f;
        if (Input.GetKey(pitchUpKey)) pitchInput += 1f;
        if (Input.GetKey(pitchDownKey)) pitchInput -= 1f;
    }

    void ReadMobileInput()
    {
        if (mobileMoveJoystick != null)
        {
            moveInput = mobileMoveJoystick.Vertical;
            yawInput = mobileMoveJoystick.Horizontal;
        }
        else
        {
            moveInput = 0f;
            yawInput = 0f;
        }

        if (mobileVerticalThruster != null)
            upInput = mobileVerticalThruster.Value;
        else
            upInput = 0f;

        pitchInput = 0f; // если на мобилке нет отдельного pitch-контрола
    }

    // ---------- Movement ----------

    void ApplyMovementWithSmoothing()
    {
        Vector3 targetVelocity =
            transform.forward * (moveInput * forwardThrust) +
            transform.up * (upInput * verticalThrust);

        rb.velocity = Vector3.SmoothDamp(
            rb.velocity,
            targetVelocity,
            ref smoothVelocity,
            movementSmoothing
        );
    }

    void LimitLinearSpeeds()
    {
        Vector3 localVelocity = transform.InverseTransformDirection(rb.velocity);

        localVelocity.z = Mathf.Clamp(localVelocity.z, -maxForwardSpeed, maxForwardSpeed);
        localVelocity.y = Mathf.Clamp(localVelocity.y, -maxVerticalSpeed, maxVerticalSpeed);

        rb.velocity = transform.TransformDirection(localVelocity);
    }

    // ---------- Rotation (новая логика) ----------

    void ApplyRotationStable()
    {
        // Базовая целевая ротация без крена
        Quaternion target = Quaternion.Euler(desiredPitch, desiredYaw, 0f);

        // Если крен жёстко запрещён — просто тянемся к target
        if (lockRollWithConstraints)
        {
            Quaternion newRot = Quaternion.Slerp(
                rb.rotation,
                target,
                rotationLerpSpeed * Time.fixedDeltaTime
            );

            rb.MoveRotation(newRot);
            return;
        }

        // Если крен не запрещён — мягко возвращаем roll к 0,
        // сохраняя yaw/pitch целью
        Quaternion current = rb.rotation;

        // Сначала тянемся к target
        Quaternion intermediate = Quaternion.Slerp(
            current,
            target,
            rotationLerpSpeed * Time.fixedDeltaTime
        );

        // Потом отдельно подправим roll в сторону нуля
        Vector3 e = intermediate.eulerAngles;
        float roll = e.z;
        if (roll > 180f) roll -= 360f;

        float newRoll = Mathf.Lerp(roll, 0f, rollAutoLevelStrength * Time.fixedDeltaTime);

        Quaternion final = Quaternion.Euler(
            NormalizeAngleSigned(e.x),
            NormalizeAngleUnsigned(e.y),
            newRoll
        );

        rb.MoveRotation(final);
    }

    float NormalizeAngleSigned(float angle)
    {
        if (angle > 180f) angle -= 360f;
        return angle;
    }

    float NormalizeAngleUnsigned(float angle)
    {
        while (angle < 0f) angle += 360f;
        while (angle >= 360f) angle -= 360f;
        return angle;
    }

    // ---------- Props / Audio ----------

    void UpdatePropellersAndAudio()
    {
        if (propellers != null)
        {
            foreach (var propeller in propellers)
            {
                if (propeller != null)
                    propeller.SetThrottle(throttleForward);
            }
        }

        if (audioRef != null)
        {
            float speed = rb.velocity.magnitude;
            audioRef.SetEngineLoad(throttleForward, speed);
        }
    }

    // ---------- Sonar ----------

    public void OnSonarButtonPressed()
    {
        if (audioRef != null)
        {
            audioRef.TriggerSonar();
        }

        HighlightFishBySonar();
    }

    void HighlightFishBySonar()
    {
        var allHighlights = FindObjectsOfType<FishSonarHighlight>();

        sonarInRange.Clear();

        foreach (var h in allHighlights)
        {
            if (h == null) continue;

            float dist = Vector3.Distance(transform.position, h.transform.position);
            if (dist > sonarWorldRadius) continue;

            if (sonarOnlyUncaughtFish)
            {
                var data = h.GetComponent<FishData>();
                if (data != null && data.caught)
                    continue;
            }

            sonarInRange.Add(h);
            h.Ping(sonarHighlightDuration);
        }

        if (SonarRadarUI.I != null)
        {
            SonarRadarUI.I.ShowPing(transform, sonarInRange, sonarRadarDuration);
        }
    }
}


2.58 Текст программы «SubmarineHealth.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using UnityEngine.Events;
using System; // ��� Action

public class SubmarineHealth : MonoBehaviour
{
    // ������� "������� ����" (amountApplied, current, max)
    public event Action<float, float, float> OnDamaged;

    [Header("��������� ��������� �������")]
    public float maxHealth = 100f;
    public float currentHealth = 100f;

    [Header("��������� ����� �������")]
    public float damageCooldown = 0.5f; // ������� ����� ����������� ����� �� ����
    private float lastHitTime = -999f;

    [Header("�������")]
    public UnityEvent onDeath; // ����� ��������� ����� ��������� (����������, ���������, � �.�.)

    void Awake()
    {
        currentHealth = maxHealth;
    }

    // ��������, ����� ������ ������� ����� ������� ����
    public void ApplyDamage(float dmg)
    {
        if (dmg <= 0f) return;

        // ������ �� ������� ������ ������
        if (Time.time - lastHitTime < damageCooldown)
            return;

        lastHitTime = Time.time;

        float prev = currentHealth;
        currentHealth = Mathf.Max(0f, currentHealth - dmg);
        float applied = Mathf.Max(0f, prev - currentHealth); // ���������� ��������� ����

        // �����: ������� �������� �����, ������ ������
        OnDamaged?.Invoke(applied, currentHealth, maxHealth);

        if (currentHealth <= 0f)
        {
            Debug.Log("��������� ���������� (������ ���������).");
            onDeath?.Invoke();
        }
    }

    public void Heal(float amount)
    {
        if (amount <= 0f || currentHealth <= 0f) return;
        currentHealth = Mathf.Min(maxHealth, currentHealth + amount);
    }

    public float GetHealth01() => maxHealth > 0f ? currentHealth / maxHealth : 0f;
}


2.59 Текст программы «SubmarineHealthUI.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class SubmarineHealthUI : MonoBehaviour
{
    [Header("Targets")]
    public SubmarineHealth target;            // здоровье субмарины
    public SubmarineController subController; // управление субмариной

    [Header("Health Bar (tiled/sliced)")]
    public RectTransform healthFillRT;        // RectTransform HealthFill
    public Image healthFillImage;             // Image на HealthFill (Tiled или Sliced)
    public float maxWidth = 200f;             // ширина при фулл-хп
    public float barHeight = 24f;             // высота бара

    [Header("Low HP blink")]
    public float lowHealthThreshold = 0.2f;   // ниже этого мигаем
    public float blinkSpeed = 6f;             // скорость мигания
    private float baseAlpha = 1f;             // запоминаем изначальную альфу

    [Header("Death screen")]
    public CanvasGroup deathPanel;            // DeathPanel (CanvasGroup)
    public float deathFadeTime = 0.5f;        // скорость затемнения
    public string mainMenuSceneName = "MainMenu";

    [Header("Death audio")]
    public AudioSource deathAudioSource;
    public AudioClip deathClip;
    public float deathVolume = 1f;

    [Header("Hints")]
    public bool showFirstDamageHint = true;
    public bool showCriticalHint = true;
    [Range(0f, 1f)] public float criticalPct = 0.25f;

    bool isDead = false;
    bool deathSoundPlayed = false;
    float shownFrac = 1f;
    bool firstDamageShown = false; // для первого сообщения об уроне

    void Start()
    {
        // стартовая альфа
        if (healthFillImage != null)
            baseAlpha = healthFillImage.color.a;

        // спрятать экран смерти
        if (deathPanel != null)
        {
            deathPanel.alpha = 0f;
            deathPanel.interactable = false;
            deathPanel.blocksRaycasts = false;
            deathPanel.gameObject.SetActive(false);
        }

        // выставить бар на полный
        if (healthFillRT != null)
        {
            var size = healthFillRT.sizeDelta;
            size.x = maxWidth;
            size.y = barHeight;
            healthFillRT.sizeDelta = size;
        }

        // ПОДПИСКА на событие урона
        if (target != null)
            target.OnDamaged += HandleDamaged;
    }

    void OnDestroy()
    {
        if (target != null)
            target.OnDamaged -= HandleDamaged;
    }

    // Первое сообщение об уроне + критическое состояние
    void HandleDamaged(float amount, float current, float max)
    {
        if (isDead) return;

        if (showFirstDamageHint && !firstDamageShown)
        {
            firstDamageShown = true;
            HintsRuntime.Show("ВНИМАНИЕ: получен урон! Держитесь подальше от опасной рыбы, стен и всплытия", 2.6f, "dmg_first", 999f);
        }

        if (showCriticalHint && current <= max * Mathf.Clamp01(criticalPct))
        {
            HintsRuntime.Show("Критическое состояние корпуса! Избегайте столкновений.", 2.6f, "lowhp", 10f);
        }
    }

    void Update()
    {
        if (target == null || healthFillRT == null || healthFillImage == null)
            return;

        float hpFrac = Mathf.Clamp01(target.currentHealth / target.maxHealth);

        // сглаживание ширины
        shownFrac = Mathf.Lerp(shownFrac, hpFrac, 10f * Time.unscaledDeltaTime);

        var size = healthFillRT.sizeDelta;
        size.x = maxWidth * shownFrac;
        size.y = barHeight;
        healthFillRT.sizeDelta = size;

        // цвет бара
        Color c;
        if (hpFrac > 0.5f)
        {
            c = Color.Lerp(new Color(1f, 0.8f, 0.2f, 0.9f),
                           new Color(0.2f, 1f, 0.4f, 0.9f),
                           Mathf.InverseLerp(0.5f, 1f, hpFrac));
        }
        else
        {
            c = Color.Lerp(new Color(0.8f, 0.0f, 0.0f, 0.9f),
                           new Color(1f, 0.5f, 0.0f, 0.9f),
                           Mathf.InverseLerp(0.0f, 0.5f, hpFrac));
        }

        if (!isDead)
        {
            if (hpFrac <= 0f)
            {
                StartDeath();
                c = new Color(1f, 0f, 0f, 1f);
            }
            else if (hpFrac <= lowHealthThreshold)
            {
                float pulse = 0.5f + 0.5f * Mathf.PingPong(Time.unscaledTime * blinkSpeed, 1f);
                c.a = baseAlpha * pulse;
            }
            else
            {
                c.a = baseAlpha;
            }
        }
        else
        {
            c = new Color(1f, 0f, 0f, 1f);
        }

        healthFillImage.color = c;

        // фейд экрана смерти
        if (isDead && deathPanel != null)
        {
            deathPanel.alpha = Mathf.MoveTowards(deathPanel.alpha, 1f, Time.unscaledDeltaTime / deathFadeTime);
            if (deathPanel.alpha >= 0.99f)
            {
                deathPanel.interactable = true;
                deathPanel.blocksRaycasts = true;
            }
        }
    }

    void StartDeath()
    {
        if (isDead) return;
        isDead = true;

        Debug.Log("Субмарина уничтожена. Корпус раздавлен.");

        if (subController != null)
            subController.enabled = false;

        Time.timeScale = 0f;

        if (deathPanel != null)
        {
            deathPanel.gameObject.SetActive(true);
            deathPanel.alpha = 0f;
            deathPanel.interactable = false;
            deathPanel.blocksRaycasts = false;
        }

        if (!deathSoundPlayed)
        {
            PlayDeathSound();
            deathSoundPlayed = true;
        }
    }

    void PlayDeathSound()
    {
        if (!deathAudioSource || !deathClip)
        {
            if (!deathAudioSource) Debug.LogWarning("[SubmarineHealthUI] deathAudioSource = NULL.");
            if (!deathClip) Debug.LogWarning("[SubmarineHealthUI] deathClip = NULL.");
            return;
        }

        AudioListener.pause = false; // на всякий случай
        deathAudioSource.volume = deathVolume;
        deathAudioSource.clip = deathClip;
        deathAudioSource.loop = false;
        deathAudioSource.Play();
    }

    public void ReturnToMainMenu()
    {
        Time.timeScale = 1f;
        SceneManager.LoadScene(mainMenuSceneName);
    }
}


2.60 Текст программы «SubmarineInvulnerabilityBlink.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using System.Collections;
using UnityEngine;

public class SubmarineInvulnerabilityBlink : MonoBehaviour
{
    [Header("��� ����� ������ (������ ���������)")]
    public Renderer[] renderers;              // MeshRenderer / SkinnedMeshRenderer

    [Header("��������� �������")]
    [Tooltip("������� ������ ��������� ������ � ��������� ���������� ��� ����")]
    public float invulnDuration = 2f;

    [Tooltip("��� ����� ������ (���)")]
    public float blinkInterval = 0.15f;

    [Tooltip("������ � ������� ���� ��� � ���������")]
    public bool startVisible = true;

    bool isInvulnerable;
    Coroutine blinkRoutine;

    // ������, ����� ������ ������� ����� ������, ���� �� ������
    public bool IsInvulnerable => isInvulnerable;

    void Awake()
    {
        // ���� ������� �� ������ � ��������� ����
        if (renderers == null || renderers.Length == 0)
            renderers = GetComponentsInChildren<Renderer>();

        SetRenderersVisible(true);
    }

    public void TriggerInvulnerability()
    {
        if (blinkRoutine != null)
            StopCoroutine(blinkRoutine);

        blinkRoutine = StartCoroutine(BlinkCoroutine());
    }

    IEnumerator BlinkCoroutine()
    {
        isInvulnerable = true;

        float timer = 0f;
        bool visible = startVisible;

        while (timer < invulnDuration)
        {
            SetRenderersVisible(visible);
            visible = !visible;

            yield return new WaitForSeconds(blinkInterval);
            timer += blinkInterval;
        }

        // � ����� �������: ������ ������� �����
        SetRenderersVisible(true);

        isInvulnerable = false;
        blinkRoutine = null;
    }

    void SetRenderersVisible(bool visible)
    {
        if (renderers == null) return;

        foreach (var r in renderers)
        {
            if (r != null)
                r.enabled = visible;
        }
    }
}


2.61 Текст программы «SubmarineLightsBlinker.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public class SubmarineLightsBlinker : MonoBehaviour
{
    [Header("Renderers")]
    public Renderer sideLampsRenderer; // жёлтые боковые
    public Renderer topLampsRenderer;  // зелёные верхние

    [Header("Warmth (Кельвины)")]
    [Range(1500, 6500)] public float sideTemperatureK = 2600f; // тёплая лампа накаливания
    [Range(1500, 6500)] public float topTemperatureK = 3200f; // чуть холоднее для верха
    [Range(0f, 1f)] public float desaturate = 0.35f;       // снижение насыщенности (0.3–0.5)

    [Header("Blink & Intensity")]
    public float sideBlinkSpeed = 1.6f;
    public float topBlinkSpeed = 1.0f;

    // понизил по умолчанию — меньше «неона». Подбирай 0.6–1.8
    [Range(0f, 5f)] public float sideEmission = 1.0f;
    [Range(0f, 5f)] public float topEmission = 0.8f;

    [Tooltip("Смягчает мигание, чтобы не било по глазам и блуму")]
    public AnimationCurve pulseShape = AnimationCurve.EaseInOut(0, 0, 1, 1);

    [Header("Top (зелёные) — потеплее, но всё ещё зелёные")]
    [Range(0f, 1f)] public float topWarmMix = 0.55f; // смешиваем зелёный с тёплым белым

    [Header("Advanced")]
    [Tooltip("Менять ли базовый цвет материала. По умолчанию — нет, чтобы избежать «неона».")]
    public bool alsoAffectBaseColor = false;

    private MaterialPropertyBlock _mpbSide, _mpbTop;
    private static readonly int EmissionColorID = Shader.PropertyToID("_EmissionColor");
    private static readonly int BaseColorID = Shader.PropertyToID("_Color");

    void Awake()
    {
        _mpbSide ??= new MaterialPropertyBlock();
        _mpbTop ??= new MaterialPropertyBlock();
        EnableEmissionKeyword(sideLampsRenderer);
        EnableEmissionKeyword(topLampsRenderer);
    }

    void Update()
    {
        // --- БОКОВЫЕ (тёплый янтарный) ---
        if (sideLampsRenderer)
        {
            float t = 0.5f + 0.5f * Mathf.Sin(Time.time * sideBlinkSpeed * Mathf.PI * 2f);
            t = pulseShape.Evaluate(t); // сгладили синус
            Color warm = KelvinToRGB(sideTemperatureK);
            warm = Desaturate(warm, desaturate);

            // немного «не ноль» даже в off, чтобы не было полного провала
            float offLevel = 0.08f;
            float pulse = Mathf.Lerp(offLevel, 1f, t);
            Color emission = warm * (sideEmission * pulse);

            Apply(sideLampsRenderer, _mpbSide, emission, alsoAffectBaseColor ? warm : (Color?)null);
        }

        // --- ВЕРХНИЕ (зелёные, но теплее/желтее) ---
        if (topLampsRenderer)
        {
            float t = 0.5f + 0.5f * Mathf.Sin(Time.time * topBlinkSpeed * Mathf.PI * 2f);
            t = pulseShape.Evaluate(t);

            // базовый зелёный
            Color green = new Color(0f, 1f, 0.2f, 1f);
            // тёплый белый
            Color warmWhite = KelvinToRGB(topTemperatureK);
            // смешали — получился «оливково-жёлто-зелёный», мягче
            Color topWarm = Color.Lerp(green, warmWhite, topWarmMix);
            topWarm = Desaturate(topWarm, desaturate);

            float offLevel = 0.06f;
            float pulse = Mathf.Lerp(offLevel, 1f, t);
            Color emission = topWarm * (topEmission * pulse);

            Apply(topLampsRenderer, _mpbTop, emission, alsoAffectBaseColor ? topWarm : (Color?)null);
        }
    }

    // --- Helpers ---

    private void Apply(Renderer r, MaterialPropertyBlock mpb, Color emissionLinear, Color? baseColor = null)
    {
        if (!r) return;

        r.GetPropertyBlock(mpb);

        // Эмиссия — лучше в ЛИНЕЙНОМ, чтобы не «неонить» от гаммы
        // (Unity сам учтёт пространство, но явная конверсия убирает сюрпризы)
        mpb.SetColor(EmissionColorID, emissionLinear.linear);

        if (baseColor.HasValue)
        {
            // albedo — не усиливаем, без умножения на интенсивность
            mpb.SetColor(BaseColorID, baseColor.Value);
        }

        r.SetPropertyBlock(mpb);
    }

    private void EnableEmissionKeyword(Renderer r)
    {
        if (!r) return;
        var mats = r.sharedMaterials;
        for (int i = 0; i < mats.Length; i++)
        {
            var m = mats[i];
            if (!m) continue;
            if (!m.IsKeywordEnabled("_EMISSION"))
                m.EnableKeyword("_EMISSION");
        }
    }

    // Упрощённая конверсия «температура К» → RGB (достаточно для стилизации)
    private static Color KelvinToRGB(float kelvin)
    {
        kelvin = Mathf.Clamp(kelvin, 1000f, 15000f) / 100f;
        float r, g, b;

        // Red
        if (kelvin <= 66f) r = 1f;
        else r = Mathf.Clamp01(1.292936186062745f * Mathf.Pow(kelvin - 60f, -0.1332047592f));

        // Green
        if (kelvin <= 66f)
            g = Mathf.Clamp01(0.3900815787690196f * Mathf.Log(kelvin) - 0.6318414437886275f);
        else
            g = Mathf.Clamp01(1.129890860895294f * Mathf.Pow(kelvin - 60f, -0.0755148492f));

        // Blue
        if (kelvin >= 66f) b = 1f;
        else if (kelvin <= 19f) b = 0f;
        else b = Mathf.Clamp01(0.5432067891101961f * Mathf.Log(kelvin - 10f) - 1.19625408914f);

        return new Color(r, g, b, 1f);
    }

    private static Color Desaturate(Color c, float amount)
    {
        // в HSV понижаем S, чтобы уйти от кислотности
        Color.RGBToHSV(c, out float h, out float s, out float v);
        s = Mathf.Lerp(s, 0f, Mathf.Clamp01(amount));
        return Color.HSVToRGB(h, s, v);
    }
}


2.62 Текст программы «ThirdPersonSubCam.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public class ThirdPersonSubCam : MonoBehaviour
{
    [Header("Follow target")]
    public Transform followTarget;

    // Offset в ЛОКАЛЬНЫХ осях субмарины: X = вправо(-влево), Y = вверх, Z = вперёд(-назад)
    public Vector3 localOffset = new Vector3(-1f, 2f, -6f);

    [Header("Smoothing")]
    public float posSmoothTime = 0.15f;   // SmoothDamp-время к целевой позиции
    public float dirSmoothSpeed = 10f;    // сглаживание смены направления (чем больше — тем резче)
    public float lookLerpSpeed = 12f;     // скорость поворота камеры к цели

    [Header("Collision")]
    public LayerMask collisionMask;
    public float camRadius = 0.3f;
    public float minDistance = 0.5f;
    public float wallPadding = 0.05f;

    Vector3 posVel;         // velocity для SmoothDamp позиции
    Vector3 smoothedDir;    // сглажённое направление от цели к камере (нормализованное)

    void Start()
    {
        if (!followTarget) return;

        // стартовая идеальная позиция
        Vector3 idealPos = followTarget.TransformPoint(localOffset);
        Vector3 from = followTarget.position;
        smoothedDir = (idealPos - from).normalized;

        transform.position = idealPos;
        transform.rotation = Quaternion.LookRotation(from - transform.position, Vector3.up);
    }

    void LateUpdate()
    {
        if (!followTarget) return;

        // 1) Идеальная точка без коллизий в МИРЕ из локального смещения
        Vector3 idealPos = followTarget.TransformPoint(localOffset);
        Vector3 from = followTarget.position;

        Vector3 desiredDir = (idealPos - from).normalized;
        float desiredDist = Vector3.Distance(from, idealPos);

        // 2) Сгладить смену направления (даёт плавное «боковое» следование)
        float t = 1f - Mathf.Exp(-dirSmoothSpeed * Time.deltaTime); // плавный коэффициент
        smoothedDir = Vector3.Slerp(smoothedDir, desiredDir, t);
        if (smoothedDir.sqrMagnitude < 1e-6f) smoothedDir = desiredDir; // защита
        smoothedDir.Normalize();

        // 3) Коллизии по сглаженному направлению
        float targetDist = desiredDist;
        if (Physics.SphereCast(from, camRadius, smoothedDir, out var hit, desiredDist, collisionMask, QueryTriggerInteraction.Ignore))
            targetDist = Mathf.Max(minDistance, hit.distance - wallPadding);

        Vector3 targetPos = from + smoothedDir * targetDist;

        // 4) Плавное смещение камеры
        transform.position = Vector3.SmoothDamp(transform.position, targetPos, ref posVel, posSmoothTime);

        // 5) Плавный взгляд на субмарину
        var desiredRot = Quaternion.LookRotation(from - transform.position, Vector3.up);
        transform.rotation = Quaternion.Slerp(transform.rotation, desiredRot, Time.deltaTime * lookLerpSpeed);
    }
}


2.63 Текст программы «ToxicScreenEffect.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using System.Collections;
using UnityEngine;
using UnityEngine.UI;

public class ToxicScreenEffect : MonoBehaviour
{
    [Header("Overlay")]
    public Image overlayImage;     // ������ �� Image

    [Header("Blink settings")]
    public int blinkCount = 3;
    public float fadeInTime = 0.1f;
    public float holdTime = 0.05f;
    public float fadeOutTime = 0.1f;
    public float betweenBlinks = 0.05f;
    [Range(0f, 1f)]
    public float maxAlpha = 0.7f;

    void Awake()
    {
        if (overlayImage == null)
            overlayImage = GetComponent<Image>();

        if (overlayImage != null)
        {
            var c = overlayImage.color;
            c.a = 0f;                // ���������� ��������� ����������
            overlayImage.color = c;
        }
    }

    public void Play()
    {
        if (overlayImage == null) return;

        StopAllCoroutines();
        StartCoroutine(DoEffect());
    }

    IEnumerator DoEffect()
    {
        Color c = overlayImage.color;

        for (int i = 0; i < blinkCount; i++)
        {
            // ����������
            float t = 0f;
            while (t < fadeInTime)
            {
                t += Time.deltaTime;
                float k = fadeInTime > 0f ? t / fadeInTime : 1f;
                c.a = Mathf.Lerp(0f, maxAlpha, k);
                overlayImage.color = c;
                yield return null;
            }

            if (holdTime > 0f)
                yield return new WaitForSeconds(holdTime);

            // �����������
            t = 0f;
            while (t < fadeOutTime)
            {
                t += Time.deltaTime;
                float k = fadeOutTime > 0f ? t / fadeOutTime : 1f;
                c.a = Mathf.Lerp(maxAlpha, 0f, k);
                overlayImage.color = c;
                yield return null;
            }

            c.a = 0f;
            overlayImage.color = c;

            if (betweenBlinks > 0f && i < blinkCount - 1)
                yield return new WaitForSeconds(betweenBlinks);
        }
    }
}


2.64 Текст программы «TutorialGatedHints.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public class TutorialHintsMobile : MonoBehaviour
{
    public static bool Active { get; private set; }

    [Header("Refs")]
    public SubmarineController subController;

    [Header("������")]
    [Tooltip("��������� �� ��������� ��������, ������ ���� �������� ��������� � ����������.")]
    public bool onlyIfHintsEnabled = true;

    // 0 = ��������, 1 = �����/����, 2 = ����, 3 = ������� ����
    int step;
    bool movedForward, movedBack, movedLeft, movedRight;
    bool movedUp, movedDown;

    void OnEnable()
    {
        FishCatcher.OnAnyFishCaught += OnAnyFishCaught;
    }

    void OnDisable()
    {
        FishCatcher.OnAnyFishCaught -= OnAnyFishCaught;
    }

    void Start()
    {
        // ������ ������� �������� ���������

        if (onlyIfHintsEnabled && !HintsPref.Get())
        {
            enabled = false;
            return;
        }

        if (!subController)
        {
            Debug.LogWarning("TutorialHintsMobile: no SubmarineController reference");
            enabled = false;
            return;
        }

        Begin();
    }

    void Begin()
    {
        Active = true;

        // ����� ����, �� SubmarineController ���������� �������� input
        Time.timeScale = 0f;

        step = 0;
        movedForward = movedBack = movedLeft = movedRight = movedUp = movedDown = false;

        HintsPopupUI.I?.ShowSticky(
            "��������: ��������� ����� ������� �������� � �������� �������� �� ��� �������."
        );
    }

    void Update()
    {
        if (!Active) return;

        switch (step)
        {
            case 0: HandleStep0_Movement(); break;
            case 1: HandleStep1_UpDown(); break;
            case 2: /* ��� ������ ������ (OnScanPressedMobile) */ break;
            case 3: /* ��� OnAnyFishCaught */ break;
        }
    }

    // ---------- ��� 0: �������� ----------

    void HandleStep0_Movement()
    {
        float move = subController.MoveAxis;
        float yaw = subController.YawAxis;

        const float threshold = 0.4f;

        if (move > threshold) movedForward = true;
        if (move < -threshold) movedBack = true;
        if (yaw < -threshold) movedLeft = true;
        if (yaw > threshold) movedRight = true;

        if (movedForward && movedBack && movedLeft && movedRight)
        {
            step = 1;

            HintsPopupUI.I?.ShowSticky(
                "������/�����: ������ ������������ ����� � ������ ����� � ����."
            );
        }
    }

    // ---------- ��� 1: �����/���� ----------

    void HandleStep1_UpDown()
    {
        float upAxis = subController.UpAxis;
        const float vThreshold = 0.4f;

        if (upAxis > vThreshold) movedUp = true;
        if (upAxis < -vThreshold) movedDown = true;

        if (movedUp && movedDown)
        {
            step = 2;

            HintsPopupUI.I?.ShowSticky(
                "����: ����� ������ ������ �� ������."
            );
        }
    }

    // ---------- ��� 2: ���� ----------

    // ���������� � ������ ������ (UI Button) �� �������
    public void OnScanPressedMobile()
    {
        if (!Active || step != 2) return;

        CompleteScanStep();
    }

    void CompleteScanStep()
    {
        step = 3;

        // ����� ����� ���� ���������� ����
        Time.timeScale = 1f;

        HintsPopupUI.I?.ShowSticky(
            "������ ����: �������� ����� � ����, ������� ���� � ������ ��������."
        );
    }

    void OnAnyFishCaught()
    {
        if (!Active || step != 3) return;
        Finish();
    }

    void Finish()
    {
        Active = false;
        HintsPopupUI.I?.HideImmediate();
        enabled = false;
    }
}


2.65 Текст программы «TutorialHintsPC.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public class TutorialHintsPC : MonoBehaviour
{
    public static bool Active { get; private set; }

    [Header("Refs")]
    public SubmarineController subController;

    [Header("������")]
    public bool onlyIfHintsEnabled = true;

    [Header("������� ����������")]
    public KeyCode keyForward = KeyCode.W;
    public KeyCode keyBackward = KeyCode.S;
    public KeyCode keyLeft = KeyCode.A;
    public KeyCode keyRight = KeyCode.D;

    public KeyCode keyUp = KeyCode.Space;
    public KeyCode keyDown = KeyCode.R;

    public KeyCode keyScan = KeyCode.E;

    // 0 = ��������, 1 = �����/����, 2 = ����, 3 = ������� ����
    int step;
    bool movedForward, movedBack, movedLeft, movedRight;
    bool movedUp, movedDown;

    void OnEnable()
    {
        FishCatcher.OnAnyFishCaught += OnAnyFishCaught;
    }

    void OnDisable()
    {
        FishCatcher.OnAnyFishCaught -= OnAnyFishCaught;
    }

    void Start()
    {
        if (onlyIfHintsEnabled && !HintsPref.Get())
        {
            enabled = false;
            return;
        }

        if (!subController)
        {
            Debug.LogWarning("TutorialHintsPC: no SubmarineController reference");
            enabled = false;
            return;
        }

        Begin();
    }

    void Begin()
    {
        Active = true;

        // ����� ����, �� ���� ������
        Time.timeScale = 0f;

        step = 0;
        movedForward = movedBack = movedLeft = movedRight = movedUp = movedDown = false;

        HintsPopupUI.I?.ShowSticky(
            $"��������: {keyForward} {keyLeft} {keyBackward} {keyRight} � " +
            "�������� �������� �����, �����, ����� � ������."
        );
    }

    void Update()
    {
        if (!Active) return;

        switch (step)
        {
            case 0: HandleStep0_Movement(); break;
            case 1: HandleStep1_UpDown(); break;
            case 2: HandleStep2_Scan(); break;
            case 3: /* ��� OnAnyFishCaught */ break;
        }
    }

    // ---------- ��� 0: �������� ----------

    void HandleStep0_Movement()
    {
        if (Input.GetKey(keyForward)) movedForward = true;
        if (Input.GetKey(keyBackward)) movedBack = true;
        if (Input.GetKey(keyLeft)) movedLeft = true;
        if (Input.GetKey(keyRight)) movedRight = true;

        if (movedForward && movedBack && movedLeft && movedRight)
        {
            step = 1;

            HintsPopupUI.I?.ShowSticky(
                $"������/�����: {keyUp} � �����, {keyDown} � ����. ����� ���."
            );
        }
    }

    // ---------- ��� 1: �����/���� ----------

    void HandleStep1_UpDown()
    {
        if (Input.GetKey(keyUp)) movedUp = true;
        if (Input.GetKey(keyDown)) movedDown = true;

        if (movedUp && movedDown)
        {
            step = 2;

            HintsPopupUI.I?.ShowSticky(
                $"����: ����� {keyScan}."
            );
        }
    }

    // ---------- ��� 2: ���� ----------

    void HandleStep2_Scan()
    {
        if (Input.GetKeyDown(keyScan))
        {
            CompleteScanStep();
        }
    }

    void CompleteScanStep()
    {
        step = 3;

        // ������ ���� ��� � �������� �������
        Time.timeScale = 1f;

        HintsPopupUI.I?.ShowSticky(
            "������ ����: �������� ����� � ����, ������� ���� � ������ ��������."
        );
    }

    void OnAnyFishCaught()
    {
        if (!Active || step != 3) return;
        Finish();
    }

    void Finish()
    {
        Active = false;
        HintsPopupUI.I?.HideImmediate();
        enabled = false;
    }
}


2.66 Текст программы «UiClickDebugger.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using UnityEngine.EventSystems;

public class UiClickDebugger : MonoBehaviour, IPointerClickHandler
{
    public void OnPointerClick(PointerEventData eventData)
    {
        Debug.Log("[UiClickDebugger] Click on " + gameObject.name +
                  " button, event=" + eventData.button);
    }
}


2.67 Текст программы «UnderwaterDistortEffect1.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
public class UnderwaterDistortEffect : MonoBehaviour
{
    public Shader distortShader;
    public float strength = 0.002f;
    public float speed = 1.0f;
    public float frequency = 4.0f;

    Material _mat;

    void OnEnable()
    {
        if (distortShader == null)
            distortShader = Shader.Find("Hidden/UnderwaterDistort_BuiltIn");

        if (distortShader != null)
            _mat = new Material(distortShader);
    }

    void OnRenderImage(RenderTexture src, RenderTexture dst)
    {
        if (_mat == null)
        {
            Graphics.Blit(src, dst);
            return;
        }

        _mat.SetFloat("_Strength", strength);
        _mat.SetFloat("_Speed", speed);
        _mat.SetFloat("_Frequency", frequency);
        _mat.SetFloat("_TimeValue", Time.time);

        Graphics.Blit(src, dst, _mat);
    }
}


2.68 Текст программы «UnderwaterFogController.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;

public class UnderwaterFogController : MonoBehaviour
{
    [Header("Water Level (Y)")]
    public float waterSurfaceY = 0f; // ������ ����������� ���� � ����

    [Header("Fog density")]
    public float minFogDensity = 0.02f; // ����� � �����������
    public float maxFogDensity = 0.08f; // �������

    [Header("Fog colors")]
    public Color shallowColor = new Color(0.10f, 0.30f, 0.40f, 1f); // ��������� ������
    public Color deepColor = new Color(0.02f, 0.08f, 0.12f, 1f); // ����-����� �����

    [Header("Depth settings")]
    public float shallowDepth = 0.0f;   // ����� �� �����������
    public float deepDepth = 20.0f;  // ��� ������� "����� �������"

    void Update()
    {
        float camY = transform.position.y;

        // ��������� ������� �� ���� ����������� ����?
        // camY ���� ���� -> depth = 0
        float depth = Mathf.Max(0f, waterSurfaceY - camY);

        // ����������� ������� � [0..1]
        float t = Mathf.InverseLerp(shallowDepth, deepDepth, depth);
        // ������� ����-����, ����� �� ��������
        t = Mathf.SmoothStep(0f, 1f, t);

        // ���� ��������� ������
        float density = Mathf.Lerp(minFogDensity, maxFogDensity, t);
        RenderSettings.fogDensity = density;

        // ���� ����� ������ (������ = ������/�����)
        Color fogCol = Color.Lerp(shallowColor, deepColor, t);
        RenderSettings.fogColor = fogCol;
    }
}


2.69 Текст программы «VolumeSettingsUI.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using UnityEngine.UI;

public class VolumeSettingsUI : MonoBehaviour
{
    [Header("Sliders (0..1)")]
    public Slider masterSlider;
    public Slider musicSlider;
    public Slider engineSlider;
    public Slider sfxSlider;
    public Slider sonarSlider;

    [Header("Buttons")]
    public Button saveButton;
    public Button cancelButton;

    struct VolState
    {
        public float master, music, engine, sfx, sonar;
    }

    VolState initial;

    void Awake()
    {
        // ��������� �������� �� PlayerPrefs
        if (masterSlider) masterSlider.value = SoundSettings.GetMaster();
        if (musicSlider) musicSlider.value = SoundSettings.GetMusic();
        if (engineSlider) engineSlider.value = SoundSettings.GetEngine();
        if (sfxSlider) sfxSlider.value = SoundSettings.GetSfx();
        if (sonarSlider) sonarSlider.value = SoundSettings.GetSonar();

        initial = CaptureCurrent();

        if (saveButton)
        {
            saveButton.interactable = false;
            saveButton.onClick.AddListener(Save);
        }

        if (cancelButton)
            cancelButton.onClick.AddListener(Cancel);

        // ������� ��������� ���������
        if (masterSlider) masterSlider.onValueChanged.AddListener(_ => OnChanged());
        if (musicSlider) musicSlider.onValueChanged.AddListener(_ => OnChanged());
        if (engineSlider) engineSlider.onValueChanged.AddListener(_ => OnChanged());
        if (sfxSlider) sfxSlider.onValueChanged.AddListener(_ => OnChanged());
        if (sonarSlider) sonarSlider.onValueChanged.AddListener(_ => OnChanged());
    }

    VolState CaptureCurrent()
    {
        VolState s;
        s.master = masterSlider ? masterSlider.value : SoundSettings.GetMaster();
        s.music = musicSlider ? musicSlider.value : SoundSettings.GetMusic();
        s.engine = engineSlider ? engineSlider.value : SoundSettings.GetEngine();
        s.sfx = sfxSlider ? sfxSlider.value : SoundSettings.GetSfx();
        s.sonar = sonarSlider ? sonarSlider.value : SoundSettings.GetSonar();
        return s;
    }

    bool IsDifferentFromInitial()
    {
        VolState cur = CaptureCurrent();
        const float EPS = 0.0001f;
        if (Mathf.Abs(cur.master - initial.master) > EPS) return true;
        if (Mathf.Abs(cur.music - initial.music) > EPS) return true;
        if (Mathf.Abs(cur.engine - initial.engine) > EPS) return true;
        if (Mathf.Abs(cur.sfx - initial.sfx) > EPS) return true;
        if (Mathf.Abs(cur.sonar - initial.sonar) > EPS) return true;
        return false;
    }

    void OnChanged()
    {
        if (saveButton)
            saveButton.interactable = IsDifferentFromInitial();
    }

    public void Save()
    {
        if (masterSlider) SoundSettings.SetMaster(masterSlider.value);
        if (musicSlider) SoundSettings.SetMusic(musicSlider.value);
        if (engineSlider) SoundSettings.SetEngine(engineSlider.value);
        if (sfxSlider) SoundSettings.SetSfx(sfxSlider.value);
        if (sonarSlider) SoundSettings.SetSonar(sonarSlider.value);

        initial = CaptureCurrent();
        if (saveButton) saveButton.interactable = false;

        // ��������� �� ���� SubmarineAudio � �����
        var allAudio = FindObjectsOfType<SubmarineAudio>();
        foreach (var a in allAudio)
        {
            a.ApplyVolumeSettings();
        }
    }

    public void Cancel()
    {
        if (masterSlider) masterSlider.value = initial.master;
        if (musicSlider) musicSlider.value = initial.music;
        if (engineSlider) engineSlider.value = initial.engine;
        if (sfxSlider) sfxSlider.value = initial.sfx;
        if (sonarSlider) sonarSlider.value = initial.sonar;

        if (saveButton) saveButton.interactable = false;
    }
}


2.70 Текст программы «WebGLBrowserCheck.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Runtime.InteropServices;

public static class WebGLBrowserCheck
{
#if UNITY_WEBGL && !UNITY_EDITOR
    [DllImport("__Internal")]
    private static extern int IsMobilePlatform();
#endif

    /// <summary>
    /// true � ���� WebGL ������� � ��������� ��������,
    /// false � �� ���� ��������� ������� (��, ��������, �� WebGL).
    /// </summary>
    public static bool IsMobileBrowser()
    {
#if UNITY_WEBGL && !UNITY_EDITOR
        return IsMobilePlatform() != 0;
#else
        return false;
#endif
    }
}


2.71 Текст программы «WorldHeightLimiter.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;

public class WorldBoundaryY : MonoBehaviour
{
    [Header("Ограничения по высоте (ось Y)")]
    public float minY = -50f;
    public bool useMinY = false;

    public float maxY = 15f;
    public bool useMaxY = true;

    public float boundaryDamage = 15f; // урон при выходе за границу

    [Header("Фейд экрана")]
    public CanvasGroup fadeCanvas;
    public float fadeDuration = 0.4f;

    [Header("Возврат в пределы")]
    public float pushForce = 5f;
    public float cooldownAfterReturn = 0.2f;

    Rigidbody rb;
    SubmarineController controller;
    SubmarineHealth health;
    SubmarineAudio audioRef; // ← ДОБАВИЛИ

    bool isRespawning = false;

    void Awake()
    {
        rb = GetComponent<Rigidbody>();
        controller = GetComponent<SubmarineController>();
        health = GetComponent<SubmarineHealth>();
        audioRef = GetComponent<SubmarineAudio>(); // ← аудио менеджер

        if (health == null)
            Debug.LogWarning("[WorldBoundaryY] SubmarineHealth не найден!");

        if (fadeCanvas == null)
            Debug.LogWarning("[WorldBoundaryY] fadeCanvas не назначен.");
    }

    void Update()
    {
        if (isRespawning) return;

        float y = transform.position.y;

        bool tooLow = useMinY && y < minY;
        bool tooHigh = useMaxY && y > maxY;

        if (tooLow || tooHigh)
        {
            StartCoroutine(ReturnInsideY());
        }
    }

    IEnumerator ReturnInsideY()
    {
        isRespawning = true;

        // отключить управление
        if (controller != null)
            controller.enabled = false;

        // остановить физику
        if (rb != null)
        {
            rb.velocity = Vector3.zero;
            rb.angularVelocity = Vector3.zero;
            rb.isKinematic = true;
        }

        // нанести урон и звук аварии
        if (health != null && boundaryDamage > 0f)
        {
            health.ApplyDamage(boundaryDamage);
        }

        if (audioRef != null)
        {
            audioRef.PlayBoundaryHit();
        }

        // затемнение
        yield return StartCoroutine(FadeTo(1f));

        // вернуть в зону
        Vector3 p = transform.position;
        if (useMinY && p.y < minY) p.y = minY;
        if (useMaxY && p.y > maxY) p.y = maxY;
        transform.position = p;

        // подождать кадр
        yield return null;

        // включить физику обратно (слегка толкнуть вниз-вперёд)
        if (rb != null)
        {
            rb.isKinematic = false;
            Vector3 shoveDir = (Vector3.down - transform.forward * 0.5f).normalized;
            rb.velocity = shoveDir * pushForce;
            rb.angularVelocity = Vector3.zero;
        }

        // убрать затемнение
        yield return StartCoroutine(FadeTo(0f));

        // вернуть управление игроку
        if (controller != null)
            controller.enabled = true;

        // короткий кулдаун
        yield return new WaitForSeconds(cooldownAfterReturn);

        isRespawning = false;
    }

    IEnumerator FadeTo(float targetAlpha)
    {
        if (fadeCanvas == null)
            yield break;

        float startAlpha = fadeCanvas.alpha;
        float t = 0f;

        while (t < fadeDuration)
        {
            t += Time.deltaTime;
            float k = t / fadeDuration;
            fadeCanvas.alpha = Mathf.Lerp(startAlpha, targetAlpha, k);
            yield return null;
        }

        fadeCanvas.alpha = targetAlpha;
    }
}


2.72 Текст программы «WorldLimitZone.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;

public class WorldLimitZone : MonoBehaviour
{
    [Header("���� ���������� ������")]
    public Transform respawnPoint;        // ����� ������ ���������

    [Header("���������� ������")]
    public CanvasGroup fadeCanvas;        // CanvasGroup �� ������������� ����� ��������
    public float fadeDuration = 0.4f;

    [Header("����� ��������")]
    public float pushForce = 5f;

    [Header("�������")]
    public bool logDebug = true;

    bool isRespawning = false;

    void Awake()
    {
        if (logDebug) Debug.Log("[WorldLimitZone] Awake �� �������: " + gameObject.name);

        // ������� �������� ������������ ����� � ��������:
        if (!GetComponent<Collider>())
        {
            Debug.LogError("[WorldLimitZone] ��� Collider �� " + name + " (������ ���� BoxCollider)");
        }
        else
        {
            var col = GetComponent<Collider>();
            if (!col.isTrigger)
            {
                Debug.LogError("[WorldLimitZone] Collider �� ������� ��� Trigger �� " + name + " (isTrigger ������ ���� true)");
            }
        }

        if (respawnPoint == null)
        {
            Debug.LogWarning("[WorldLimitZone] respawnPoint ������. �������� ����� ��������.");
        }
        if (fadeCanvas == null)
        {
            Debug.LogWarning("[WorldLimitZone] fadeCanvas ������. ���������� �� ���������.");
        }
    }

    void OnTriggerEnter(Collider other)
    {
        if (logDebug) Debug.Log("[WorldLimitZone] OnTriggerEnter � " + other.name + " (tag=" + other.tag + ")");

        // �� �� ��������� ��� �����, �� ������ ������������ ���� ���� Rigidbody
        Rigidbody rb = other.attachedRigidbody;
        if (rb != null && !isRespawning)
        {
            StartCoroutine(HandleRespawn(other, rb));
        }
    }

    IEnumerator HandleRespawn(Collider other, Rigidbody rb)
    {
        isRespawning = true;

        if (logDebug) Debug.Log("[WorldLimitZone] HANDLE RESPAWN ����� ��� " + other.name);

        // 0. ��������� ���������� �����, ����� ��� �� ��������������
        var controller = other.GetComponent<SubmarineController>();
        if (controller != null)
        {
            controller.enabled = false;
            if (logDebug) Debug.Log("[WorldLimitZone] �������� SubmarineController �� " + other.name);
        }

        // 1. ������������ ������ �� ����� ���������
        rb.velocity = Vector3.zero;
        rb.angularVelocity = Vector3.zero;
        rb.isKinematic = true;

        // 2. ���� Ҩ���
        yield return StartCoroutine(FadeTo(1f));

        // 3. �������� ������
        if (respawnPoint != null)
        {
            other.transform.position = respawnPoint.position;
            other.transform.rotation = respawnPoint.rotation;

            if (logDebug) Debug.Log("[WorldLimitZone] ����������� � " + respawnPoint.position);
        }
        else
        {
            if (logDebug) Debug.LogWarning("[WorldLimitZone] respawnPoint �� ��������, ������ ���������������.");
        }

        // 4. ��� ����, ����� ���������� ������
        yield return null;
        rb.isKinematic = false;
        rb.velocity = other.transform.forward * pushForce;
        rb.angularVelocity = Vector3.zero;

        // 5. ���� �������
        yield return StartCoroutine(FadeTo(0f));

        // 6. �������� ���������� �������
        if (controller != null)
        {
            controller.enabled = true;
            if (logDebug) Debug.Log("[WorldLimitZone] ������� SubmarineController �������");
        }

        isRespawning = false;
        if (logDebug) Debug.Log("[WorldLimitZone] HANDLE RESPAWN �����");
    }

    IEnumerator FadeTo(float targetAlpha)
    {
        if (fadeCanvas == null)
        {
            // ���� �� ����� � ������ �������
            yield break;
        }

        float startAlpha = fadeCanvas.alpha;
        float t = 0f;

        while (t < fadeDuration)
        {
            t += Time.deltaTime;
            float k = t / fadeDuration;
            fadeCanvas.alpha = Mathf.Lerp(startAlpha, targetAlpha, k);
            yield return null;
        }

        fadeCanvas.alpha = targetAlpha;
    }
}


2.73 Текст программы «Benchmark01.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class Benchmark01 : MonoBehaviour
    {

        public int BenchmarkType = 0;

        public TMP_FontAsset TMProFont;
        public Font TextMeshFont;

        private TextMeshPro m_textMeshPro;
        private TextContainer m_textContainer;
        private TextMesh m_textMesh;

        private const string label01 = "The <#0050FF>count is: </color>{0}";
        private const string label02 = "The <color=#0050FF>count is: </color>";

        //private string m_string;
        //private int m_frame;

        private Material m_material01;
        private Material m_material02;



        IEnumerator Start()
        {



            if (BenchmarkType == 0) // TextMesh Pro Component
            {
                m_textMeshPro = gameObject.AddComponent<TextMeshPro>();
                m_textMeshPro.autoSizeTextContainer = true;

                //m_textMeshPro.anchorDampening = true;

                if (TMProFont != null)
                    m_textMeshPro.font = TMProFont;

                //m_textMeshPro.font = Resources.Load("Fonts & Materials/Anton SDF", typeof(TextMeshProFont)) as TextMeshProFont; // Make sure the Anton SDF exists before calling this...
                //m_textMeshPro.fontSharedMaterial = Resources.Load("Fonts & Materials/Anton SDF", typeof(Material)) as Material; // Same as above make sure this material exists.

                m_textMeshPro.fontSize = 48;
                m_textMeshPro.alignment = TextAlignmentOptions.Center;
                //m_textMeshPro.anchor = AnchorPositions.Center;
                m_textMeshPro.extraPadding = true;
                //m_textMeshPro.outlineWidth = 0.25f;
                //m_textMeshPro.fontSharedMaterial.SetFloat("_OutlineWidth", 0.2f);
                //m_textMeshPro.fontSharedMaterial.EnableKeyword("UNDERLAY_ON");
                //m_textMeshPro.lineJustification = LineJustificationTypes.Center;
                m_textMeshPro.enableWordWrapping = false;    
                //m_textMeshPro.lineLength = 60;          
                //m_textMeshPro.characterSpacing = 0.2f;
                //m_textMeshPro.fontColor = new Color32(255, 255, 255, 255);

                m_material01 = m_textMeshPro.font.material;
                m_material02 = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Drop Shadow"); // Make sure the LiberationSans SDF exists before calling this...  


            }
            else if (BenchmarkType == 1) // TextMesh
            {
                m_textMesh = gameObject.AddComponent<TextMesh>();

                if (TextMeshFont != null)
                {
                    m_textMesh.font = TextMeshFont;
                    m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material;
                }
                else
                {
                    m_textMesh.font = Resources.Load("Fonts/ARIAL", typeof(Font)) as Font;
                    m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material;
                }

                m_textMesh.fontSize = 48;
                m_textMesh.anchor = TextAnchor.MiddleCenter;

                //m_textMesh.color = new Color32(255, 255, 0, 255);
            }



            for (int i = 0; i <= 1000000; i++)
            {
                if (BenchmarkType == 0)
                {
                    m_textMeshPro.SetText(label01, i % 1000);
                    if (i % 1000 == 999)
                        m_textMeshPro.fontSharedMaterial = m_textMeshPro.fontSharedMaterial == m_material01 ? m_textMeshPro.fontSharedMaterial = m_material02 : m_textMeshPro.fontSharedMaterial = m_material01;



                }
                else if (BenchmarkType == 1)
                    m_textMesh.text = label02 + (i % 1000).ToString();

                yield return null;
            }


            yield return null;
        }


        /*
        void Update()
        {
            if (BenchmarkType == 0)
            {
                m_textMeshPro.text = (m_frame % 1000).ToString();
            }
            else if (BenchmarkType == 1)
            {
                m_textMesh.text = (m_frame % 1000).ToString();
            }

            m_frame += 1;
        }
        */
    }
}


2.74 Текст программы «Benchmark01_UGUI.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;
using UnityEngine.UI;


namespace TMPro.Examples
{
    
    public class Benchmark01_UGUI : MonoBehaviour
    {

        public int BenchmarkType = 0;

        public Canvas canvas;
        public TMP_FontAsset TMProFont;
        public Font TextMeshFont;

        private TextMeshProUGUI m_textMeshPro;
        //private TextContainer m_textContainer;
        private Text m_textMesh;

        private const string label01 = "The <#0050FF>count is: </color>";
        private const string label02 = "The <color=#0050FF>count is: </color>";

        //private const string label01 = "TextMesh <#0050FF>Pro!</color>  The count is: {0}";
        //private const string label02 = "Text Mesh<color=#0050FF>        The count is: </color>";

        //private string m_string;
        //private int m_frame;

        private Material m_material01;
        private Material m_material02;



        IEnumerator Start()
        {



            if (BenchmarkType == 0) // TextMesh Pro Component
            {
                m_textMeshPro = gameObject.AddComponent<TextMeshProUGUI>();
                //m_textContainer = GetComponent<TextContainer>();


                //m_textMeshPro.anchorDampening = true;

                if (TMProFont != null)
                    m_textMeshPro.font = TMProFont;

                //m_textMeshPro.font = Resources.Load("Fonts & Materials/Anton SDF", typeof(TextMeshProFont)) as TextMeshProFont; // Make sure the Anton SDF exists before calling this...           
                //m_textMeshPro.fontSharedMaterial = Resources.Load("Fonts & Materials/Anton SDF", typeof(Material)) as Material; // Same as above make sure this material exists.

                m_textMeshPro.fontSize = 48;
                m_textMeshPro.alignment = TextAlignmentOptions.Center;
                //m_textMeshPro.anchor = AnchorPositions.Center;
                m_textMeshPro.extraPadding = true;
                //m_textMeshPro.outlineWidth = 0.25f;
                //m_textMeshPro.fontSharedMaterial.SetFloat("_OutlineWidth", 0.2f);
                //m_textMeshPro.fontSharedMaterial.EnableKeyword("UNDERLAY_ON");
                //m_textMeshPro.lineJustification = LineJustificationTypes.Center;
                //m_textMeshPro.enableWordWrapping = true;    
                //m_textMeshPro.lineLength = 60;          
                //m_textMeshPro.characterSpacing = 0.2f;
                //m_textMeshPro.fontColor = new Color32(255, 255, 255, 255);

                m_material01 = m_textMeshPro.font.material;
                m_material02 = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - BEVEL"); // Make sure the LiberationSans SDF exists before calling this...  


            }
            else if (BenchmarkType == 1) // TextMesh
            {
                m_textMesh = gameObject.AddComponent<Text>();

                if (TextMeshFont != null)
                {
                    m_textMesh.font = TextMeshFont;
                    //m_textMesh.renderer.sharedMaterial = m_textMesh.font.material;
                }
                else
                {
                    //m_textMesh.font = Resources.Load("Fonts/ARIAL", typeof(Font)) as Font;
                    //m_textMesh.renderer.sharedMaterial = m_textMesh.font.material;
                }

                m_textMesh.fontSize = 48;
                m_textMesh.alignment = TextAnchor.MiddleCenter;

                //m_textMesh.color = new Color32(255, 255, 0, 255);    
            }



            for (int i = 0; i <= 1000000; i++)
            {
                if (BenchmarkType == 0)
                {
                    m_textMeshPro.text = label01 + (i % 1000);
                    if (i % 1000 == 999)
                        m_textMeshPro.fontSharedMaterial = m_textMeshPro.fontSharedMaterial == m_material01 ? m_textMeshPro.fontSharedMaterial = m_material02 : m_textMeshPro.fontSharedMaterial = m_material01;



                }
                else if (BenchmarkType == 1)
                    m_textMesh.text = label02 + (i % 1000).ToString();

                yield return null;
            }


            yield return null;
        }


        /*
        void Update()
        {
            if (BenchmarkType == 0)
            {
                m_textMeshPro.text = (m_frame % 1000).ToString();            
            }
            else if (BenchmarkType == 1)
            {
                m_textMesh.text = (m_frame % 1000).ToString();
            }

            m_frame += 1;
        }
        */
    }

}


2.75 Текст программы «Benchmark02.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{

    public class Benchmark02 : MonoBehaviour
    {

        public int SpawnType = 0;
        public int NumberOfNPC = 12;

        public bool IsTextObjectScaleStatic;
        private TextMeshProFloatingText floatingText_Script;


        void Start()
        {

            for (int i = 0; i < NumberOfNPC; i++)
            {


                if (SpawnType == 0)
                {
                    // TextMesh Pro Implementation
                    GameObject go = new GameObject();
                    go.transform.position = new Vector3(Random.Range(-95f, 95f), 0.25f, Random.Range(-95f, 95f));

                    TextMeshPro textMeshPro = go.AddComponent<TextMeshPro>();

                    textMeshPro.autoSizeTextContainer = true;
                    textMeshPro.rectTransform.pivot = new Vector2(0.5f, 0);

                    textMeshPro.alignment = TextAlignmentOptions.Bottom;
                    textMeshPro.fontSize = 96;
                    textMeshPro.enableKerning = false;

                    textMeshPro.color = new Color32(255, 255, 0, 255);
                    textMeshPro.text = "!";
                    textMeshPro.isTextObjectScaleStatic = IsTextObjectScaleStatic;

                    // Spawn Floating Text
                    floatingText_Script = go.AddComponent<TextMeshProFloatingText>();
                    floatingText_Script.SpawnType = 0;
                    floatingText_Script.IsTextObjectScaleStatic = IsTextObjectScaleStatic;
                }
                else if (SpawnType == 1)
                {
                    // TextMesh Implementation
                    GameObject go = new GameObject();
                    go.transform.position = new Vector3(Random.Range(-95f, 95f), 0.25f, Random.Range(-95f, 95f));

                    TextMesh textMesh = go.AddComponent<TextMesh>();
                    textMesh.font = Resources.Load<Font>("Fonts/ARIAL");
                    textMesh.GetComponent<Renderer>().sharedMaterial = textMesh.font.material;

                    textMesh.anchor = TextAnchor.LowerCenter;
                    textMesh.fontSize = 96;

                    textMesh.color = new Color32(255, 255, 0, 255);
                    textMesh.text = "!";

                    // Spawn Floating Text
                    floatingText_Script = go.AddComponent<TextMeshProFloatingText>();
                    floatingText_Script.SpawnType = 1;
                }
                else if (SpawnType == 2)
                {
                    // Canvas WorldSpace Camera
                    GameObject go = new GameObject();
                    Canvas canvas = go.AddComponent<Canvas>();
                    canvas.worldCamera = Camera.main;

                    go.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f);
                    go.transform.position = new Vector3(Random.Range(-95f, 95f), 5f, Random.Range(-95f, 95f));

                    TextMeshProUGUI textObject = new GameObject().AddComponent<TextMeshProUGUI>();
                    textObject.rectTransform.SetParent(go.transform, false);

                    textObject.color = new Color32(255, 255, 0, 255);
                    textObject.alignment = TextAlignmentOptions.Bottom;
                    textObject.fontSize = 96;
                    textObject.text = "!";

                    // Spawn Floating Text
                    floatingText_Script = go.AddComponent<TextMeshProFloatingText>();
                    floatingText_Script.SpawnType = 0;
                }



            }
        }
    }
}


2.76 Текст программы «Benchmark03.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;
using UnityEngine.TextCore.LowLevel;


namespace TMPro.Examples
{

    public class Benchmark03 : MonoBehaviour
    {
        public enum BenchmarkType { TMP_SDF_MOBILE = 0, TMP_SDF__MOBILE_SSD = 1, TMP_SDF = 2, TMP_BITMAP_MOBILE = 3, TEXTMESH_BITMAP = 4 }

        public int NumberOfSamples = 100;
        public BenchmarkType Benchmark;

        public Font SourceFont;


        void Awake()
        {

        }


        void Start()
        {
            TMP_FontAsset fontAsset = null;

            // Create Dynamic Font Asset for the given font file.
            switch (Benchmark)
            {
                case BenchmarkType.TMP_SDF_MOBILE:
                    fontAsset = TMP_FontAsset.CreateFontAsset(SourceFont, 90, 9, GlyphRenderMode.SDFAA, 256, 256, AtlasPopulationMode.Dynamic);
                    break;
                case BenchmarkType.TMP_SDF__MOBILE_SSD:
                    fontAsset = TMP_FontAsset.CreateFontAsset(SourceFont, 90, 9, GlyphRenderMode.SDFAA, 256, 256, AtlasPopulationMode.Dynamic);
                    fontAsset.material.shader = Shader.Find("TextMeshPro/Mobile/Distance Field SSD");
                    break;
                case BenchmarkType.TMP_SDF:
                    fontAsset = TMP_FontAsset.CreateFontAsset(SourceFont, 90, 9, GlyphRenderMode.SDFAA, 256, 256, AtlasPopulationMode.Dynamic);
                    fontAsset.material.shader = Shader.Find("TextMeshPro/Distance Field");
                    break;
                case BenchmarkType.TMP_BITMAP_MOBILE:
                    fontAsset = TMP_FontAsset.CreateFontAsset(SourceFont, 90, 9, GlyphRenderMode.SMOOTH, 256, 256, AtlasPopulationMode.Dynamic);
                    break;
            }

            for (int i = 0; i < NumberOfSamples; i++)
            {
                switch (Benchmark)
                {
                    case BenchmarkType.TMP_SDF_MOBILE:
                    case BenchmarkType.TMP_SDF__MOBILE_SSD:
                    case BenchmarkType.TMP_SDF:
                    case BenchmarkType.TMP_BITMAP_MOBILE:
                        {
                            GameObject go = new GameObject();
                            go.transform.position = new Vector3(0, 1.2f, 0);

                            TextMeshPro textComponent = go.AddComponent<TextMeshPro>();
                            textComponent.font = fontAsset;
                            textComponent.fontSize = 128;
                            textComponent.text = "@";
                            textComponent.alignment = TextAlignmentOptions.Center;
                            textComponent.color = new Color32(255, 255, 0, 255);

                            if (Benchmark == BenchmarkType.TMP_BITMAP_MOBILE)
                                textComponent.fontSize = 132;

                        }
                        break;
                    case BenchmarkType.TEXTMESH_BITMAP:
                        {
                            GameObject go = new GameObject();
                            go.transform.position = new Vector3(0, 1.2f, 0);

                            TextMesh textMesh = go.AddComponent<TextMesh>();
                            textMesh.GetComponent<Renderer>().sharedMaterial = SourceFont.material;
                            textMesh.font = SourceFont;
                            textMesh.anchor = TextAnchor.MiddleCenter;
                            textMesh.fontSize = 130;

                            textMesh.color = new Color32(255, 255, 0, 255);
                            textMesh.text = "@";
                        }
                        break;
                }
            }
        }

    }
}


2.77 Текст программы «Benchmark04.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class Benchmark04 : MonoBehaviour
    {

        public int SpawnType = 0;

        public int MinPointSize = 12;
        public int MaxPointSize = 64;
        public int Steps = 4;

        private Transform m_Transform;
        //private TextMeshProFloatingText floatingText_Script;
        //public Material material;


        void Start()
        {
            m_Transform = transform;

            float lineHeight = 0;
            float orthoSize = Camera.main.orthographicSize = Screen.height / 2;
            float ratio = (float)Screen.width / Screen.height;

            for (int i = MinPointSize; i <= MaxPointSize; i += Steps)
            {
                if (SpawnType == 0)
                {
                    // TextMesh Pro Implementation
                    GameObject go = new GameObject("Text - " + i + " Pts");

                    if (lineHeight > orthoSize * 2) return;

                    go.transform.position = m_Transform.position + new Vector3(ratio * -orthoSize * 0.975f, orthoSize * 0.975f - lineHeight, 0);

                    TextMeshPro textMeshPro = go.AddComponent<TextMeshPro>();

                    //textMeshPro.fontSharedMaterial = material;
                    //textMeshPro.font = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(TextMeshProFont)) as TextMeshProFont;
                    //textMeshPro.anchor = AnchorPositions.Left;
                    textMeshPro.rectTransform.pivot = new Vector2(0, 0.5f);

                    textMeshPro.enableWordWrapping = false;
                    textMeshPro.extraPadding = true;
                    textMeshPro.isOrthographic = true;
                    textMeshPro.fontSize = i;

                    textMeshPro.text = i + " pts - Lorem ipsum dolor sit...";
                    textMeshPro.color = new Color32(255, 255, 255, 255);

                    lineHeight += i;
                }
                else
                {
                    // TextMesh Implementation
                    // Causes crashes since atlas needed exceeds 4096 X 4096
                    /*
                    GameObject go = new GameObject("Arial " + i);

                    //if (lineHeight > orthoSize * 2 * 0.9f) return;

                    go.transform.position = m_Transform.position + new Vector3(ratio * -orthoSize * 0.975f, orthoSize * 0.975f - lineHeight, 1);
                                       
                    TextMesh textMesh = go.AddComponent<TextMesh>();
                    textMesh.font = Resources.Load("Fonts/ARIAL", typeof(Font)) as Font;
                    textMesh.renderer.sharedMaterial = textMesh.font.material;
                    textMesh.anchor = TextAnchor.MiddleLeft;
                    textMesh.fontSize = i * 10;

                    textMesh.color = new Color32(255, 255, 255, 255);
                    textMesh.text = i + " pts - Lorem ipsum dolor sit...";

                    lineHeight += i;
                    */
                }
            }
        }

    }
}


2.78 Текст программы «CameraController.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class CameraController : MonoBehaviour
    {
        public enum CameraModes { Follow, Isometric, Free }

        private Transform cameraTransform;
        private Transform dummyTarget;

        public Transform CameraTarget;

        public float FollowDistance = 30.0f;
        public float MaxFollowDistance = 100.0f;
        public float MinFollowDistance = 2.0f;

        public float ElevationAngle = 30.0f;
        public float MaxElevationAngle = 85.0f;
        public float MinElevationAngle = 0f;

        public float OrbitalAngle = 0f;

        public CameraModes CameraMode = CameraModes.Follow;

        public bool MovementSmoothing = true;
        public bool RotationSmoothing = false;
        private bool previousSmoothing;

        public float MovementSmoothingValue = 25f;
        public float RotationSmoothingValue = 5.0f;

        public float MoveSensitivity = 2.0f;

        private Vector3 currentVelocity = Vector3.zero;
        private Vector3 desiredPosition;
        private float mouseX;
        private float mouseY;
        private Vector3 moveVector;
        private float mouseWheel;

        // Controls for Touches on Mobile devices
        //private float prev_ZoomDelta;


        private const string event_SmoothingValue = "Slider - Smoothing Value";
        private const string event_FollowDistance = "Slider - Camera Zoom";


        void Awake()
        {
            if (QualitySettings.vSyncCount > 0)
                Application.targetFrameRate = 60;
            else
                Application.targetFrameRate = -1;

            if (Application.platform == RuntimePlatform.IPhonePlayer || Application.platform == RuntimePlatform.Android)
                Input.simulateMouseWithTouches = false;

            cameraTransform = transform;
            previousSmoothing = MovementSmoothing;
        }


        // Use this for initialization
        void Start()
        {
            if (CameraTarget == null)
            {
                // If we don't have a target (assigned by the player, create a dummy in the center of the scene).
                dummyTarget = new GameObject("Camera Target").transform;
                CameraTarget = dummyTarget;
            }
        }

        // Update is called once per frame
        void LateUpdate()
        {
            GetPlayerInput();


            // Check if we still have a valid target
            if (CameraTarget != null)
            {
                if (CameraMode == CameraModes.Isometric)
                {
                    desiredPosition = CameraTarget.position + Quaternion.Euler(ElevationAngle, OrbitalAngle, 0f) * new Vector3(0, 0, -FollowDistance);
                }
                else if (CameraMode == CameraModes.Follow)
                {
                    desiredPosition = CameraTarget.position + CameraTarget.TransformDirection(Quaternion.Euler(ElevationAngle, OrbitalAngle, 0f) * (new Vector3(0, 0, -FollowDistance)));
                }
                else
                {
                    // Free Camera implementation
                }

                if (MovementSmoothing == true)
                {
                    // Using Smoothing
                    cameraTransform.position = Vector3.SmoothDamp(cameraTransform.position, desiredPosition, ref currentVelocity, MovementSmoothingValue * Time.fixedDeltaTime);
                    //cameraTransform.position = Vector3.Lerp(cameraTransform.position, desiredPosition, Time.deltaTime * 5.0f);
                }
                else
                {
                    // Not using Smoothing
                    cameraTransform.position = desiredPosition;
                }

                if (RotationSmoothing == true)
                    cameraTransform.rotation = Quaternion.Lerp(cameraTransform.rotation, Quaternion.LookRotation(CameraTarget.position - cameraTransform.position), RotationSmoothingValue * Time.deltaTime);
                else
                {
                    cameraTransform.LookAt(CameraTarget);
                }

            }

        }



        void GetPlayerInput()
        {
            moveVector = Vector3.zero;

            // Check Mouse Wheel Input prior to Shift Key so we can apply multiplier on Shift for Scrolling
            mouseWheel = Input.GetAxis("Mouse ScrollWheel");

            float touchCount = Input.touchCount;

            if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift) || touchCount > 0)
            {
                mouseWheel *= 10;

                if (Input.GetKeyDown(KeyCode.I))
                    CameraMode = CameraModes.Isometric;

                if (Input.GetKeyDown(KeyCode.F))
                    CameraMode = CameraModes.Follow;

                if (Input.GetKeyDown(KeyCode.S))
                    MovementSmoothing = !MovementSmoothing;


                // Check for right mouse button to change camera follow and elevation angle
                if (Input.GetMouseButton(1))
                {
                    mouseY = Input.GetAxis("Mouse Y");
                    mouseX = Input.GetAxis("Mouse X");

                    if (mouseY > 0.01f || mouseY < -0.01f)
                    {
                        ElevationAngle -= mouseY * MoveSensitivity;
                        // Limit Elevation angle between min & max values.
                        ElevationAngle = Mathf.Clamp(ElevationAngle, MinElevationAngle, MaxElevationAngle);
                    }

                    if (mouseX > 0.01f || mouseX < -0.01f)
                    {
                        OrbitalAngle += mouseX * MoveSensitivity;
                        if (OrbitalAngle > 360)
                            OrbitalAngle -= 360;
                        if (OrbitalAngle < 0)
                            OrbitalAngle += 360;
                    }
                }

                // Get Input from Mobile Device
                if (touchCount == 1 && Input.GetTouch(0).phase == TouchPhase.Moved)
                {
                    Vector2 deltaPosition = Input.GetTouch(0).deltaPosition;

                    // Handle elevation changes
                    if (deltaPosition.y > 0.01f || deltaPosition.y < -0.01f)
                    {
                        ElevationAngle -= deltaPosition.y * 0.1f;
                        // Limit Elevation angle between min & max values.
                        ElevationAngle = Mathf.Clamp(ElevationAngle, MinElevationAngle, MaxElevationAngle);
                    }


                    // Handle left & right 
                    if (deltaPosition.x > 0.01f || deltaPosition.x < -0.01f)
                    {
                        OrbitalAngle += deltaPosition.x * 0.1f;
                        if (OrbitalAngle > 360)
                            OrbitalAngle -= 360;
                        if (OrbitalAngle < 0)
                            OrbitalAngle += 360;
                    }

                }

                // Check for left mouse button to select a new CameraTarget or to reset Follow position
                if (Input.GetMouseButton(0))
                {
                    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
                    RaycastHit hit;

                    if (Physics.Raycast(ray, out hit, 300, 1 << 10 | 1 << 11 | 1 << 12 | 1 << 14))
                    {
                        if (hit.transform == CameraTarget)
                        {
                            // Reset Follow Position
                            OrbitalAngle = 0;
                        }
                        else
                        {
                            CameraTarget = hit.transform;
                            OrbitalAngle = 0;
                            MovementSmoothing = previousSmoothing;
                        }

                    }
                }


                if (Input.GetMouseButton(2))
                {
                    if (dummyTarget == null)
                    {
                        // We need a Dummy Target to anchor the Camera
                        dummyTarget = new GameObject("Camera Target").transform;
                        dummyTarget.position = CameraTarget.position;
                        dummyTarget.rotation = CameraTarget.rotation;
                        CameraTarget = dummyTarget;
                        previousSmoothing = MovementSmoothing;
                        MovementSmoothing = false;
                    }
                    else if (dummyTarget != CameraTarget)
                    {
                        // Move DummyTarget to CameraTarget
                        dummyTarget.position = CameraTarget.position;
                        dummyTarget.rotation = CameraTarget.rotation;
                        CameraTarget = dummyTarget;
                        previousSmoothing = MovementSmoothing;
                        MovementSmoothing = false;
                    }


                    mouseY = Input.GetAxis("Mouse Y");
                    mouseX = Input.GetAxis("Mouse X");

                    moveVector = cameraTransform.TransformDirection(mouseX, mouseY, 0);

                    dummyTarget.Translate(-moveVector, Space.World);

                }

            }

            // Check Pinching to Zoom in - out on Mobile device
            if (touchCount == 2)
            {
                Touch touch0 = Input.GetTouch(0);
                Touch touch1 = Input.GetTouch(1);

                Vector2 touch0PrevPos = touch0.position - touch0.deltaPosition;
                Vector2 touch1PrevPos = touch1.position - touch1.deltaPosition;

                float prevTouchDelta = (touch0PrevPos - touch1PrevPos).magnitude;
                float touchDelta = (touch0.position - touch1.position).magnitude;

                float zoomDelta = prevTouchDelta - touchDelta;

                if (zoomDelta > 0.01f || zoomDelta < -0.01f)
                {
                    FollowDistance += zoomDelta * 0.25f;
                    // Limit FollowDistance between min & max values.
                    FollowDistance = Mathf.Clamp(FollowDistance, MinFollowDistance, MaxFollowDistance);
                }


            }

            // Check MouseWheel to Zoom in-out
            if (mouseWheel < -0.01f || mouseWheel > 0.01f)
            {

                FollowDistance -= mouseWheel * 5.0f;
                // Limit FollowDistance between min & max values.
                FollowDistance = Mathf.Clamp(FollowDistance, MinFollowDistance, MaxFollowDistance);
            }


        }
    }
}

2.79 Текст программы «ChatController.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class ChatController : MonoBehaviour {


    public TMP_InputField ChatInputField;

    public TMP_Text ChatDisplayOutput;

    public Scrollbar ChatScrollbar;

    void OnEnable()
    {
        ChatInputField.onSubmit.AddListener(AddToChatOutput);
    }

    void OnDisable()
    {
        ChatInputField.onSubmit.RemoveListener(AddToChatOutput);
    }


    void AddToChatOutput(string newText)
    {
        // Clear Input Field
        ChatInputField.text = string.Empty;

        var timeNow = System.DateTime.Now;

        string formattedInput = "[<#FFFF80>" + timeNow.Hour.ToString("d2") + ":" + timeNow.Minute.ToString("d2") + ":" + timeNow.Second.ToString("d2") + "</color>] " + newText;

        if (ChatDisplayOutput != null)
        {
            // No special formatting for first entry
            // Add line feed before each subsequent entries
            if (ChatDisplayOutput.text == string.Empty)
                ChatDisplayOutput.text = formattedInput;
            else
                ChatDisplayOutput.text += "\n" + formattedInput;
        }

        // Keep Chat input field active
        ChatInputField.ActivateInputField();

        // Set the scrollbar to the bottom when next text is submitted.
        ChatScrollbar.value = 0;
    }

}


2.80 Текст программы «DropdownSample.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using TMPro;
using UnityEngine;

public class DropdownSample: MonoBehaviour
{
	[SerializeField]
	private TextMeshProUGUI text = null;

	[SerializeField]
	private TMP_Dropdown dropdownWithoutPlaceholder = null;

	[SerializeField]
	private TMP_Dropdown dropdownWithPlaceholder = null;

	public void OnButtonClick()
	{
		text.text = dropdownWithPlaceholder.value > -1 ? "Selected values:\n" + dropdownWithoutPlaceholder.value + " - " + dropdownWithPlaceholder.value : "Error: Please make a selection";
	}
}


2.81 Текст программы «EnvMapAnimator.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;
using TMPro;

public class EnvMapAnimator : MonoBehaviour {

    //private Vector3 TranslationSpeeds;
    public Vector3 RotationSpeeds;
    private TMP_Text m_textMeshPro;
    private Material m_material;
    

    void Awake()
    {
        //Debug.Log("Awake() on Script called.");
        m_textMeshPro = GetComponent<TMP_Text>();
        m_material = m_textMeshPro.fontSharedMaterial;
    }

    // Use this for initialization
	IEnumerator Start ()
    {
        Matrix4x4 matrix = new Matrix4x4(); 
        
        while (true)
        {
            //matrix.SetTRS(new Vector3 (Time.time * TranslationSpeeds.x, Time.time * TranslationSpeeds.y, Time.time * TranslationSpeeds.z), Quaternion.Euler(Time.time * RotationSpeeds.x, Time.time * RotationSpeeds.y , Time.time * RotationSpeeds.z), Vector3.one);
             matrix.SetTRS(Vector3.zero, Quaternion.Euler(Time.time * RotationSpeeds.x, Time.time * RotationSpeeds.y , Time.time * RotationSpeeds.z), Vector3.one);

            m_material.SetMatrix("_EnvMatrix", matrix);

            yield return null;
        }
	}
}


2.82 Текст программы «ObjectSpin.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class ObjectSpin : MonoBehaviour
    {

#pragma warning disable 0414

        public float SpinSpeed = 5;
        public int RotationRange = 15;
        private Transform m_transform;

        private float m_time;
        private Vector3 m_prevPOS;
        private Vector3 m_initial_Rotation;
        private Vector3 m_initial_Position;
        private Color32 m_lightColor;
        private int frames = 0;

        public enum MotionType { Rotation, BackAndForth, Translation };
        public MotionType Motion;

        void Awake()
        {
            m_transform = transform;
            m_initial_Rotation = m_transform.rotation.eulerAngles;
            m_initial_Position = m_transform.position;

            Light light = GetComponent<Light>();
            m_lightColor = light != null ? light.color : Color.black;
        }


        // Update is called once per frame
        void Update()
        {
            if (Motion == MotionType.Rotation)
            {
                m_transform.Rotate(0, SpinSpeed * Time.deltaTime, 0);
            }
            else if (Motion == MotionType.BackAndForth)
            {
                m_time += SpinSpeed * Time.deltaTime;
                m_transform.rotation = Quaternion.Euler(m_initial_Rotation.x, Mathf.Sin(m_time) * RotationRange + m_initial_Rotation.y, m_initial_Rotation.z);
            }
            else
            {
                m_time += SpinSpeed * Time.deltaTime;

                float x = 15 * Mathf.Cos(m_time * .95f);
                float y = 10; // *Mathf.Sin(m_time * 1f) * Mathf.Cos(m_time * 1f);
                float z = 0f; // *Mathf.Sin(m_time * .9f);    

                m_transform.position = m_initial_Position + new Vector3(x, z, y);

                // Drawing light patterns because they can be cool looking.
                //if (frames > 2)
                //    Debug.DrawLine(m_transform.position, m_prevPOS, m_lightColor, 100f);

                m_prevPOS = m_transform.position;
                frames += 1;
            }
        }
    }
}

2.83 Текст программы «ShaderPropAnimator.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class ShaderPropAnimator : MonoBehaviour
    {

        private Renderer m_Renderer;
        private Material m_Material;

        public AnimationCurve GlowCurve;

        public float m_frame;

        void Awake()
        {
            // Cache a reference to object's renderer
            m_Renderer = GetComponent<Renderer>();

            // Cache a reference to object's material and create an instance by doing so.
            m_Material = m_Renderer.material;
        }

        void Start()
        {
            StartCoroutine(AnimateProperties());
        }

        IEnumerator AnimateProperties()
        {
            //float lightAngle;
            float glowPower;
            m_frame = Random.Range(0f, 1f);

            while (true)
            {
                //lightAngle = (m_Material.GetFloat(ShaderPropertyIDs.ID_LightAngle) + Time.deltaTime) % 6.2831853f;
                //m_Material.SetFloat(ShaderPropertyIDs.ID_LightAngle, lightAngle);

                glowPower = GlowCurve.Evaluate(m_frame);
                m_Material.SetFloat(ShaderUtilities.ID_GlowPower, glowPower);

                m_frame += Time.deltaTime * Random.Range(0.2f, 0.3f);
                yield return new WaitForEndOfFrame();
            }
        }
    }
}


2.84 Текст программы «SimpleScript.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class SimpleScript : MonoBehaviour
    {

        private TextMeshPro m_textMeshPro;
        //private TMP_FontAsset m_FontAsset;

        private const string label = "The <#0050FF>count is: </color>{0:2}";
        private float m_frame;


        void Start()
        {
            // Add new TextMesh Pro Component
            m_textMeshPro = gameObject.AddComponent<TextMeshPro>();

            m_textMeshPro.autoSizeTextContainer = true;

            // Load the Font Asset to be used.
            //m_FontAsset = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(TMP_FontAsset)) as TMP_FontAsset;
            //m_textMeshPro.font = m_FontAsset;

            // Assign Material to TextMesh Pro Component
            //m_textMeshPro.fontSharedMaterial = Resources.Load("Fonts & Materials/LiberationSans SDF - Bevel", typeof(Material)) as Material;
            //m_textMeshPro.fontSharedMaterial.EnableKeyword("BEVEL_ON");
            
            // Set various font settings.
            m_textMeshPro.fontSize = 48;

            m_textMeshPro.alignment = TextAlignmentOptions.Center;
            
            //m_textMeshPro.anchorDampening = true; // Has been deprecated but under consideration for re-implementation.
            //m_textMeshPro.enableAutoSizing = true;

            //m_textMeshPro.characterSpacing = 0.2f;
            //m_textMeshPro.wordSpacing = 0.1f;

            //m_textMeshPro.enableCulling = true;
            m_textMeshPro.enableWordWrapping = false;

            //textMeshPro.fontColor = new Color32(255, 255, 255, 255);
        }


        void Update()
        {
            m_textMeshPro.SetText(label, m_frame % 1000);
            m_frame += 1 * Time.deltaTime;
        }

    }
}


2.85 Текст программы «SkewTextExample.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{

    public class SkewTextExample : MonoBehaviour
    {

        private TMP_Text m_TextComponent;

        public AnimationCurve VertexCurve = new AnimationCurve(new Keyframe(0, 0), new Keyframe(0.25f, 2.0f), new Keyframe(0.5f, 0), new Keyframe(0.75f, 2.0f), new Keyframe(1, 0f));
        //public float AngleMultiplier = 1.0f;
        //public float SpeedMultiplier = 1.0f;
        public float CurveScale = 1.0f;
        public float ShearAmount = 1.0f;

        void Awake()
        {
            m_TextComponent = gameObject.GetComponent<TMP_Text>();
        }


        void Start()
        {
            StartCoroutine(WarpText());
        }


        private AnimationCurve CopyAnimationCurve(AnimationCurve curve)
        {
            AnimationCurve newCurve = new AnimationCurve();

            newCurve.keys = curve.keys;

            return newCurve;
        }


        /// <summary>
        ///  Method to curve text along a Unity animation curve.
        /// </summary>
        /// <param name="textComponent"></param>
        /// <returns></returns>
        IEnumerator WarpText()
        {
            VertexCurve.preWrapMode = WrapMode.Clamp;
            VertexCurve.postWrapMode = WrapMode.Clamp;

            //Mesh mesh = m_TextComponent.textInfo.meshInfo[0].mesh;

            Vector3[] vertices;
            Matrix4x4 matrix;

            m_TextComponent.havePropertiesChanged = true; // Need to force the TextMeshPro Object to be updated.
            CurveScale *= 10;
            float old_CurveScale = CurveScale;
            float old_ShearValue = ShearAmount;
            AnimationCurve old_curve = CopyAnimationCurve(VertexCurve);

            while (true)
            {
                if (!m_TextComponent.havePropertiesChanged && old_CurveScale == CurveScale && old_curve.keys[1].value == VertexCurve.keys[1].value && old_ShearValue == ShearAmount)
                {
                    yield return null;
                    continue;
                }

                old_CurveScale = CurveScale;
                old_curve = CopyAnimationCurve(VertexCurve);
                old_ShearValue = ShearAmount;

                m_TextComponent.ForceMeshUpdate(); // Generate the mesh and populate the textInfo with data we can use and manipulate.

                TMP_TextInfo textInfo = m_TextComponent.textInfo;
                int characterCount = textInfo.characterCount;


                if (characterCount == 0) continue;

                //vertices = textInfo.meshInfo[0].vertices;
                //int lastVertexIndex = textInfo.characterInfo[characterCount - 1].vertexIndex;

                float boundsMinX = m_TextComponent.bounds.min.x;  //textInfo.meshInfo[0].mesh.bounds.min.x;
                float boundsMaxX = m_TextComponent.bounds.max.x;  //textInfo.meshInfo[0].mesh.bounds.max.x;



                for (int i = 0; i < characterCount; i++)
                {
                    if (!textInfo.characterInfo[i].isVisible)
                        continue;

                    int vertexIndex = textInfo.characterInfo[i].vertexIndex;

                    // Get the index of the mesh used by this character.
                    int materialIndex = textInfo.characterInfo[i].materialReferenceIndex;

                    vertices = textInfo.meshInfo[materialIndex].vertices;

                    // Compute the baseline mid point for each character
                    Vector3 offsetToMidBaseline = new Vector2((vertices[vertexIndex + 0].x + vertices[vertexIndex + 2].x) / 2, textInfo.characterInfo[i].baseLine);
                    //float offsetY = VertexCurve.Evaluate((float)i / characterCount + loopCount / 50f); // Random.Range(-0.25f, 0.25f);

                    // Apply offset to adjust our pivot point.
                    vertices[vertexIndex + 0] += -offsetToMidBaseline;
                    vertices[vertexIndex + 1] += -offsetToMidBaseline;
                    vertices[vertexIndex + 2] += -offsetToMidBaseline;
                    vertices[vertexIndex + 3] += -offsetToMidBaseline;

                    // Apply the Shearing FX
                    float shear_value = ShearAmount * 0.01f;
                    Vector3 topShear = new Vector3(shear_value * (textInfo.characterInfo[i].topRight.y - textInfo.characterInfo[i].baseLine), 0, 0);
                    Vector3 bottomShear = new Vector3(shear_value * (textInfo.characterInfo[i].baseLine - textInfo.characterInfo[i].bottomRight.y), 0, 0);

                    vertices[vertexIndex + 0] += -bottomShear;
                    vertices[vertexIndex + 1] += topShear;
                    vertices[vertexIndex + 2] += topShear;
                    vertices[vertexIndex + 3] += -bottomShear;


                    // Compute the angle of rotation for each character based on the animation curve
                    float x0 = (offsetToMidBaseline.x - boundsMinX) / (boundsMaxX - boundsMinX); // Character's position relative to the bounds of the mesh.
                    float x1 = x0 + 0.0001f;
                    float y0 = VertexCurve.Evaluate(x0) * CurveScale;
                    float y1 = VertexCurve.Evaluate(x1) * CurveScale;

                    Vector3 horizontal = new Vector3(1, 0, 0);
                    //Vector3 normal = new Vector3(-(y1 - y0), (x1 * (boundsMaxX - boundsMinX) + boundsMinX) - offsetToMidBaseline.x, 0);
                    Vector3 tangent = new Vector3(x1 * (boundsMaxX - boundsMinX) + boundsMinX, y1) - new Vector3(offsetToMidBaseline.x, y0);

                    float dot = Mathf.Acos(Vector3.Dot(horizontal, tangent.normalized)) * 57.2957795f;
                    Vector3 cross = Vector3.Cross(horizontal, tangent);
                    float angle = cross.z > 0 ? dot : 360 - dot;

                    matrix = Matrix4x4.TRS(new Vector3(0, y0, 0), Quaternion.Euler(0, 0, angle), Vector3.one);

                    vertices[vertexIndex + 0] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 0]);
                    vertices[vertexIndex + 1] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 1]);
                    vertices[vertexIndex + 2] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 2]);
                    vertices[vertexIndex + 3] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 3]);

                    vertices[vertexIndex + 0] += offsetToMidBaseline;
                    vertices[vertexIndex + 1] += offsetToMidBaseline;
                    vertices[vertexIndex + 2] += offsetToMidBaseline;
                    vertices[vertexIndex + 3] += offsetToMidBaseline;
                }


                // Upload the mesh with the revised information
                m_TextComponent.UpdateVertexData();

                yield return null; // new WaitForSeconds(0.025f);
            }
        }
    }
}


2.86 Текст программы «TeleType.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class TeleType : MonoBehaviour
    {


        //[Range(0, 100)]
        //public int RevealSpeed = 50;

        private string label01 = "Example <sprite=2> of using <sprite=7> <#ffa000>Graphics Inline</color> <sprite=5> with Text in <font=\"Bangers SDF\" material=\"Bangers SDF - Drop Shadow\">TextMesh<#40a0ff>Pro</color></font><sprite=0> and Unity<sprite=1>";
        private string label02 = "Example <sprite=2> of using <sprite=7> <#ffa000>Graphics Inline</color> <sprite=5> with Text in <font=\"Bangers SDF\" material=\"Bangers SDF - Drop Shadow\">TextMesh<#40a0ff>Pro</color></font><sprite=0> and Unity<sprite=2>";


        private TMP_Text m_textMeshPro;


        void Awake()
        {
            // Get Reference to TextMeshPro Component
            m_textMeshPro = GetComponent<TMP_Text>();
            m_textMeshPro.text = label01;
            m_textMeshPro.enableWordWrapping = true;
            m_textMeshPro.alignment = TextAlignmentOptions.Top;



            //if (GetComponentInParent(typeof(Canvas)) as Canvas == null)
            //{
            //    GameObject canvas = new GameObject("Canvas", typeof(Canvas));
            //    gameObject.transform.SetParent(canvas.transform);
            //    canvas.GetComponent<Canvas>().renderMode = RenderMode.ScreenSpaceOverlay;

            //    // Set RectTransform Size
            //    gameObject.GetComponent<RectTransform>().sizeDelta = new Vector2(500, 300);
            //    m_textMeshPro.fontSize = 48;
            //}


        }


        IEnumerator Start()
        {

            // Force and update of the mesh to get valid information.
            m_textMeshPro.ForceMeshUpdate();


            int totalVisibleCharacters = m_textMeshPro.textInfo.characterCount; // Get # of Visible Character in text object
            int counter = 0;
            int visibleCount = 0;

            while (true)
            {
                visibleCount = counter % (totalVisibleCharacters + 1);

                m_textMeshPro.maxVisibleCharacters = visibleCount; // How many characters should TextMeshPro display?

                // Once the last character has been revealed, wait 1.0 second and start over.
                if (visibleCount >= totalVisibleCharacters)
                {
                    yield return new WaitForSeconds(1.0f);
                    m_textMeshPro.text = label02;
                    yield return new WaitForSeconds(1.0f);
                    m_textMeshPro.text = label01;
                    yield return new WaitForSeconds(1.0f);
                }

                counter += 1;

                yield return new WaitForSeconds(0.05f);
            }

            //Debug.Log("Done revealing the text.");
        }

    }
}

2.87 Текст программы «TextConsoleSimulator.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    public class TextConsoleSimulator : MonoBehaviour
    {
        private TMP_Text m_TextComponent;
        private bool hasTextChanged;

        void Awake()
        {
            m_TextComponent = gameObject.GetComponent<TMP_Text>();
        }


        void Start()
        {
            StartCoroutine(RevealCharacters(m_TextComponent));
            //StartCoroutine(RevealWords(m_TextComponent));
        }


        void OnEnable()
        {
            // Subscribe to event fired when text object has been regenerated.
            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
        }

        void OnDisable()
        {
            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
        }


        // Event received when the text object has changed.
        void ON_TEXT_CHANGED(Object obj)
        {
            hasTextChanged = true;
        }


        /// <summary>
        /// Method revealing the text one character at a time.
        /// </summary>
        /// <returns></returns>
        IEnumerator RevealCharacters(TMP_Text textComponent)
        {
            textComponent.ForceMeshUpdate();

            TMP_TextInfo textInfo = textComponent.textInfo;

            int totalVisibleCharacters = textInfo.characterCount; // Get # of Visible Character in text object
            int visibleCount = 0;

            while (true)
            {
                if (hasTextChanged)
                {
                    totalVisibleCharacters = textInfo.characterCount; // Update visible character count.
                    hasTextChanged = false; 
                }

                if (visibleCount > totalVisibleCharacters)
                {
                    yield return new WaitForSeconds(1.0f);
                    visibleCount = 0;
                }

                textComponent.maxVisibleCharacters = visibleCount; // How many characters should TextMeshPro display?

                visibleCount += 1;

                yield return null;
            }
        }


        /// <summary>
        /// Method revealing the text one word at a time.
        /// </summary>
        /// <returns></returns>
        IEnumerator RevealWords(TMP_Text textComponent)
        {
            textComponent.ForceMeshUpdate();

            int totalWordCount = textComponent.textInfo.wordCount;
            int totalVisibleCharacters = textComponent.textInfo.characterCount; // Get # of Visible Character in text object
            int counter = 0;
            int currentWord = 0;
            int visibleCount = 0;

            while (true)
            {
                currentWord = counter % (totalWordCount + 1);

                // Get last character index for the current word.
                if (currentWord == 0) // Display no words.
                    visibleCount = 0;
                else if (currentWord < totalWordCount) // Display all other words with the exception of the last one.
                    visibleCount = textComponent.textInfo.wordInfo[currentWord - 1].lastCharacterIndex + 1;
                else if (currentWord == totalWordCount) // Display last word and all remaining characters.
                    visibleCount = totalVisibleCharacters;

                textComponent.maxVisibleCharacters = visibleCount; // How many characters should TextMeshPro display?

                // Once the last character has been revealed, wait 1.0 second and start over.
                if (visibleCount >= totalVisibleCharacters)
                {
                    yield return new WaitForSeconds(1.0f);
                }

                counter += 1;

                yield return new WaitForSeconds(0.1f);
            }
        }

    }
}

2.88 Текст программы «TextMeshProFloatingText.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{

    public class TextMeshProFloatingText : MonoBehaviour
    {
        public Font TheFont;

        private GameObject m_floatingText;
        private TextMeshPro m_textMeshPro;
        private TextMesh m_textMesh;

        private Transform m_transform;
        private Transform m_floatingText_Transform;
        private Transform m_cameraTransform;

        Vector3 lastPOS = Vector3.zero;
        Quaternion lastRotation = Quaternion.identity;

        public int SpawnType;
        public bool IsTextObjectScaleStatic;

        //private int m_frame = 0;

        static WaitForEndOfFrame k_WaitForEndOfFrame = new WaitForEndOfFrame();
        static WaitForSeconds[] k_WaitForSecondsRandom = new WaitForSeconds[]
        {
            new WaitForSeconds(0.05f), new WaitForSeconds(0.1f), new WaitForSeconds(0.15f), new WaitForSeconds(0.2f), new WaitForSeconds(0.25f),
            new WaitForSeconds(0.3f), new WaitForSeconds(0.35f), new WaitForSeconds(0.4f), new WaitForSeconds(0.45f), new WaitForSeconds(0.5f),
            new WaitForSeconds(0.55f), new WaitForSeconds(0.6f), new WaitForSeconds(0.65f), new WaitForSeconds(0.7f), new WaitForSeconds(0.75f),
            new WaitForSeconds(0.8f), new WaitForSeconds(0.85f), new WaitForSeconds(0.9f), new WaitForSeconds(0.95f), new WaitForSeconds(1.0f),
        };

        void Awake()
        {
            m_transform = transform;
            m_floatingText = new GameObject(this.name + " floating text");

            // Reference to Transform is lost when TMP component is added since it replaces it by a RectTransform.
            //m_floatingText_Transform = m_floatingText.transform;
            //m_floatingText_Transform.position = m_transform.position + new Vector3(0, 15f, 0);

            m_cameraTransform = Camera.main.transform;
        }

        void Start()
        {
            if (SpawnType == 0)
            {
                // TextMesh Pro Implementation
                m_textMeshPro = m_floatingText.AddComponent<TextMeshPro>();
                m_textMeshPro.rectTransform.sizeDelta = new Vector2(3, 3);

                m_floatingText_Transform = m_floatingText.transform;
                m_floatingText_Transform.position = m_transform.position + new Vector3(0, 15f, 0);

                //m_textMeshPro.fontAsset = Resources.Load("Fonts & Materials/JOKERMAN SDF", typeof(TextMeshProFont)) as TextMeshProFont; // User should only provide a string to the resource.
                //m_textMeshPro.fontSharedMaterial = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(Material)) as Material;

                m_textMeshPro.alignment = TextAlignmentOptions.Center;
                m_textMeshPro.color = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255);
                m_textMeshPro.fontSize = 24;
                //m_textMeshPro.enableExtraPadding = true;
                //m_textMeshPro.enableShadows = false;
                m_textMeshPro.enableKerning = false;
                m_textMeshPro.text = string.Empty;
                m_textMeshPro.isTextObjectScaleStatic = IsTextObjectScaleStatic;

                StartCoroutine(DisplayTextMeshProFloatingText());
            }
            else if (SpawnType == 1)
            {
                //Debug.Log("Spawning TextMesh Objects.");

                m_floatingText_Transform = m_floatingText.transform;
                m_floatingText_Transform.position = m_transform.position + new Vector3(0, 15f, 0);

                m_textMesh = m_floatingText.AddComponent<TextMesh>();
                m_textMesh.font = Resources.Load<Font>("Fonts/ARIAL");
                m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material;
                m_textMesh.color = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255);
                m_textMesh.anchor = TextAnchor.LowerCenter;
                m_textMesh.fontSize = 24;

                StartCoroutine(DisplayTextMeshFloatingText());
            }
            else if (SpawnType == 2)
            {

            }

        }


        //void Update()
        //{
        //    if (SpawnType == 0)
        //    {
        //        m_textMeshPro.SetText("{0}", m_frame);
        //    }
        //    else
        //    {
        //        m_textMesh.text = m_frame.ToString();
        //    }
        //    m_frame = (m_frame + 1) % 1000;

        //}


        public IEnumerator DisplayTextMeshProFloatingText()
        {
            float CountDuration = 2.0f; // How long is the countdown alive.
            float starting_Count = Random.Range(5f, 20f); // At what number is the counter starting at.
            float current_Count = starting_Count;

            Vector3 start_pos = m_floatingText_Transform.position;
            Color32 start_color = m_textMeshPro.color;
            float alpha = 255;
            int int_counter = 0;


            float fadeDuration = 3 / starting_Count * CountDuration;

            while (current_Count > 0)
            {
                current_Count -= (Time.deltaTime / CountDuration) * starting_Count;

                if (current_Count <= 3)
                {
                    //Debug.Log("Fading Counter ... " + current_Count.ToString("f2"));
                    alpha = Mathf.Clamp(alpha - (Time.deltaTime / fadeDuration) * 255, 0, 255);
                }

                int_counter = (int)current_Count;
                m_textMeshPro.text = int_counter.ToString();
                //m_textMeshPro.SetText("{0}", (int)current_Count);

                m_textMeshPro.color = new Color32(start_color.r, start_color.g, start_color.b, (byte)alpha);

                // Move the floating text upward each update
                m_floatingText_Transform.position += new Vector3(0, starting_Count * Time.deltaTime, 0);

                // Align floating text perpendicular to Camera.
                if (!lastPOS.Compare(m_cameraTransform.position, 1000) || !lastRotation.Compare(m_cameraTransform.rotation, 1000))
                {
                    lastPOS = m_cameraTransform.position;
                    lastRotation = m_cameraTransform.rotation;
                    m_floatingText_Transform.rotation = lastRotation;
                    Vector3 dir = m_transform.position - lastPOS;
                    m_transform.forward = new Vector3(dir.x, 0, dir.z);
                }

                yield return k_WaitForEndOfFrame;
            }

            //Debug.Log("Done Counting down.");

            yield return k_WaitForSecondsRandom[Random.Range(0, 19)];

            m_floatingText_Transform.position = start_pos;

            StartCoroutine(DisplayTextMeshProFloatingText());
        }


        public IEnumerator DisplayTextMeshFloatingText()
        {
            float CountDuration = 2.0f; // How long is the countdown alive.
            float starting_Count = Random.Range(5f, 20f); // At what number is the counter starting at.
            float current_Count = starting_Count;

            Vector3 start_pos = m_floatingText_Transform.position;
            Color32 start_color = m_textMesh.color;
            float alpha = 255;
            int int_counter = 0;

            float fadeDuration = 3 / starting_Count * CountDuration;

            while (current_Count > 0)
            {
                current_Count -= (Time.deltaTime / CountDuration) * starting_Count;

                if (current_Count <= 3)
                {
                    //Debug.Log("Fading Counter ... " + current_Count.ToString("f2"));
                    alpha = Mathf.Clamp(alpha - (Time.deltaTime / fadeDuration) * 255, 0, 255);
                }

                int_counter = (int)current_Count;
                m_textMesh.text = int_counter.ToString();
                //Debug.Log("Current Count:" + current_Count.ToString("f2"));

                m_textMesh.color = new Color32(start_color.r, start_color.g, start_color.b, (byte)alpha);

                // Move the floating text upward each update
                m_floatingText_Transform.position += new Vector3(0, starting_Count * Time.deltaTime, 0);

                // Align floating text perpendicular to Camera.
                if (!lastPOS.Compare(m_cameraTransform.position, 1000) || !lastRotation.Compare(m_cameraTransform.rotation, 1000))
                {
                    lastPOS = m_cameraTransform.position;
                    lastRotation = m_cameraTransform.rotation;
                    m_floatingText_Transform.rotation = lastRotation;
                    Vector3 dir = m_transform.position - lastPOS;
                    m_transform.forward = new Vector3(dir.x, 0, dir.z);
                }

                yield return k_WaitForEndOfFrame;
            }

            //Debug.Log("Done Counting down.");

            yield return k_WaitForSecondsRandom[Random.Range(0, 20)];

            m_floatingText_Transform.position = start_pos;

            StartCoroutine(DisplayTextMeshFloatingText());
        }
    }
}


2.89 Текст программы «TextMeshSpawner.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class TextMeshSpawner : MonoBehaviour
    {

        public int SpawnType = 0;
        public int NumberOfNPC = 12;

        public Font TheFont;

        private TextMeshProFloatingText floatingText_Script;

        void Awake()
        {

        }

        void Start()
        {

            for (int i = 0; i < NumberOfNPC; i++)
            {
                if (SpawnType == 0)
                {
                    // TextMesh Pro Implementation     
                    //go.transform.localScale = new Vector3(2, 2, 2);
                    GameObject go = new GameObject(); //"NPC " + i);
                    go.transform.position = new Vector3(Random.Range(-95f, 95f), 0.5f, Random.Range(-95f, 95f));

                    //go.transform.position = new Vector3(0, 1.01f, 0);
                    //go.renderer.castShadows = false;
                    //go.renderer.receiveShadows = false;
                    //go.transform.rotation = Quaternion.Euler(0, Random.Range(0, 360), 0);

                    TextMeshPro textMeshPro = go.AddComponent<TextMeshPro>();
                    //textMeshPro.FontAsset = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(TextMeshProFont)) as TextMeshProFont;
                    //textMeshPro.anchor = AnchorPositions.Bottom;
                    textMeshPro.fontSize = 96;

                    textMeshPro.text = "!";
                    textMeshPro.color = new Color32(255, 255, 0, 255);
                    //textMeshPro.Text = "!";


                    // Spawn Floating Text
                    floatingText_Script = go.AddComponent<TextMeshProFloatingText>();
                    floatingText_Script.SpawnType = 0;
                }
                else
                {
                    // TextMesh Implementation
                    GameObject go = new GameObject(); //"NPC " + i);
                    go.transform.position = new Vector3(Random.Range(-95f, 95f), 0.5f, Random.Range(-95f, 95f));

                    //go.transform.position = new Vector3(0, 1.01f, 0);

                    TextMesh textMesh = go.AddComponent<TextMesh>();
                    textMesh.GetComponent<Renderer>().sharedMaterial = TheFont.material;
                    textMesh.font = TheFont;
                    textMesh.anchor = TextAnchor.LowerCenter;
                    textMesh.fontSize = 96;

                    textMesh.color = new Color32(255, 255, 0, 255);
                    textMesh.text = "!";

                    // Spawn Floating Text
                    floatingText_Script = go.AddComponent<TextMeshProFloatingText>();
                    floatingText_Script.SpawnType = 1;
                }
            }
        }

    }
}


2.90 Текст программы «TMP_DigitValidator.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System;


namespace TMPro
{
    /// <summary>
    /// EXample of a Custom Character Input Validator to only allow digits from 0 to 9.
    /// </summary>
    [Serializable]
    //[CreateAssetMenu(fileName = "InputValidator - Digits.asset", menuName = "TextMeshPro/Input Validators/Digits", order = 100)]
    public class TMP_DigitValidator : TMP_InputValidator
    {
        // Custom text input validation function
        public override char Validate(ref string text, ref int pos, char ch)
        {
            if (ch >= '0' && ch <= '9')
            {
                text += ch;
                pos += 1;
                return ch;
            }

            return (char)0;
        }
    }
}


2.91 Текст программы «TMP_ExampleScript_01.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using TMPro;


namespace TMPro.Examples
{

    public class TMP_ExampleScript_01 : MonoBehaviour
    {
        public enum objectType { TextMeshPro = 0, TextMeshProUGUI = 1 };

        public objectType ObjectType;
        public bool isStatic;

        private TMP_Text m_text;

        //private TMP_InputField m_inputfield;


        private const string k_label = "The count is <#0080ff>{0}</color>";
        private int count;

        void Awake()
        {
            // Get a reference to the TMP text component if one already exists otherwise add one.
            // This example show the convenience of having both TMP components derive from TMP_Text. 
            if (ObjectType == 0)
                m_text = GetComponent<TextMeshPro>() ?? gameObject.AddComponent<TextMeshPro>();
            else
                m_text = GetComponent<TextMeshProUGUI>() ?? gameObject.AddComponent<TextMeshProUGUI>();

            // Load a new font asset and assign it to the text object.
            m_text.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/Anton SDF");

            // Load a new material preset which was created with the context menu duplicate.
            m_text.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/Anton SDF - Drop Shadow");

            // Set the size of the font.
            m_text.fontSize = 120;

            // Set the text
            m_text.text = "A <#0080ff>simple</color> line of text.";

            // Get the preferred width and height based on the supplied width and height as opposed to the actual size of the current text container.
            Vector2 size = m_text.GetPreferredValues(Mathf.Infinity, Mathf.Infinity);

            // Set the size of the RectTransform based on the new calculated values.
            m_text.rectTransform.sizeDelta = new Vector2(size.x, size.y);
        }


        void Update()
        {
            if (!isStatic)
            {
                m_text.SetText(k_label, count % 1000);
                count += 1;
            }
        }

    }
}


2.92 Текст программы «TMP_FrameRateCounter.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class TMP_FrameRateCounter : MonoBehaviour
    {
        public float UpdateInterval = 5.0f;
        private float m_LastInterval = 0;
        private int m_Frames = 0;

        public enum FpsCounterAnchorPositions { TopLeft, BottomLeft, TopRight, BottomRight };

        public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.TopRight;

        private string htmlColorTag;
        private const string fpsLabel = "{0:2}</color> <#8080ff>FPS \n<#FF8000>{1:2} <#8080ff>MS";

        private TextMeshPro m_TextMeshPro;
        private Transform m_frameCounter_transform;
        private Camera m_camera;

        private FpsCounterAnchorPositions last_AnchorPosition;

        void Awake()
        {
            if (!enabled)
                return;

            m_camera = Camera.main;
            Application.targetFrameRate = 9999;

            GameObject frameCounter = new GameObject("Frame Counter");

            m_TextMeshPro = frameCounter.AddComponent<TextMeshPro>();
            m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF");
            m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay");


            m_frameCounter_transform = frameCounter.transform;
            m_frameCounter_transform.SetParent(m_camera.transform);
            m_frameCounter_transform.localRotation = Quaternion.identity;

            m_TextMeshPro.enableWordWrapping = false;
            m_TextMeshPro.fontSize = 24;
            //m_TextMeshPro.FontColor = new Color32(255, 255, 255, 128);
            //m_TextMeshPro.edgeWidth = .15f;
            //m_TextMeshPro.isOverlay = true;

            //m_TextMeshPro.FaceColor = new Color32(255, 128, 0, 0);
            //m_TextMeshPro.EdgeColor = new Color32(0, 255, 0, 255);
            //m_TextMeshPro.FontMaterial.renderQueue = 4000;

            //m_TextMeshPro.CreateSoftShadowClone(new Vector2(1f, -1f));

            Set_FrameCounter_Position(AnchorPosition);
            last_AnchorPosition = AnchorPosition;


        }

        void Start()
        {
            m_LastInterval = Time.realtimeSinceStartup;
            m_Frames = 0;
        }

        void Update()
        {
            if (AnchorPosition != last_AnchorPosition)
                Set_FrameCounter_Position(AnchorPosition);

            last_AnchorPosition = AnchorPosition;

            m_Frames += 1;
            float timeNow = Time.realtimeSinceStartup;

            if (timeNow > m_LastInterval + UpdateInterval)
            {
                // display two fractional digits (f2 format)
                float fps = m_Frames / (timeNow - m_LastInterval);
                float ms = 1000.0f / Mathf.Max(fps, 0.00001f);

                if (fps < 30)
                    htmlColorTag = "<color=yellow>";
                else if (fps < 10)
                    htmlColorTag = "<color=red>";
                else
                    htmlColorTag = "<color=green>";

                //string format = System.String.Format(htmlColorTag + "{0:F2} </color>FPS \n{1:F2} <#8080ff>MS",fps, ms);
                //m_TextMeshPro.text = format;

                m_TextMeshPro.SetText(htmlColorTag + fpsLabel, fps, ms);

                m_Frames = 0;
                m_LastInterval = timeNow;
            }
        }


        void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
        {
            //Debug.Log("Changing frame counter anchor position.");
            m_TextMeshPro.margin = new Vector4(1f, 1f, 1f, 1f);

            switch (anchor_position)
            {
                case FpsCounterAnchorPositions.TopLeft:
                    m_TextMeshPro.alignment = TextAlignmentOptions.TopLeft;
                    m_TextMeshPro.rectTransform.pivot = new Vector2(0, 1);
                    m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0, 1, 100.0f));
                    break;
                case FpsCounterAnchorPositions.BottomLeft:
                    m_TextMeshPro.alignment = TextAlignmentOptions.BottomLeft;
                    m_TextMeshPro.rectTransform.pivot = new Vector2(0, 0);
                    m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0, 0, 100.0f));
                    break;
                case FpsCounterAnchorPositions.TopRight:
                    m_TextMeshPro.alignment = TextAlignmentOptions.TopRight;
                    m_TextMeshPro.rectTransform.pivot = new Vector2(1, 1);
                    m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1, 1, 100.0f));
                    break;
                case FpsCounterAnchorPositions.BottomRight:
                    m_TextMeshPro.alignment = TextAlignmentOptions.BottomRight;
                    m_TextMeshPro.rectTransform.pivot = new Vector2(1, 0);
                    m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1, 0, 100.0f));
                    break;
            }
        }
    }
}


2.93 Текст программы «TMP_PhoneNumberValidator.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;
using System;

namespace TMPro
{
    /// <summary>
    /// Example of a Custom Character Input Validator to only allow phone number in the (800) 555-1212 format.
    /// </summary>
    [Serializable]
    //[CreateAssetMenu(fileName = "InputValidator - Phone Numbers.asset", menuName = "TextMeshPro/Input Validators/Phone Numbers")]
    public class TMP_PhoneNumberValidator : TMP_InputValidator
    {
        // Custom text input validation function
        public override char Validate(ref string text, ref int pos, char ch)
        {
            Debug.Log("Trying to validate...");
            
            // Return unless the character is a valid digit
            if (ch < '0' && ch > '9') return (char)0;

            int length = text.Length;

            // Enforce Phone Number format for every character input.
            for (int i = 0; i < length + 1; i++)
            {
                switch (i)
                {
                    case 0:
                        if (i == length)
                            text = "(" + ch;
                        pos = 2;
                        break;
                    case 1:
                        if (i == length)
                            text += ch;
                        pos = 2;
                        break;
                    case 2:
                        if (i == length)
                            text += ch;
                        pos = 3;
                        break;
                    case 3:
                        if (i == length)
                            text += ch + ") ";
                        pos = 6;
                        break;
                    case 4:
                        if (i == length)
                            text += ") " + ch;
                        pos = 7;
                        break;
                    case 5:
                        if (i == length)
                            text += " " + ch;
                        pos = 7;
                        break;
                    case 6:
                        if (i == length)
                            text += ch;
                        pos = 7;
                        break;
                    case 7:
                        if (i == length)
                            text += ch;
                        pos = 8;
                        break;
                    case 8:
                        if (i == length)
                            text += ch + "-";
                        pos = 10;
                        break;
                    case 9:
                        if (i == length)
                            text += "-" + ch;
                        pos = 11;
                        break;
                    case 10:
                        if (i == length)
                            text += ch;
                        pos = 11;
                        break;
                    case 11:
                        if (i == length)
                            text += ch;
                        pos = 12;
                        break;
                    case 12:
                        if (i == length)
                            text += ch;
                        pos = 13;
                        break;
                    case 13:
                        if (i == length)
                            text += ch;
                        pos = 14;
                        break;
                }
            }

            return ch;
        }
    }
}


2.94 Текст программы «TMP_TextEventCheck.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;


namespace TMPro.Examples
{
    public class TMP_TextEventCheck : MonoBehaviour
    {

        public TMP_TextEventHandler TextEventHandler;

        private TMP_Text m_TextComponent;

        void OnEnable()
        {
            if (TextEventHandler != null)
            {
                // Get a reference to the text component
                m_TextComponent = TextEventHandler.GetComponent<TMP_Text>();
                
                TextEventHandler.onCharacterSelection.AddListener(OnCharacterSelection);
                TextEventHandler.onSpriteSelection.AddListener(OnSpriteSelection);
                TextEventHandler.onWordSelection.AddListener(OnWordSelection);
                TextEventHandler.onLineSelection.AddListener(OnLineSelection);
                TextEventHandler.onLinkSelection.AddListener(OnLinkSelection);
            }
        }


        void OnDisable()
        {
            if (TextEventHandler != null)
            {
                TextEventHandler.onCharacterSelection.RemoveListener(OnCharacterSelection);
                TextEventHandler.onSpriteSelection.RemoveListener(OnSpriteSelection);
                TextEventHandler.onWordSelection.RemoveListener(OnWordSelection);
                TextEventHandler.onLineSelection.RemoveListener(OnLineSelection);
                TextEventHandler.onLinkSelection.RemoveListener(OnLinkSelection);
            }
        }


        void OnCharacterSelection(char c, int index)
        {
            Debug.Log("Character [" + c + "] at Index: " + index + " has been selected.");
        }

        void OnSpriteSelection(char c, int index)
        {
            Debug.Log("Sprite [" + c + "] at Index: " + index + " has been selected.");
        }

        void OnWordSelection(string word, int firstCharacterIndex, int length)
        {
            Debug.Log("Word [" + word + "] with first character index of " + firstCharacterIndex + " and length of " + length + " has been selected.");
        }

        void OnLineSelection(string lineText, int firstCharacterIndex, int length)
        {
            Debug.Log("Line [" + lineText + "] with first character index of " + firstCharacterIndex + " and length of " + length + " has been selected.");
        }

        void OnLinkSelection(string linkID, string linkText, int linkIndex)
        {
            if (m_TextComponent != null)
            {
                TMP_LinkInfo linkInfo = m_TextComponent.textInfo.linkInfo[linkIndex];
            }
            
            Debug.Log("Link Index: " + linkIndex + " with ID [" + linkID + "] and Text \"" + linkText + "\" has been selected.");
        }

    }
}


2.95 Текст программы «TMP_TextEventHandler.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using System;


namespace TMPro
{

    public class TMP_TextEventHandler : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler
    {
        [Serializable]
        public class CharacterSelectionEvent : UnityEvent<char, int> { }

        [Serializable]
        public class SpriteSelectionEvent : UnityEvent<char, int> { }

        [Serializable]
        public class WordSelectionEvent : UnityEvent<string, int, int> { }

        [Serializable]
        public class LineSelectionEvent : UnityEvent<string, int, int> { }

        [Serializable]
        public class LinkSelectionEvent : UnityEvent<string, string, int> { }


        /// <summary>
        /// Event delegate triggered when pointer is over a character.
        /// </summary>
        public CharacterSelectionEvent onCharacterSelection
        {
            get { return m_OnCharacterSelection; }
            set { m_OnCharacterSelection = value; }
        }
        [SerializeField]
        private CharacterSelectionEvent m_OnCharacterSelection = new CharacterSelectionEvent();


        /// <summary>
        /// Event delegate triggered when pointer is over a sprite.
        /// </summary>
        public SpriteSelectionEvent onSpriteSelection
        {
            get { return m_OnSpriteSelection; }
            set { m_OnSpriteSelection = value; }
        }
        [SerializeField]
        private SpriteSelectionEvent m_OnSpriteSelection = new SpriteSelectionEvent();


        /// <summary>
        /// Event delegate triggered when pointer is over a word.
        /// </summary>
        public WordSelectionEvent onWordSelection
        {
            get { return m_OnWordSelection; }
            set { m_OnWordSelection = value; }
        }
        [SerializeField]
        private WordSelectionEvent m_OnWordSelection = new WordSelectionEvent();


        /// <summary>
        /// Event delegate triggered when pointer is over a line.
        /// </summary>
        public LineSelectionEvent onLineSelection
        {
            get { return m_OnLineSelection; }
            set { m_OnLineSelection = value; }
        }
        [SerializeField]
        private LineSelectionEvent m_OnLineSelection = new LineSelectionEvent();


        /// <summary>
        /// Event delegate triggered when pointer is over a link.
        /// </summary>
        public LinkSelectionEvent onLinkSelection
        {
            get { return m_OnLinkSelection; }
            set { m_OnLinkSelection = value; }
        }
        [SerializeField]
        private LinkSelectionEvent m_OnLinkSelection = new LinkSelectionEvent();



        private TMP_Text m_TextComponent;

        private Camera m_Camera;
        private Canvas m_Canvas;

        private int m_selectedLink = -1;
        private int m_lastCharIndex = -1;
        private int m_lastWordIndex = -1;
        private int m_lastLineIndex = -1;

        void Awake()
        {
            // Get a reference to the text component.
            m_TextComponent = gameObject.GetComponent<TMP_Text>();

            // Get a reference to the camera rendering the text taking into consideration the text component type.
            if (m_TextComponent.GetType() == typeof(TextMeshProUGUI))
            {
                m_Canvas = gameObject.GetComponentInParent<Canvas>();
                if (m_Canvas != null)
                {
                    if (m_Canvas.renderMode == RenderMode.ScreenSpaceOverlay)
                        m_Camera = null;
                    else
                        m_Camera = m_Canvas.worldCamera;
                }
            }
            else
            {
                m_Camera = Camera.main;
            }
        }


        void LateUpdate()
        {
            if (TMP_TextUtilities.IsIntersectingRectTransform(m_TextComponent.rectTransform, Input.mousePosition, m_Camera))
            {
                #region Example of Character or Sprite Selection
                int charIndex = TMP_TextUtilities.FindIntersectingCharacter(m_TextComponent, Input.mousePosition, m_Camera, true);
                if (charIndex != -1 && charIndex != m_lastCharIndex)
                {
                    m_lastCharIndex = charIndex;

                    TMP_TextElementType elementType = m_TextComponent.textInfo.characterInfo[charIndex].elementType;

                    // Send event to any event listeners depending on whether it is a character or sprite.
                    if (elementType == TMP_TextElementType.Character)
                        SendOnCharacterSelection(m_TextComponent.textInfo.characterInfo[charIndex].character, charIndex);
                    else if (elementType == TMP_TextElementType.Sprite)
                        SendOnSpriteSelection(m_TextComponent.textInfo.characterInfo[charIndex].character, charIndex);
                }
                #endregion


                #region Example of Word Selection
                // Check if Mouse intersects any words and if so assign a random color to that word.
                int wordIndex = TMP_TextUtilities.FindIntersectingWord(m_TextComponent, Input.mousePosition, m_Camera);
                if (wordIndex != -1 && wordIndex != m_lastWordIndex)
                {
                    m_lastWordIndex = wordIndex;

                    // Get the information about the selected word.
                    TMP_WordInfo wInfo = m_TextComponent.textInfo.wordInfo[wordIndex];

                    // Send the event to any listeners.
                    SendOnWordSelection(wInfo.GetWord(), wInfo.firstCharacterIndex, wInfo.characterCount);
                }
                #endregion


                #region Example of Line Selection
                // Check if Mouse intersects any words and if so assign a random color to that word.
                int lineIndex = TMP_TextUtilities.FindIntersectingLine(m_TextComponent, Input.mousePosition, m_Camera);
                if (lineIndex != -1 && lineIndex != m_lastLineIndex)
                {
                    m_lastLineIndex = lineIndex;

                    // Get the information about the selected word.
                    TMP_LineInfo lineInfo = m_TextComponent.textInfo.lineInfo[lineIndex];

                    // Send the event to any listeners.
                    char[] buffer = new char[lineInfo.characterCount];
                    for (int i = 0; i < lineInfo.characterCount && i < m_TextComponent.textInfo.characterInfo.Length; i++)
                    {
                        buffer[i] = m_TextComponent.textInfo.characterInfo[i + lineInfo.firstCharacterIndex].character;
                    }

                    string lineText = new string(buffer);
                    SendOnLineSelection(lineText, lineInfo.firstCharacterIndex, lineInfo.characterCount);
                }
                #endregion


                #region Example of Link Handling
                // Check if mouse intersects with any links.
                int linkIndex = TMP_TextUtilities.FindIntersectingLink(m_TextComponent, Input.mousePosition, m_Camera);

                // Handle new Link selection.
                if (linkIndex != -1 && linkIndex != m_selectedLink)
                {
                    m_selectedLink = linkIndex;

                    // Get information about the link.
                    TMP_LinkInfo linkInfo = m_TextComponent.textInfo.linkInfo[linkIndex];

                    // Send the event to any listeners.
                    SendOnLinkSelection(linkInfo.GetLinkID(), linkInfo.GetLinkText(), linkIndex);
                }
                #endregion
            }
            else
            {
                // Reset all selections given we are hovering outside the text container bounds.
                m_selectedLink = -1;
                m_lastCharIndex = -1;
                m_lastWordIndex = -1;
                m_lastLineIndex = -1;
            }
        }


        public void OnPointerEnter(PointerEventData eventData)
        {
            //Debug.Log("OnPointerEnter()");
        }


        public void OnPointerExit(PointerEventData eventData)
        {
            //Debug.Log("OnPointerExit()");
        }


        private void SendOnCharacterSelection(char character, int characterIndex)
        {
            if (onCharacterSelection != null)
                onCharacterSelection.Invoke(character, characterIndex);
        }

        private void SendOnSpriteSelection(char character, int characterIndex)
        {
            if (onSpriteSelection != null)
                onSpriteSelection.Invoke(character, characterIndex);
        }

        private void SendOnWordSelection(string word, int charIndex, int length)
        {
            if (onWordSelection != null)
                onWordSelection.Invoke(word, charIndex, length);
        }

        private void SendOnLineSelection(string line, int charIndex, int length)
        {
            if (onLineSelection != null)
                onLineSelection.Invoke(line, charIndex, length);
        }

        private void SendOnLinkSelection(string linkID, string linkText, int linkIndex)
        {
            if (onLinkSelection != null)
                onLinkSelection.Invoke(linkID, linkText, linkIndex);
        }

    }
}


2.96 Текст программы «TMP_TextInfoDebugTool.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using System;
using UnityEngine;
using System.Collections;
using UnityEditor;


namespace TMPro.Examples
{

    public class TMP_TextInfoDebugTool : MonoBehaviour
    {
        // Since this script is used for debugging, we exclude it from builds.
        // TODO: Rework this script to make it into an editor utility.
        #if UNITY_EDITOR
        public bool ShowCharacters;
        public bool ShowWords;
        public bool ShowLinks;
        public bool ShowLines;
        public bool ShowMeshBounds;
        public bool ShowTextBounds;
        [Space(10)]
        [TextArea(2, 2)]
        public string ObjectStats;

        [SerializeField]
        private TMP_Text m_TextComponent;

        private Transform m_Transform;
        private TMP_TextInfo m_TextInfo;

        private float m_ScaleMultiplier;
        private float m_HandleSize;


        void OnDrawGizmos()
        {
            if (m_TextComponent == null)
            {
                m_TextComponent = GetComponent<TMP_Text>();

                if (m_TextComponent == null)
                    return;
            }

            m_Transform = m_TextComponent.transform;

            // Get a reference to the text object's textInfo
            m_TextInfo = m_TextComponent.textInfo;

            // Update Text Statistics
            ObjectStats = "Characters: " + m_TextInfo.characterCount + "   Words: " + m_TextInfo.wordCount + "   Spaces: " + m_TextInfo.spaceCount + "   Sprites: " + m_TextInfo.spriteCount + "   Links: " + m_TextInfo.linkCount
                          + "\nLines: " + m_TextInfo.lineCount + "   Pages: " + m_TextInfo.pageCount;

            // Get the handle size for drawing the various
            m_ScaleMultiplier = m_TextComponent.GetType() == typeof(TextMeshPro) ? 1 : 0.1f;
            m_HandleSize = HandleUtility.GetHandleSize(m_Transform.position) * m_ScaleMultiplier;

            // Draw line metrics
            #region Draw Lines
            if (ShowLines)
                DrawLineBounds();
            #endregion

            // Draw word metrics
            #region Draw Words
            if (ShowWords)
                DrawWordBounds();
            #endregion

            // Draw character metrics
            #region Draw Characters
            if (ShowCharacters)
                DrawCharactersBounds();
            #endregion

            // Draw Quads around each of the words
            #region Draw Links
            if (ShowLinks)
                DrawLinkBounds();
            #endregion

            // Draw Quad around the bounds of the text
            #region Draw Bounds
            if (ShowMeshBounds)
                DrawBounds();
            #endregion

            // Draw Quad around the rendered region of the text.
            #region Draw Text Bounds
            if (ShowTextBounds)
                DrawTextBounds();
            #endregion
        }


        /// <summary>
        /// Method to draw a rectangle around each character.
        /// </summary>
        /// <param name="text"></param>
        void DrawCharactersBounds()
        {
            int characterCount = m_TextInfo.characterCount;

            for (int i = 0; i < characterCount; i++)
            {
                // Draw visible as well as invisible characters
                TMP_CharacterInfo characterInfo = m_TextInfo.characterInfo[i];

                bool isCharacterVisible = i < m_TextComponent.maxVisibleCharacters &&
                                          characterInfo.lineNumber < m_TextComponent.maxVisibleLines &&
                                          i >= m_TextComponent.firstVisibleCharacter;

                if (m_TextComponent.overflowMode == TextOverflowModes.Page)
                    isCharacterVisible = isCharacterVisible && characterInfo.pageNumber + 1 == m_TextComponent.pageToDisplay;

                if (!isCharacterVisible)
                    continue;

                float dottedLineSize = 6;

                // Get Bottom Left and Top Right position of the current character
                Vector3 bottomLeft = m_Transform.TransformPoint(characterInfo.bottomLeft);
                Vector3 topLeft = m_Transform.TransformPoint(new Vector3(characterInfo.topLeft.x, characterInfo.topLeft.y, 0));
                Vector3 topRight = m_Transform.TransformPoint(characterInfo.topRight);
                Vector3 bottomRight = m_Transform.TransformPoint(new Vector3(characterInfo.bottomRight.x, characterInfo.bottomRight.y, 0));

                // Draw character bounds
                if (characterInfo.isVisible)
                {
                    Color color = Color.green;
                    DrawDottedRectangle(bottomLeft, topRight, color);
                }
                else
                {
                    Color color = Color.grey;

                    float whiteSpaceAdvance = Math.Abs(characterInfo.origin - characterInfo.xAdvance) > 0.01f ? characterInfo.xAdvance : characterInfo.origin + (characterInfo.ascender - characterInfo.descender) * 0.03f;
                    DrawDottedRectangle(m_Transform.TransformPoint(new Vector3(characterInfo.origin, characterInfo.descender, 0)), m_Transform.TransformPoint(new Vector3(whiteSpaceAdvance, characterInfo.ascender, 0)), color, 4);
                }

                float origin = characterInfo.origin;
                float advance = characterInfo.xAdvance;
                float ascentline = characterInfo.ascender;
                float baseline = characterInfo.baseLine;
                float descentline = characterInfo.descender;

                //Draw Ascent line
                Vector3 ascentlineStart = m_Transform.TransformPoint(new Vector3(origin, ascentline, 0));
                Vector3 ascentlineEnd = m_Transform.TransformPoint(new Vector3(advance, ascentline, 0));

                Handles.color = Color.cyan;
                Handles.DrawDottedLine(ascentlineStart, ascentlineEnd, dottedLineSize);

                // Draw Cap Height & Mean line
                float capline = characterInfo.fontAsset == null ? 0 : baseline + characterInfo.fontAsset.faceInfo.capLine * characterInfo.scale;
                Vector3 capHeightStart = new Vector3(topLeft.x, m_Transform.TransformPoint(new Vector3(0, capline, 0)).y, 0);
                Vector3 capHeightEnd = new Vector3(topRight.x, m_Transform.TransformPoint(new Vector3(0, capline, 0)).y, 0);

                float meanline = characterInfo.fontAsset == null ? 0 : baseline + characterInfo.fontAsset.faceInfo.meanLine * characterInfo.scale;
                Vector3 meanlineStart = new Vector3(topLeft.x, m_Transform.TransformPoint(new Vector3(0, meanline, 0)).y, 0);
                Vector3 meanlineEnd = new Vector3(topRight.x, m_Transform.TransformPoint(new Vector3(0, meanline, 0)).y, 0);

                if (characterInfo.isVisible)
                {
                    // Cap line
                    Handles.color = Color.cyan;
                    Handles.DrawDottedLine(capHeightStart, capHeightEnd, dottedLineSize);

                    // Mean line
                    Handles.color = Color.cyan;
                    Handles.DrawDottedLine(meanlineStart, meanlineEnd, dottedLineSize);
                }

                //Draw Base line
                Vector3 baselineStart = m_Transform.TransformPoint(new Vector3(origin, baseline, 0));
                Vector3 baselineEnd = m_Transform.TransformPoint(new Vector3(advance, baseline, 0));

                Handles.color = Color.cyan;
                Handles.DrawDottedLine(baselineStart, baselineEnd, dottedLineSize);

                //Draw Descent line
                Vector3 descentlineStart = m_Transform.TransformPoint(new Vector3(origin, descentline, 0));
                Vector3 descentlineEnd = m_Transform.TransformPoint(new Vector3(advance, descentline, 0));

                Handles.color = Color.cyan;
                Handles.DrawDottedLine(descentlineStart, descentlineEnd, dottedLineSize);

                // Draw Origin
                Vector3 originPosition = m_Transform.TransformPoint(new Vector3(origin, baseline, 0));
                DrawCrosshair(originPosition, 0.05f / m_ScaleMultiplier, Color.cyan);

                // Draw Horizontal Advance
                Vector3 advancePosition = m_Transform.TransformPoint(new Vector3(advance, baseline, 0));
                DrawSquare(advancePosition, 0.025f / m_ScaleMultiplier, Color.yellow);
                DrawCrosshair(advancePosition, 0.0125f / m_ScaleMultiplier, Color.yellow);

                // Draw text labels for metrics
               if (m_HandleSize < 0.5f)
               {
                   GUIStyle style = new GUIStyle(GUI.skin.GetStyle("Label"));
                   style.normal.textColor = new Color(0.6f, 0.6f, 0.6f, 1.0f);
                   style.fontSize = 12;
                   style.fixedWidth = 200;
                   style.fixedHeight = 20;

                   Vector3 labelPosition;
                   float center = (origin + advance) / 2;

                   //float baselineMetrics = 0;
                   //float ascentlineMetrics = ascentline - baseline;
                   //float caplineMetrics = capline - baseline;
                   //float meanlineMetrics = meanline - baseline;
                   //float descentlineMetrics = descentline - baseline;

                   // Ascent Line
                   labelPosition = m_Transform.TransformPoint(new Vector3(center, ascentline, 0));
                   style.alignment = TextAnchor.UpperCenter;
                   Handles.Label(labelPosition, "Ascent Line", style);
                   //Handles.Label(labelPosition, "Ascent Line (" + ascentlineMetrics.ToString("f3") + ")" , style);

                   // Base Line
                   labelPosition = m_Transform.TransformPoint(new Vector3(center, baseline, 0));
                   Handles.Label(labelPosition, "Base Line", style);
                   //Handles.Label(labelPosition, "Base Line (" + baselineMetrics.ToString("f3") + ")" , style);

                   // Descent line
                   labelPosition = m_Transform.TransformPoint(new Vector3(center, descentline, 0));
                   Handles.Label(labelPosition, "Descent Line", style);
                   //Handles.Label(labelPosition, "Descent Line (" + descentlineMetrics.ToString("f3") + ")" , style);

                   if (characterInfo.isVisible)
                   {
                       // Cap Line
                       labelPosition = m_Transform.TransformPoint(new Vector3(center, capline, 0));
                       style.alignment = TextAnchor.UpperCenter;
                       Handles.Label(labelPosition, "Cap Line", style);
                       //Handles.Label(labelPosition, "Cap Line (" + caplineMetrics.ToString("f3") + ")" , style);

                       // Mean Line
                       labelPosition = m_Transform.TransformPoint(new Vector3(center, meanline, 0));
                       style.alignment = TextAnchor.UpperCenter;
                       Handles.Label(labelPosition, "Mean Line", style);
                       //Handles.Label(labelPosition, "Mean Line (" + ascentlineMetrics.ToString("f3") + ")" , style);

                       // Origin
                       labelPosition = m_Transform.TransformPoint(new Vector3(origin, baseline, 0));
                       style.alignment = TextAnchor.UpperRight;
                       Handles.Label(labelPosition, "Origin ", style);

                       // Advance
                       labelPosition = m_Transform.TransformPoint(new Vector3(advance, baseline, 0));
                       style.alignment = TextAnchor.UpperLeft;
                       Handles.Label(labelPosition, "  Advance", style);
                   }
               }
            }
        }


        /// <summary>
        /// Method to draw rectangles around each word of the text.
        /// </summary>
        /// <param name="text"></param>
        void DrawWordBounds()
        {
            for (int i = 0; i < m_TextInfo.wordCount; i++)
            {
                TMP_WordInfo wInfo = m_TextInfo.wordInfo[i];

                bool isBeginRegion = false;

                Vector3 bottomLeft = Vector3.zero;
                Vector3 topLeft = Vector3.zero;
                Vector3 bottomRight = Vector3.zero;
                Vector3 topRight = Vector3.zero;

                float maxAscender = -Mathf.Infinity;
                float minDescender = Mathf.Infinity;

                Color wordColor = Color.green;

                // Iterate through each character of the word
                for (int j = 0; j < wInfo.characterCount; j++)
                {
                    int characterIndex = wInfo.firstCharacterIndex + j;
                    TMP_CharacterInfo currentCharInfo = m_TextInfo.characterInfo[characterIndex];
                    int currentLine = currentCharInfo.lineNumber;

                    bool isCharacterVisible = characterIndex > m_TextComponent.maxVisibleCharacters ||
                                              currentCharInfo.lineNumber > m_TextComponent.maxVisibleLines ||
                                             (m_TextComponent.overflowMode == TextOverflowModes.Page && currentCharInfo.pageNumber + 1 != m_TextComponent.pageToDisplay) ? false : true;

                    // Track Max Ascender and Min Descender
                    maxAscender = Mathf.Max(maxAscender, currentCharInfo.ascender);
                    minDescender = Mathf.Min(minDescender, currentCharInfo.descender);

                    if (isBeginRegion == false && isCharacterVisible)
                    {
                        isBeginRegion = true;

                        bottomLeft = new Vector3(currentCharInfo.bottomLeft.x, currentCharInfo.descender, 0);
                        topLeft = new Vector3(currentCharInfo.bottomLeft.x, currentCharInfo.ascender, 0);

                        //Debug.Log("Start Word Region at [" + currentCharInfo.character + "]");

                        // If Word is one character
                        if (wInfo.characterCount == 1)
                        {
                            isBeginRegion = false;

                            topLeft = m_Transform.TransformPoint(new Vector3(topLeft.x, maxAscender, 0));
                            bottomLeft = m_Transform.TransformPoint(new Vector3(bottomLeft.x, minDescender, 0));
                            bottomRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, minDescender, 0));
                            topRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, maxAscender, 0));

                            // Draw Region
                            DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, wordColor);

                            //Debug.Log("End Word Region at [" + currentCharInfo.character + "]");
                        }
                    }

                    // Last Character of Word
                    if (isBeginRegion && j == wInfo.characterCount - 1)
                    {
                        isBeginRegion = false;

                        topLeft = m_Transform.TransformPoint(new Vector3(topLeft.x, maxAscender, 0));
                        bottomLeft = m_Transform.TransformPoint(new Vector3(bottomLeft.x, minDescender, 0));
                        bottomRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, minDescender, 0));
                        topRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, maxAscender, 0));

                        // Draw Region
                        DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, wordColor);

                        //Debug.Log("End Word Region at [" + currentCharInfo.character + "]");
                    }
                    // If Word is split on more than one line.
                    else if (isBeginRegion && currentLine != m_TextInfo.characterInfo[characterIndex + 1].lineNumber)
                    {
                        isBeginRegion = false;

                        topLeft = m_Transform.TransformPoint(new Vector3(topLeft.x, maxAscender, 0));
                        bottomLeft = m_Transform.TransformPoint(new Vector3(bottomLeft.x, minDescender, 0));
                        bottomRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, minDescender, 0));
                        topRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, maxAscender, 0));

                        // Draw Region
                        DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, wordColor);
                        //Debug.Log("End Word Region at [" + currentCharInfo.character + "]");
                        maxAscender = -Mathf.Infinity;
                        minDescender = Mathf.Infinity;

                    }
                }

                //Debug.Log(wInfo.GetWord(m_TextMeshPro.textInfo.characterInfo));
            }


        }


        /// <summary>
        /// Draw rectangle around each of the links contained in the text.
        /// </summary>
        /// <param name="text"></param>
        void DrawLinkBounds()
        {
            TMP_TextInfo textInfo = m_TextComponent.textInfo;

            for (int i = 0; i < textInfo.linkCount; i++)
            {
                TMP_LinkInfo linkInfo = textInfo.linkInfo[i];

                bool isBeginRegion = false;

                Vector3 bottomLeft = Vector3.zero;
                Vector3 topLeft = Vector3.zero;
                Vector3 bottomRight = Vector3.zero;
                Vector3 topRight = Vector3.zero;

                float maxAscender = -Mathf.Infinity;
                float minDescender = Mathf.Infinity;

                Color32 linkColor = Color.cyan;

                // Iterate through each character of the link text
                for (int j = 0; j < linkInfo.linkTextLength; j++)
                {
                    int characterIndex = linkInfo.linkTextfirstCharacterIndex + j;
                    TMP_CharacterInfo currentCharInfo = textInfo.characterInfo[characterIndex];
                    int currentLine = currentCharInfo.lineNumber;

                    bool isCharacterVisible = characterIndex > m_TextComponent.maxVisibleCharacters ||
                                              currentCharInfo.lineNumber > m_TextComponent.maxVisibleLines ||
                                             (m_TextComponent.overflowMode == TextOverflowModes.Page && currentCharInfo.pageNumber + 1 != m_TextComponent.pageToDisplay) ? false : true;

                    // Track Max Ascender and Min Descender
                    maxAscender = Mathf.Max(maxAscender, currentCharInfo.ascender);
                    minDescender = Mathf.Min(minDescender, currentCharInfo.descender);

                    if (isBeginRegion == false && isCharacterVisible)
                    {
                        isBeginRegion = true;

                        bottomLeft = new Vector3(currentCharInfo.bottomLeft.x, currentCharInfo.descender, 0);
                        topLeft = new Vector3(currentCharInfo.bottomLeft.x, currentCharInfo.ascender, 0);

                        //Debug.Log("Start Word Region at [" + currentCharInfo.character + "]");

                        // If Link is one character
                        if (linkInfo.linkTextLength == 1)
                        {
                            isBeginRegion = false;

                            topLeft = m_Transform.TransformPoint(new Vector3(topLeft.x, maxAscender, 0));
                            bottomLeft = m_Transform.TransformPoint(new Vector3(bottomLeft.x, minDescender, 0));
                            bottomRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, minDescender, 0));
                            topRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, maxAscender, 0));

                            // Draw Region
                            DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, linkColor);

                            //Debug.Log("End Word Region at [" + currentCharInfo.character + "]");
                        }
                    }

                    // Last Character of Link
                    if (isBeginRegion && j == linkInfo.linkTextLength - 1)
                    {
                        isBeginRegion = false;

                        topLeft = m_Transform.TransformPoint(new Vector3(topLeft.x, maxAscender, 0));
                        bottomLeft = m_Transform.TransformPoint(new Vector3(bottomLeft.x, minDescender, 0));
                        bottomRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, minDescender, 0));
                        topRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, maxAscender, 0));

                        // Draw Region
                        DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, linkColor);

                        //Debug.Log("End Word Region at [" + currentCharInfo.character + "]");
                    }
                    // If Link is split on more than one line.
                    else if (isBeginRegion && currentLine != textInfo.characterInfo[characterIndex + 1].lineNumber)
                    {
                        isBeginRegion = false;

                        topLeft = m_Transform.TransformPoint(new Vector3(topLeft.x, maxAscender, 0));
                        bottomLeft = m_Transform.TransformPoint(new Vector3(bottomLeft.x, minDescender, 0));
                        bottomRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, minDescender, 0));
                        topRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, maxAscender, 0));

                        // Draw Region
                        DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, linkColor);

                        maxAscender = -Mathf.Infinity;
                        minDescender = Mathf.Infinity;
                        //Debug.Log("End Word Region at [" + currentCharInfo.character + "]");
                    }
                }

                //Debug.Log(wInfo.GetWord(m_TextMeshPro.textInfo.characterInfo));
            }
        }


        /// <summary>
        /// Draw Rectangles around each lines of the text.
        /// </summary>
        /// <param name="text"></param>
        void DrawLineBounds()
        {
            int lineCount = m_TextInfo.lineCount;

            for (int i = 0; i < lineCount; i++)
            {
                TMP_LineInfo lineInfo = m_TextInfo.lineInfo[i];
                TMP_CharacterInfo firstCharacterInfo = m_TextInfo.characterInfo[lineInfo.firstCharacterIndex];
                TMP_CharacterInfo lastCharacterInfo = m_TextInfo.characterInfo[lineInfo.lastCharacterIndex];

                bool isLineVisible = (lineInfo.characterCount == 1 && (firstCharacterInfo.character == 10 || firstCharacterInfo.character == 11 || firstCharacterInfo.character == 0x2028 || firstCharacterInfo.character == 0x2029)) ||
                                      i > m_TextComponent.maxVisibleLines ||
                                     (m_TextComponent.overflowMode == TextOverflowModes.Page && firstCharacterInfo.pageNumber + 1 != m_TextComponent.pageToDisplay) ? false : true;

                if (!isLineVisible) continue;

                float lineBottomLeft = firstCharacterInfo.bottomLeft.x;
                float lineTopRight = lastCharacterInfo.topRight.x;

                float ascentline = lineInfo.ascender;
                float baseline = lineInfo.baseline;
                float descentline = lineInfo.descender;

                float dottedLineSize = 12;

                // Draw line extents
                DrawDottedRectangle(m_Transform.TransformPoint(lineInfo.lineExtents.min), m_Transform.TransformPoint(lineInfo.lineExtents.max), Color.green, 4);

                // Draw Ascent line
                Vector3 ascentlineStart = m_Transform.TransformPoint(new Vector3(lineBottomLeft, ascentline, 0));
                Vector3 ascentlineEnd = m_Transform.TransformPoint(new Vector3(lineTopRight, ascentline, 0));

                Handles.color = Color.yellow;
                Handles.DrawDottedLine(ascentlineStart, ascentlineEnd, dottedLineSize);

                // Draw Base line
                Vector3 baseLineStart = m_Transform.TransformPoint(new Vector3(lineBottomLeft, baseline, 0));
                Vector3 baseLineEnd = m_Transform.TransformPoint(new Vector3(lineTopRight, baseline, 0));

                Handles.color = Color.yellow;
                Handles.DrawDottedLine(baseLineStart, baseLineEnd, dottedLineSize);

                // Draw Descent line
                Vector3 descentLineStart = m_Transform.TransformPoint(new Vector3(lineBottomLeft, descentline, 0));
                Vector3 descentLineEnd = m_Transform.TransformPoint(new Vector3(lineTopRight, descentline, 0));

                Handles.color = Color.yellow;
                Handles.DrawDottedLine(descentLineStart, descentLineEnd, dottedLineSize);

                // Draw text labels for metrics
                if (m_HandleSize < 1.0f)
                {
                    GUIStyle style = new GUIStyle();
                    style.normal.textColor = new Color(0.8f, 0.8f, 0.8f, 1.0f);
                    style.fontSize = 12;
                    style.fixedWidth = 200;
                    style.fixedHeight = 20;
                    Vector3 labelPosition;

                    // Ascent Line
                    labelPosition = m_Transform.TransformPoint(new Vector3(lineBottomLeft, ascentline, 0));
                    style.padding = new RectOffset(0, 10, 0, 5);
                    style.alignment = TextAnchor.MiddleRight;
                    Handles.Label(labelPosition, "Ascent Line", style);

                    // Base Line
                    labelPosition = m_Transform.TransformPoint(new Vector3(lineBottomLeft, baseline, 0));
                    Handles.Label(labelPosition, "Base Line", style);

                    // Descent line
                    labelPosition = m_Transform.TransformPoint(new Vector3(lineBottomLeft, descentline, 0));
                    Handles.Label(labelPosition, "Descent Line", style);
                }
            }
        }


        /// <summary>
        /// Draw Rectangle around the bounds of the text object.
        /// </summary>
        void DrawBounds()
        {
            Bounds meshBounds = m_TextComponent.bounds;

            // Get Bottom Left and Top Right position of each word
            Vector3 bottomLeft = m_TextComponent.transform.position + meshBounds.min;
            Vector3 topRight = m_TextComponent.transform.position + meshBounds.max;

            DrawRectangle(bottomLeft, topRight, new Color(1, 0.5f, 0));
        }


        void DrawTextBounds()
        {
            Bounds textBounds = m_TextComponent.textBounds;

            Vector3 bottomLeft = m_TextComponent.transform.position + (textBounds.center - textBounds.extents);
            Vector3 topRight = m_TextComponent.transform.position + (textBounds.center + textBounds.extents);

            DrawRectangle(bottomLeft, topRight, new Color(0f, 0.5f, 0.5f));
        }


        // Draw Rectangles
        void DrawRectangle(Vector3 BL, Vector3 TR, Color color)
        {
            Gizmos.color = color;

            Gizmos.DrawLine(new Vector3(BL.x, BL.y, 0), new Vector3(BL.x, TR.y, 0));
            Gizmos.DrawLine(new Vector3(BL.x, TR.y, 0), new Vector3(TR.x, TR.y, 0));
            Gizmos.DrawLine(new Vector3(TR.x, TR.y, 0), new Vector3(TR.x, BL.y, 0));
            Gizmos.DrawLine(new Vector3(TR.x, BL.y, 0), new Vector3(BL.x, BL.y, 0));
        }

        void DrawDottedRectangle(Vector3 bottomLeft, Vector3 topRight, Color color, float size = 5.0f)
        {
            Handles.color = color;
            Handles.DrawDottedLine(bottomLeft, new Vector3(bottomLeft.x, topRight.y, bottomLeft.z), size);
            Handles.DrawDottedLine(new Vector3(bottomLeft.x, topRight.y, bottomLeft.z), topRight, size);
            Handles.DrawDottedLine(topRight, new Vector3(topRight.x, bottomLeft.y, bottomLeft.z), size);
            Handles.DrawDottedLine(new Vector3(topRight.x, bottomLeft.y, bottomLeft.z), bottomLeft, size);
        }

        void DrawSolidRectangle(Vector3 bottomLeft, Vector3 topRight, Color color, float size = 5.0f)
        {
            Handles.color = color;
            Rect rect = new Rect(bottomLeft, topRight - bottomLeft);
            Handles.DrawSolidRectangleWithOutline(rect, color, Color.black);
        }

        void DrawSquare(Vector3 position, float size, Color color)
        {
            Handles.color = color;
            Vector3 bottomLeft = new Vector3(position.x - size, position.y - size, position.z);
            Vector3 topLeft = new Vector3(position.x - size, position.y + size, position.z);
            Vector3 topRight = new Vector3(position.x + size, position.y + size, position.z);
            Vector3 bottomRight = new Vector3(position.x + size, position.y - size, position.z);

            Handles.DrawLine(bottomLeft, topLeft);
            Handles.DrawLine(topLeft, topRight);
            Handles.DrawLine(topRight, bottomRight);
            Handles.DrawLine(bottomRight, bottomLeft);
        }

        void DrawCrosshair(Vector3 position, float size, Color color)
        {
            Handles.color = color;

            Handles.DrawLine(new Vector3(position.x - size, position.y, position.z), new Vector3(position.x + size, position.y, position.z));
            Handles.DrawLine(new Vector3(position.x, position.y - size, position.z), new Vector3(position.x, position.y + size, position.z));
        }


        // Draw Rectangles
        void DrawRectangle(Vector3 bl, Vector3 tl, Vector3 tr, Vector3 br, Color color)
        {
            Gizmos.color = color;

            Gizmos.DrawLine(bl, tl);
            Gizmos.DrawLine(tl, tr);
            Gizmos.DrawLine(tr, br);
            Gizmos.DrawLine(br, bl);
        }


        // Draw Rectangles
        void DrawDottedRectangle(Vector3 bl, Vector3 tl, Vector3 tr, Vector3 br, Color color)
        {
            var cam = Camera.current;
            float dotSpacing = (cam.WorldToScreenPoint(br).x - cam.WorldToScreenPoint(bl).x) / 75f;
            UnityEditor.Handles.color = color;

            UnityEditor.Handles.DrawDottedLine(bl, tl, dotSpacing);
            UnityEditor.Handles.DrawDottedLine(tl, tr, dotSpacing);
            UnityEditor.Handles.DrawDottedLine(tr, br, dotSpacing);
            UnityEditor.Handles.DrawDottedLine(br, bl, dotSpacing);
        }
        #endif
    }
}



2.97 Текст программы «TMP_TextSelector_A.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using UnityEngine.EventSystems;
using System.Collections;


namespace TMPro.Examples
{

    public class TMP_TextSelector_A : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler
    {
        private TextMeshPro m_TextMeshPro;

        private Camera m_Camera;

        private bool m_isHoveringObject;
        private int m_selectedLink = -1;
        private int m_lastCharIndex = -1;
        private int m_lastWordIndex = -1;

        void Awake()
        {
            m_TextMeshPro = gameObject.GetComponent<TextMeshPro>();
            m_Camera = Camera.main;

            // Force generation of the text object so we have valid data to work with. This is needed since LateUpdate() will be called before the text object has a chance to generated when entering play mode.
            m_TextMeshPro.ForceMeshUpdate();
        }


        void LateUpdate()
        {
            m_isHoveringObject = false;

            if (TMP_TextUtilities.IsIntersectingRectTransform(m_TextMeshPro.rectTransform, Input.mousePosition, Camera.main))
            {
                m_isHoveringObject = true;
            }

            if (m_isHoveringObject)
            {
                #region Example of Character Selection
                int charIndex = TMP_TextUtilities.FindIntersectingCharacter(m_TextMeshPro, Input.mousePosition, Camera.main, true);
                if (charIndex != -1 && charIndex != m_lastCharIndex && (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)))
                {
                    //Debug.Log("[" + m_TextMeshPro.textInfo.characterInfo[charIndex].character + "] has been selected.");

                    m_lastCharIndex = charIndex;

                    int meshIndex = m_TextMeshPro.textInfo.characterInfo[charIndex].materialReferenceIndex;

                    int vertexIndex = m_TextMeshPro.textInfo.characterInfo[charIndex].vertexIndex;

                    Color32 c = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255);

                    Color32[] vertexColors = m_TextMeshPro.textInfo.meshInfo[meshIndex].colors32;

                    vertexColors[vertexIndex + 0] = c;
                    vertexColors[vertexIndex + 1] = c;
                    vertexColors[vertexIndex + 2] = c;
                    vertexColors[vertexIndex + 3] = c;

                    //m_TextMeshPro.mesh.colors32 = vertexColors;
                    m_TextMeshPro.textInfo.meshInfo[meshIndex].mesh.colors32 = vertexColors;
                }
                #endregion

                #region Example of Link Handling
                // Check if mouse intersects with any links.
                int linkIndex = TMP_TextUtilities.FindIntersectingLink(m_TextMeshPro, Input.mousePosition, m_Camera);

                // Clear previous link selection if one existed.
                if ((linkIndex == -1 && m_selectedLink != -1) || linkIndex != m_selectedLink)
                {
                    //m_TextPopup_RectTransform.gameObject.SetActive(false);
                    m_selectedLink = -1;
                }

                // Handle new Link selection.
                if (linkIndex != -1 && linkIndex != m_selectedLink)
                {
                    m_selectedLink = linkIndex;

                    TMP_LinkInfo linkInfo = m_TextMeshPro.textInfo.linkInfo[linkIndex];

                    // The following provides an example of how to access the link properties.
                    //Debug.Log("Link ID: \"" + linkInfo.GetLinkID() + "\"   Link Text: \"" + linkInfo.GetLinkText() + "\""); // Example of how to retrieve the Link ID and Link Text.

                    Vector3 worldPointInRectangle;

                    RectTransformUtility.ScreenPointToWorldPointInRectangle(m_TextMeshPro.rectTransform, Input.mousePosition, m_Camera, out worldPointInRectangle);

                    switch (linkInfo.GetLinkID())
                    {
                        case "id_01": // 100041637: // id_01
                                      //m_TextPopup_RectTransform.position = worldPointInRectangle;
                                      //m_TextPopup_RectTransform.gameObject.SetActive(true);
                                      //m_TextPopup_TMPComponent.text = k_LinkText + " ID 01";
                            break;
                        case "id_02": // 100041638: // id_02
                                      //m_TextPopup_RectTransform.position = worldPointInRectangle;
                                      //m_TextPopup_RectTransform.gameObject.SetActive(true);
                                      //m_TextPopup_TMPComponent.text = k_LinkText + " ID 02";
                            break;
                    }
                }
                #endregion


                #region Example of Word Selection
                // Check if Mouse intersects any words and if so assign a random color to that word.
                int wordIndex = TMP_TextUtilities.FindIntersectingWord(m_TextMeshPro, Input.mousePosition, Camera.main);
                if (wordIndex != -1 && wordIndex != m_lastWordIndex)
                {
                    m_lastWordIndex = wordIndex;

                    TMP_WordInfo wInfo = m_TextMeshPro.textInfo.wordInfo[wordIndex];

                    Vector3 wordPOS = m_TextMeshPro.transform.TransformPoint(m_TextMeshPro.textInfo.characterInfo[wInfo.firstCharacterIndex].bottomLeft);
                    wordPOS = Camera.main.WorldToScreenPoint(wordPOS);

                    //Debug.Log("Mouse Position: " + Input.mousePosition.ToString("f3") + "  Word Position: " + wordPOS.ToString("f3"));

                    Color32[] vertexColors = m_TextMeshPro.textInfo.meshInfo[0].colors32;

                    Color32 c = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255);
                    for (int i = 0; i < wInfo.characterCount; i++)
                    {
                        int vertexIndex = m_TextMeshPro.textInfo.characterInfo[wInfo.firstCharacterIndex + i].vertexIndex;

                        vertexColors[vertexIndex + 0] = c;
                        vertexColors[vertexIndex + 1] = c;
                        vertexColors[vertexIndex + 2] = c;
                        vertexColors[vertexIndex + 3] = c;
                    }

                    m_TextMeshPro.mesh.colors32 = vertexColors;
                }
                #endregion
            }
        }


        public void OnPointerEnter(PointerEventData eventData)
        {
            Debug.Log("OnPointerEnter()");
            m_isHoveringObject = true;
        }


        public void OnPointerExit(PointerEventData eventData)
        {
            Debug.Log("OnPointerExit()");
            m_isHoveringObject = false;
        }

    }
}


2.98 Текст программы «TMP_TextSelector_B.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using System.Collections;
using System.Collections.Generic;


#pragma warning disable 0618 // Disabled warning due to SetVertices being deprecated until new release with SetMesh() is available.

namespace TMPro.Examples
{

    public class TMP_TextSelector_B : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerClickHandler, IPointerUpHandler
    {
        public RectTransform TextPopup_Prefab_01;

        private RectTransform m_TextPopup_RectTransform;
        private TextMeshProUGUI m_TextPopup_TMPComponent;
        private const string k_LinkText = "You have selected link <#ffff00>";
        private const string k_WordText = "Word Index: <#ffff00>";


        private TextMeshProUGUI m_TextMeshPro;
        private Canvas m_Canvas;
        private Camera m_Camera;

        // Flags
        private bool isHoveringObject;
        private int m_selectedWord = -1;
        private int m_selectedLink = -1;
        private int m_lastIndex = -1;

        private Matrix4x4 m_matrix;

        private TMP_MeshInfo[] m_cachedMeshInfoVertexData;

        void Awake()
        {
            m_TextMeshPro = gameObject.GetComponent<TextMeshProUGUI>();


            m_Canvas = gameObject.GetComponentInParent<Canvas>();

            // Get a reference to the camera if Canvas Render Mode is not ScreenSpace Overlay.
            if (m_Canvas.renderMode == RenderMode.ScreenSpaceOverlay)
                m_Camera = null;
            else
                m_Camera = m_Canvas.worldCamera;

            // Create pop-up text object which is used to show the link information.
            m_TextPopup_RectTransform = Instantiate(TextPopup_Prefab_01) as RectTransform;
            m_TextPopup_RectTransform.SetParent(m_Canvas.transform, false);
            m_TextPopup_TMPComponent = m_TextPopup_RectTransform.GetComponentInChildren<TextMeshProUGUI>();
            m_TextPopup_RectTransform.gameObject.SetActive(false);
        }


        void OnEnable()
        {
            // Subscribe to event fired when text object has been regenerated.
            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
        }

        void OnDisable()
        {
            // UnSubscribe to event fired when text object has been regenerated.
            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
        }


        void ON_TEXT_CHANGED(Object obj)
        {
            if (obj == m_TextMeshPro)
            {
                // Update cached vertex data.
                m_cachedMeshInfoVertexData = m_TextMeshPro.textInfo.CopyMeshInfoVertexData();
            }
        }


        void LateUpdate()
        {
            if (isHoveringObject)
            {
                // Check if Mouse Intersects any of the characters. If so, assign a random color.
                #region Handle Character Selection
                int charIndex = TMP_TextUtilities.FindIntersectingCharacter(m_TextMeshPro, Input.mousePosition, m_Camera, true);

                // Undo Swap and Vertex Attribute changes.
                if (charIndex == -1 || charIndex != m_lastIndex)
                {
                    RestoreCachedVertexAttributes(m_lastIndex);
                    m_lastIndex = -1;
                }

                if (charIndex != -1 && charIndex != m_lastIndex && (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)))
                {
                    m_lastIndex = charIndex;

                    // Get the index of the material / sub text object used by this character.
                    int materialIndex = m_TextMeshPro.textInfo.characterInfo[charIndex].materialReferenceIndex;

                    // Get the index of the first vertex of the selected character.
                    int vertexIndex = m_TextMeshPro.textInfo.characterInfo[charIndex].vertexIndex;

                    // Get a reference to the vertices array.
                    Vector3[] vertices = m_TextMeshPro.textInfo.meshInfo[materialIndex].vertices;

                    // Determine the center point of the character.
                    Vector2 charMidBasline = (vertices[vertexIndex + 0] + vertices[vertexIndex + 2]) / 2;

                    // Need to translate all 4 vertices of the character to aligned with middle of character / baseline.
                    // This is needed so the matrix TRS is applied at the origin for each character.
                    Vector3 offset = charMidBasline;

                    // Translate the character to the middle baseline.
                    vertices[vertexIndex + 0] = vertices[vertexIndex + 0] - offset;
                    vertices[vertexIndex + 1] = vertices[vertexIndex + 1] - offset;
                    vertices[vertexIndex + 2] = vertices[vertexIndex + 2] - offset;
                    vertices[vertexIndex + 3] = vertices[vertexIndex + 3] - offset;

                    float zoomFactor = 1.5f;

                    // Setup the Matrix for the scale change.
                    m_matrix = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, Vector3.one * zoomFactor);

                    // Apply Matrix operation on the given character.
                    vertices[vertexIndex + 0] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 0]);
                    vertices[vertexIndex + 1] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 1]);
                    vertices[vertexIndex + 2] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 2]);
                    vertices[vertexIndex + 3] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 3]);

                    // Translate the character back to its original position.
                    vertices[vertexIndex + 0] = vertices[vertexIndex + 0] + offset;
                    vertices[vertexIndex + 1] = vertices[vertexIndex + 1] + offset;
                    vertices[vertexIndex + 2] = vertices[vertexIndex + 2] + offset;
                    vertices[vertexIndex + 3] = vertices[vertexIndex + 3] + offset;

                    // Change Vertex Colors of the highlighted character
                    Color32 c = new Color32(255, 255, 192, 255);

                    // Get a reference to the vertex color
                    Color32[] vertexColors = m_TextMeshPro.textInfo.meshInfo[materialIndex].colors32;

                    vertexColors[vertexIndex + 0] = c;
                    vertexColors[vertexIndex + 1] = c;
                    vertexColors[vertexIndex + 2] = c;
                    vertexColors[vertexIndex + 3] = c;


                    // Get a reference to the meshInfo of the selected character.
                    TMP_MeshInfo meshInfo = m_TextMeshPro.textInfo.meshInfo[materialIndex];

                    // Get the index of the last character's vertex attributes.
                    int lastVertexIndex = vertices.Length - 4;

                    // Swap the current character's vertex attributes with those of the last element in the vertex attribute arrays.
                    // We do this to make sure this character is rendered last and over other characters.
                    meshInfo.SwapVertexData(vertexIndex, lastVertexIndex);

                    // Need to update the appropriate 
                    m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
                }
                #endregion


                #region Word Selection Handling
                //Check if Mouse intersects any words and if so assign a random color to that word.
                int wordIndex = TMP_TextUtilities.FindIntersectingWord(m_TextMeshPro, Input.mousePosition, m_Camera);

                // Clear previous word selection.
                if (m_TextPopup_RectTransform != null && m_selectedWord != -1 && (wordIndex == -1 || wordIndex != m_selectedWord))
                {
                    TMP_WordInfo wInfo = m_TextMeshPro.textInfo.wordInfo[m_selectedWord];

                    // Iterate through each of the characters of the word.
                    for (int i = 0; i < wInfo.characterCount; i++)
                    {
                        int characterIndex = wInfo.firstCharacterIndex + i;

                        // Get the index of the material / sub text object used by this character.
                        int meshIndex = m_TextMeshPro.textInfo.characterInfo[characterIndex].materialReferenceIndex;

                        // Get the index of the first vertex of this character.
                        int vertexIndex = m_TextMeshPro.textInfo.characterInfo[characterIndex].vertexIndex;

                        // Get a reference to the vertex color
                        Color32[] vertexColors = m_TextMeshPro.textInfo.meshInfo[meshIndex].colors32;

                        Color32 c = vertexColors[vertexIndex + 0].Tint(1.33333f);

                        vertexColors[vertexIndex + 0] = c;
                        vertexColors[vertexIndex + 1] = c;
                        vertexColors[vertexIndex + 2] = c;
                        vertexColors[vertexIndex + 3] = c;
                    }

                    // Update Geometry
                    m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);

                    m_selectedWord = -1;
                }


                // Word Selection Handling
                if (wordIndex != -1 && wordIndex != m_selectedWord && !(Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)))
                {
                    m_selectedWord = wordIndex;

                    TMP_WordInfo wInfo = m_TextMeshPro.textInfo.wordInfo[wordIndex];

                    // Iterate through each of the characters of the word.
                    for (int i = 0; i < wInfo.characterCount; i++)
                    {
                        int characterIndex = wInfo.firstCharacterIndex + i;

                        // Get the index of the material / sub text object used by this character.
                        int meshIndex = m_TextMeshPro.textInfo.characterInfo[characterIndex].materialReferenceIndex;

                        int vertexIndex = m_TextMeshPro.textInfo.characterInfo[characterIndex].vertexIndex;

                        // Get a reference to the vertex color
                        Color32[] vertexColors = m_TextMeshPro.textInfo.meshInfo[meshIndex].colors32;

                        Color32 c = vertexColors[vertexIndex + 0].Tint(0.75f);

                        vertexColors[vertexIndex + 0] = c;
                        vertexColors[vertexIndex + 1] = c;
                        vertexColors[vertexIndex + 2] = c;
                        vertexColors[vertexIndex + 3] = c;
                    }

                    // Update Geometry
                    m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);

                }
                #endregion


                #region Example of Link Handling
                // Check if mouse intersects with any links.
                int linkIndex = TMP_TextUtilities.FindIntersectingLink(m_TextMeshPro, Input.mousePosition, m_Camera);

                // Clear previous link selection if one existed.
                if ((linkIndex == -1 && m_selectedLink != -1) || linkIndex != m_selectedLink)
                {
                    m_TextPopup_RectTransform.gameObject.SetActive(false);
                    m_selectedLink = -1;
                }

                // Handle new Link selection.
                if (linkIndex != -1 && linkIndex != m_selectedLink)
                {
                    m_selectedLink = linkIndex;

                    TMP_LinkInfo linkInfo = m_TextMeshPro.textInfo.linkInfo[linkIndex];

                    // Debug.Log("Link ID: \"" + linkInfo.GetLinkID() + "\"   Link Text: \"" + linkInfo.GetLinkText() + "\""); // Example of how to retrieve the Link ID and Link Text.

                    Vector3 worldPointInRectangle;
                    RectTransformUtility.ScreenPointToWorldPointInRectangle(m_TextMeshPro.rectTransform, Input.mousePosition, m_Camera, out worldPointInRectangle);

                    switch (linkInfo.GetLinkID())
                    {
                        case "id_01": // 100041637: // id_01
                            m_TextPopup_RectTransform.position = worldPointInRectangle;
                            m_TextPopup_RectTransform.gameObject.SetActive(true);
                            m_TextPopup_TMPComponent.text = k_LinkText + " ID 01";
                            break;
                        case "id_02": // 100041638: // id_02
                            m_TextPopup_RectTransform.position = worldPointInRectangle;
                            m_TextPopup_RectTransform.gameObject.SetActive(true);
                            m_TextPopup_TMPComponent.text = k_LinkText + " ID 02";
                            break;
                    }
                }
                #endregion

            }
            else
            {
                // Restore any character that may have been modified
                if (m_lastIndex != -1)
                {
                    RestoreCachedVertexAttributes(m_lastIndex);
                    m_lastIndex = -1;
                }
            }
            
        }


        public void OnPointerEnter(PointerEventData eventData)
        {
            //Debug.Log("OnPointerEnter()");
            isHoveringObject = true;
        }


        public void OnPointerExit(PointerEventData eventData)
        {
            //Debug.Log("OnPointerExit()");
            isHoveringObject = false;
        }


        public void OnPointerClick(PointerEventData eventData)
        {
            //Debug.Log("Click at POS: " + eventData.position + "  World POS: " + eventData.worldPosition);

            // Check if Mouse Intersects any of the characters. If so, assign a random color.
            #region Character Selection Handling
            /*
            int charIndex = TMP_TextUtilities.FindIntersectingCharacter(m_TextMeshPro, Input.mousePosition, m_Camera, true);
            if (charIndex != -1 && charIndex != m_lastIndex)
            {
                //Debug.Log("Character [" + m_TextMeshPro.textInfo.characterInfo[index].character + "] was selected at POS: " + eventData.position);
                m_lastIndex = charIndex;

                Color32 c = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255);
                int vertexIndex = m_TextMeshPro.textInfo.characterInfo[charIndex].vertexIndex;

                UIVertex[] uiVertices = m_TextMeshPro.textInfo.meshInfo.uiVertices;

                uiVertices[vertexIndex + 0].color = c;
                uiVertices[vertexIndex + 1].color = c;
                uiVertices[vertexIndex + 2].color = c;
                uiVertices[vertexIndex + 3].color = c;

                m_TextMeshPro.canvasRenderer.SetVertices(uiVertices, uiVertices.Length);
            }
            */
            #endregion


            #region Word Selection Handling
            //Check if Mouse intersects any words and if so assign a random color to that word.
            /*
            int wordIndex = TMP_TextUtilities.FindIntersectingWord(m_TextMeshPro, Input.mousePosition, m_Camera);

            // Clear previous word selection.
            if (m_TextPopup_RectTransform != null && m_selectedWord != -1 && (wordIndex == -1 || wordIndex != m_selectedWord))
            {
                TMP_WordInfo wInfo = m_TextMeshPro.textInfo.wordInfo[m_selectedWord];

                // Get a reference to the uiVertices array.
                UIVertex[] uiVertices = m_TextMeshPro.textInfo.meshInfo.uiVertices;

                // Iterate through each of the characters of the word.
                for (int i = 0; i < wInfo.characterCount; i++)
                {
                    int vertexIndex = m_TextMeshPro.textInfo.characterInfo[wInfo.firstCharacterIndex + i].vertexIndex;

                    Color32 c = uiVertices[vertexIndex + 0].color.Tint(1.33333f);

                    uiVertices[vertexIndex + 0].color = c;
                    uiVertices[vertexIndex + 1].color = c;
                    uiVertices[vertexIndex + 2].color = c;
                    uiVertices[vertexIndex + 3].color = c;
                }

                m_TextMeshPro.canvasRenderer.SetVertices(uiVertices, uiVertices.Length);

                m_selectedWord = -1;
            }

            // Handle word selection
            if (wordIndex != -1 && wordIndex != m_selectedWord)
            {
                m_selectedWord = wordIndex;

                TMP_WordInfo wInfo = m_TextMeshPro.textInfo.wordInfo[wordIndex];

                // Get a reference to the uiVertices array.
                UIVertex[] uiVertices = m_TextMeshPro.textInfo.meshInfo.uiVertices;

                // Iterate through each of the characters of the word.
                for (int i = 0; i < wInfo.characterCount; i++)
                {
                    int vertexIndex = m_TextMeshPro.textInfo.characterInfo[wInfo.firstCharacterIndex + i].vertexIndex;

                    Color32 c = uiVertices[vertexIndex + 0].color.Tint(0.75f);

                    uiVertices[vertexIndex + 0].color = c;
                    uiVertices[vertexIndex + 1].color = c;
                    uiVertices[vertexIndex + 2].color = c;
                    uiVertices[vertexIndex + 3].color = c;
                }

                m_TextMeshPro.canvasRenderer.SetVertices(uiVertices, uiVertices.Length);
            }
            */
            #endregion


            #region Link Selection Handling
            /*
            // Check if Mouse intersects any words and if so assign a random color to that word.
            int linkIndex = TMP_TextUtilities.FindIntersectingLink(m_TextMeshPro, Input.mousePosition, m_Camera);
            if (linkIndex != -1)
            {
                TMP_LinkInfo linkInfo = m_TextMeshPro.textInfo.linkInfo[linkIndex];
                int linkHashCode = linkInfo.hashCode;

                //Debug.Log(TMP_TextUtilities.GetSimpleHashCode("id_02"));

                switch (linkHashCode)
                {
                    case 291445: // id_01
                        if (m_LinkObject01 == null)
                            m_LinkObject01 = Instantiate(Link_01_Prefab);
                        else
                        {
                            m_LinkObject01.gameObject.SetActive(true);
                        }

                        break;
                    case 291446: // id_02
                        break;

                }

                // Example of how to modify vertex attributes like colors
                #region Vertex Attribute Modification Example
                UIVertex[] uiVertices = m_TextMeshPro.textInfo.meshInfo.uiVertices;

                Color32 c = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255);
                for (int i = 0; i < linkInfo.characterCount; i++)
                {
                    TMP_CharacterInfo cInfo = m_TextMeshPro.textInfo.characterInfo[linkInfo.firstCharacterIndex + i];

                    if (!cInfo.isVisible) continue; // Skip invisible characters.

                    int vertexIndex = cInfo.vertexIndex;

                    uiVertices[vertexIndex + 0].color = c;
                    uiVertices[vertexIndex + 1].color = c;
                    uiVertices[vertexIndex + 2].color = c;
                    uiVertices[vertexIndex + 3].color = c;
                }

                m_TextMeshPro.canvasRenderer.SetVertices(uiVertices, uiVertices.Length);
                #endregion
            }
            */
            #endregion
        }


        public void OnPointerUp(PointerEventData eventData)
        {
            //Debug.Log("OnPointerUp()");
        }


        void RestoreCachedVertexAttributes(int index)
        {
            if (index == -1 || index > m_TextMeshPro.textInfo.characterCount - 1) return;

            // Get the index of the material / sub text object used by this character.
            int materialIndex = m_TextMeshPro.textInfo.characterInfo[index].materialReferenceIndex;

            // Get the index of the first vertex of the selected character.
            int vertexIndex = m_TextMeshPro.textInfo.characterInfo[index].vertexIndex;

            // Restore Vertices
            // Get a reference to the cached / original vertices.
            Vector3[] src_vertices = m_cachedMeshInfoVertexData[materialIndex].vertices;

            // Get a reference to the vertices that we need to replace.
            Vector3[] dst_vertices = m_TextMeshPro.textInfo.meshInfo[materialIndex].vertices;

            // Restore / Copy vertices from source to destination
            dst_vertices[vertexIndex + 0] = src_vertices[vertexIndex + 0];
            dst_vertices[vertexIndex + 1] = src_vertices[vertexIndex + 1];
            dst_vertices[vertexIndex + 2] = src_vertices[vertexIndex + 2];
            dst_vertices[vertexIndex + 3] = src_vertices[vertexIndex + 3];

            // Restore Vertex Colors
            // Get a reference to the vertex colors we need to replace.
            Color32[] dst_colors = m_TextMeshPro.textInfo.meshInfo[materialIndex].colors32;

            // Get a reference to the cached / original vertex colors.
            Color32[] src_colors = m_cachedMeshInfoVertexData[materialIndex].colors32;

            // Copy the vertex colors from source to destination.
            dst_colors[vertexIndex + 0] = src_colors[vertexIndex + 0];
            dst_colors[vertexIndex + 1] = src_colors[vertexIndex + 1];
            dst_colors[vertexIndex + 2] = src_colors[vertexIndex + 2];
            dst_colors[vertexIndex + 3] = src_colors[vertexIndex + 3];

            // Restore UV0S
            // UVS0
            Vector2[] src_uv0s = m_cachedMeshInfoVertexData[materialIndex].uvs0;
            Vector2[] dst_uv0s = m_TextMeshPro.textInfo.meshInfo[materialIndex].uvs0;
            dst_uv0s[vertexIndex + 0] = src_uv0s[vertexIndex + 0];
            dst_uv0s[vertexIndex + 1] = src_uv0s[vertexIndex + 1];
            dst_uv0s[vertexIndex + 2] = src_uv0s[vertexIndex + 2];
            dst_uv0s[vertexIndex + 3] = src_uv0s[vertexIndex + 3];

            // UVS2
            Vector2[] src_uv2s = m_cachedMeshInfoVertexData[materialIndex].uvs2;
            Vector2[] dst_uv2s = m_TextMeshPro.textInfo.meshInfo[materialIndex].uvs2;
            dst_uv2s[vertexIndex + 0] = src_uv2s[vertexIndex + 0];
            dst_uv2s[vertexIndex + 1] = src_uv2s[vertexIndex + 1];
            dst_uv2s[vertexIndex + 2] = src_uv2s[vertexIndex + 2];
            dst_uv2s[vertexIndex + 3] = src_uv2s[vertexIndex + 3];


            // Restore last vertex attribute as we swapped it as well
            int lastIndex = (src_vertices.Length / 4 - 1) * 4;

            // Vertices
            dst_vertices[lastIndex + 0] = src_vertices[lastIndex + 0];
            dst_vertices[lastIndex + 1] = src_vertices[lastIndex + 1];
            dst_vertices[lastIndex + 2] = src_vertices[lastIndex + 2];
            dst_vertices[lastIndex + 3] = src_vertices[lastIndex + 3];

            // Vertex Colors
            src_colors = m_cachedMeshInfoVertexData[materialIndex].colors32;
            dst_colors = m_TextMeshPro.textInfo.meshInfo[materialIndex].colors32;
            dst_colors[lastIndex + 0] = src_colors[lastIndex + 0];
            dst_colors[lastIndex + 1] = src_colors[lastIndex + 1];
            dst_colors[lastIndex + 2] = src_colors[lastIndex + 2];
            dst_colors[lastIndex + 3] = src_colors[lastIndex + 3];

            // UVS0
            src_uv0s = m_cachedMeshInfoVertexData[materialIndex].uvs0;
            dst_uv0s = m_TextMeshPro.textInfo.meshInfo[materialIndex].uvs0;
            dst_uv0s[lastIndex + 0] = src_uv0s[lastIndex + 0];
            dst_uv0s[lastIndex + 1] = src_uv0s[lastIndex + 1];
            dst_uv0s[lastIndex + 2] = src_uv0s[lastIndex + 2];
            dst_uv0s[lastIndex + 3] = src_uv0s[lastIndex + 3];

            // UVS2
            src_uv2s = m_cachedMeshInfoVertexData[materialIndex].uvs2;
            dst_uv2s = m_TextMeshPro.textInfo.meshInfo[materialIndex].uvs2;
            dst_uv2s[lastIndex + 0] = src_uv2s[lastIndex + 0];
            dst_uv2s[lastIndex + 1] = src_uv2s[lastIndex + 1];
            dst_uv2s[lastIndex + 2] = src_uv2s[lastIndex + 2];
            dst_uv2s[lastIndex + 3] = src_uv2s[lastIndex + 3];

            // Need to update the appropriate 
            m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
        }
    }
}


2.99 Текст программы «TMP_UiFrameRateCounter.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class TMP_UiFrameRateCounter : MonoBehaviour
    {
        public float UpdateInterval = 5.0f;
        private float m_LastInterval = 0;
        private int m_Frames = 0;

        public enum FpsCounterAnchorPositions { TopLeft, BottomLeft, TopRight, BottomRight };

        public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.TopRight;

        private string htmlColorTag;
        private const string fpsLabel = "{0:2}</color> <#8080ff>FPS \n<#FF8000>{1:2} <#8080ff>MS";

        private TextMeshProUGUI m_TextMeshPro;
        private RectTransform m_frameCounter_transform;

        private FpsCounterAnchorPositions last_AnchorPosition;

        void Awake()
        {
            if (!enabled)
                return;

            Application.targetFrameRate = 1000;

            GameObject frameCounter = new GameObject("Frame Counter");
            m_frameCounter_transform = frameCounter.AddComponent<RectTransform>();

            m_frameCounter_transform.SetParent(this.transform, false);

            m_TextMeshPro = frameCounter.AddComponent<TextMeshProUGUI>();
            m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF");
            m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay");

            m_TextMeshPro.enableWordWrapping = false;
            m_TextMeshPro.fontSize = 36;

            m_TextMeshPro.isOverlay = true;

            Set_FrameCounter_Position(AnchorPosition);
            last_AnchorPosition = AnchorPosition;
        }


        void Start()
        {
            m_LastInterval = Time.realtimeSinceStartup;
            m_Frames = 0;
        }


        void Update()
        {
            if (AnchorPosition != last_AnchorPosition)
                Set_FrameCounter_Position(AnchorPosition);

            last_AnchorPosition = AnchorPosition;

            m_Frames += 1;
            float timeNow = Time.realtimeSinceStartup;

            if (timeNow > m_LastInterval + UpdateInterval)
            {
                // display two fractional digits (f2 format)
                float fps = m_Frames / (timeNow - m_LastInterval);
                float ms = 1000.0f / Mathf.Max(fps, 0.00001f);

                if (fps < 30)
                    htmlColorTag = "<color=yellow>";
                else if (fps < 10)
                    htmlColorTag = "<color=red>";
                else
                    htmlColorTag = "<color=green>";

                m_TextMeshPro.SetText(htmlColorTag + fpsLabel, fps, ms);

                m_Frames = 0;
                m_LastInterval = timeNow;
            }
        }


        void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
        {
            switch (anchor_position)
            {
                case FpsCounterAnchorPositions.TopLeft:
                    m_TextMeshPro.alignment = TextAlignmentOptions.TopLeft;
                    m_frameCounter_transform.pivot = new Vector2(0, 1);
                    m_frameCounter_transform.anchorMin = new Vector2(0.01f, 0.99f);
                    m_frameCounter_transform.anchorMax = new Vector2(0.01f, 0.99f);
                    m_frameCounter_transform.anchoredPosition = new Vector2(0, 1);
                    break;
                case FpsCounterAnchorPositions.BottomLeft:
                    m_TextMeshPro.alignment = TextAlignmentOptions.BottomLeft;
                    m_frameCounter_transform.pivot = new Vector2(0, 0);
                    m_frameCounter_transform.anchorMin = new Vector2(0.01f, 0.01f);
                    m_frameCounter_transform.anchorMax = new Vector2(0.01f, 0.01f);
                    m_frameCounter_transform.anchoredPosition = new Vector2(0, 0);
                    break;
                case FpsCounterAnchorPositions.TopRight:
                    m_TextMeshPro.alignment = TextAlignmentOptions.TopRight;
                    m_frameCounter_transform.pivot = new Vector2(1, 1);
                    m_frameCounter_transform.anchorMin = new Vector2(0.99f, 0.99f);
                    m_frameCounter_transform.anchorMax = new Vector2(0.99f, 0.99f);
                    m_frameCounter_transform.anchoredPosition = new Vector2(1, 1);
                    break;
                case FpsCounterAnchorPositions.BottomRight:
                    m_TextMeshPro.alignment = TextAlignmentOptions.BottomRight;
                    m_frameCounter_transform.pivot = new Vector2(1, 0);
                    m_frameCounter_transform.anchorMin = new Vector2(0.99f, 0.01f);
                    m_frameCounter_transform.anchorMax = new Vector2(0.99f, 0.01f);
                    m_frameCounter_transform.anchoredPosition = new Vector2(1, 0);
                    break;
            }
        }
    }
}

2.100 Текст программы «TMPro_InstructionOverlay.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{
    
    public class TMPro_InstructionOverlay : MonoBehaviour
    {

        public enum FpsCounterAnchorPositions { TopLeft, BottomLeft, TopRight, BottomRight };

        public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.BottomLeft;

        private const string instructions = "Camera Control - <#ffff00>Shift + RMB\n</color>Zoom - <#ffff00>Mouse wheel.";

        private TextMeshPro m_TextMeshPro;
        private TextContainer m_textContainer;
        private Transform m_frameCounter_transform;
        private Camera m_camera;

        //private FpsCounterAnchorPositions last_AnchorPosition;

        void Awake()
        {
            if (!enabled)
                return;

            m_camera = Camera.main;

            GameObject frameCounter = new GameObject("Frame Counter");
            m_frameCounter_transform = frameCounter.transform;
            m_frameCounter_transform.parent = m_camera.transform;
            m_frameCounter_transform.localRotation = Quaternion.identity;


            m_TextMeshPro = frameCounter.AddComponent<TextMeshPro>();
            m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF");
            m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay");

            m_TextMeshPro.fontSize = 30;

            m_TextMeshPro.isOverlay = true;
            m_textContainer = frameCounter.GetComponent<TextContainer>();

            Set_FrameCounter_Position(AnchorPosition);
            //last_AnchorPosition = AnchorPosition;

            m_TextMeshPro.text = instructions;

        }




        void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
        {

            switch (anchor_position)
            {
                case FpsCounterAnchorPositions.TopLeft:
                    //m_TextMeshPro.anchor = AnchorPositions.TopLeft;
                    m_textContainer.anchorPosition = TextContainerAnchors.TopLeft;
                    m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0, 1, 100.0f));
                    break;
                case FpsCounterAnchorPositions.BottomLeft:
                    //m_TextMeshPro.anchor = AnchorPositions.BottomLeft;
                    m_textContainer.anchorPosition = TextContainerAnchors.BottomLeft;
                    m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0, 0, 100.0f));
                    break;
                case FpsCounterAnchorPositions.TopRight:
                    //m_TextMeshPro.anchor = AnchorPositions.TopRight;
                    m_textContainer.anchorPosition = TextContainerAnchors.TopRight;
                    m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1, 1, 100.0f));
                    break;
                case FpsCounterAnchorPositions.BottomRight:
                    //m_TextMeshPro.anchor = AnchorPositions.BottomRight;
                    m_textContainer.anchorPosition = TextContainerAnchors.BottomRight;
                    m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1, 0, 100.0f));
                    break;
            }
        }
    }
}


2.101 Текст программы «VertexColorCycler.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{

    public class VertexColorCycler : MonoBehaviour
    {

        private TMP_Text m_TextComponent;

        void Awake()
        {
            m_TextComponent = GetComponent<TMP_Text>();
        }


        void Start()
        {
            StartCoroutine(AnimateVertexColors());
        }


        /// <summary>
        /// Method to animate vertex colors of a TMP Text object.
        /// </summary>
        /// <returns></returns>
        IEnumerator AnimateVertexColors()
        {
            // Force the text object to update right away so we can have geometry to modify right from the start.
            m_TextComponent.ForceMeshUpdate();

            TMP_TextInfo textInfo = m_TextComponent.textInfo;
            int currentCharacter = 0;

            Color32[] newVertexColors;
            Color32 c0 = m_TextComponent.color;

            while (true)
            {
                int characterCount = textInfo.characterCount;

                // If No Characters then just yield and wait for some text to be added
                if (characterCount == 0)
                {
                    yield return new WaitForSeconds(0.25f);
                    continue;
                }

                // Get the index of the material used by the current character.
                int materialIndex = textInfo.characterInfo[currentCharacter].materialReferenceIndex;

                // Get the vertex colors of the mesh used by this text element (character or sprite).
                newVertexColors = textInfo.meshInfo[materialIndex].colors32;

                // Get the index of the first vertex used by this text element.
                int vertexIndex = textInfo.characterInfo[currentCharacter].vertexIndex;

                // Only change the vertex color if the text element is visible.
                if (textInfo.characterInfo[currentCharacter].isVisible)
                {
                    c0 = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255);

                    newVertexColors[vertexIndex + 0] = c0;
                    newVertexColors[vertexIndex + 1] = c0;
                    newVertexColors[vertexIndex + 2] = c0;
                    newVertexColors[vertexIndex + 3] = c0;

                    // New function which pushes (all) updated vertex data to the appropriate meshes when using either the Mesh Renderer or CanvasRenderer.
                    m_TextComponent.UpdateVertexData(TMP_VertexDataUpdateFlags.Colors32);

                    // This last process could be done to only update the vertex data that has changed as opposed to all of the vertex data but it would require extra steps and knowing what type of renderer is used.
                    // These extra steps would be a performance optimization but it is unlikely that such optimization will be necessary.
                }

                currentCharacter = (currentCharacter + 1) % characterCount;

                yield return new WaitForSeconds(0.05f);
            }
        }

    }
}


2.102 Текст программы «VertexJitter.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{

    public class VertexJitter : MonoBehaviour
    {

        public float AngleMultiplier = 1.0f;
        public float SpeedMultiplier = 1.0f;
        public float CurveScale = 1.0f;

        private TMP_Text m_TextComponent;
        private bool hasTextChanged;

        /// <summary>
        /// Structure to hold pre-computed animation data.
        /// </summary>
        private struct VertexAnim
        {
            public float angleRange;
            public float angle;
            public float speed;
        }

        void Awake()
        {
            m_TextComponent = GetComponent<TMP_Text>();
        }

        void OnEnable()
        {
            // Subscribe to event fired when text object has been regenerated.
            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
        }

        void OnDisable()
        {
            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
        }


        void Start()
        {
            StartCoroutine(AnimateVertexColors());
        }


        void ON_TEXT_CHANGED(Object obj)
        {
            if (obj == m_TextComponent)
                hasTextChanged = true;
        }

        /// <summary>
        /// Method to animate vertex colors of a TMP Text object.
        /// </summary>
        /// <returns></returns>
        IEnumerator AnimateVertexColors()
        {

            // We force an update of the text object since it would only be updated at the end of the frame. Ie. before this code is executed on the first frame.
            // Alternatively, we could yield and wait until the end of the frame when the text object will be generated.
            m_TextComponent.ForceMeshUpdate();

            TMP_TextInfo textInfo = m_TextComponent.textInfo;

            Matrix4x4 matrix;

            int loopCount = 0;
            hasTextChanged = true;

            // Create an Array which contains pre-computed Angle Ranges and Speeds for a bunch of characters.
            VertexAnim[] vertexAnim = new VertexAnim[1024];
            for (int i = 0; i < 1024; i++)
            {
                vertexAnim[i].angleRange = Random.Range(10f, 25f);
                vertexAnim[i].speed = Random.Range(1f, 3f);
            }

            // Cache the vertex data of the text object as the Jitter FX is applied to the original position of the characters.
            TMP_MeshInfo[] cachedMeshInfo = textInfo.CopyMeshInfoVertexData();

            while (true)
            {
                // Get new copy of vertex data if the text has changed.
                if (hasTextChanged)
                {
                    // Update the copy of the vertex data for the text object.
                    cachedMeshInfo = textInfo.CopyMeshInfoVertexData();

                    hasTextChanged = false;
                }

                int characterCount = textInfo.characterCount;

                // If No Characters then just yield and wait for some text to be added
                if (characterCount == 0)
                {
                    yield return new WaitForSeconds(0.25f);
                    continue;
                }


                for (int i = 0; i < characterCount; i++)
                {
                    TMP_CharacterInfo charInfo = textInfo.characterInfo[i];

                    // Skip characters that are not visible and thus have no geometry to manipulate.
                    if (!charInfo.isVisible)
                        continue;

                    // Retrieve the pre-computed animation data for the given character.
                    VertexAnim vertAnim = vertexAnim[i];

                    // Get the index of the material used by the current character.
                    int materialIndex = textInfo.characterInfo[i].materialReferenceIndex;

                    // Get the index of the first vertex used by this text element.
                    int vertexIndex = textInfo.characterInfo[i].vertexIndex;

                    // Get the cached vertices of the mesh used by this text element (character or sprite).
                    Vector3[] sourceVertices = cachedMeshInfo[materialIndex].vertices;

                    // Determine the center point of each character at the baseline.
                    //Vector2 charMidBasline = new Vector2((sourceVertices[vertexIndex + 0].x + sourceVertices[vertexIndex + 2].x) / 2, charInfo.baseLine);
                    // Determine the center point of each character.
                    Vector2 charMidBasline = (sourceVertices[vertexIndex + 0] + sourceVertices[vertexIndex + 2]) / 2;

                    // Need to translate all 4 vertices of each quad to aligned with middle of character / baseline.
                    // This is needed so the matrix TRS is applied at the origin for each character.
                    Vector3 offset = charMidBasline;

                    Vector3[] destinationVertices = textInfo.meshInfo[materialIndex].vertices;

                    destinationVertices[vertexIndex + 0] = sourceVertices[vertexIndex + 0] - offset;
                    destinationVertices[vertexIndex + 1] = sourceVertices[vertexIndex + 1] - offset;
                    destinationVertices[vertexIndex + 2] = sourceVertices[vertexIndex + 2] - offset;
                    destinationVertices[vertexIndex + 3] = sourceVertices[vertexIndex + 3] - offset;

                    vertAnim.angle = Mathf.SmoothStep(-vertAnim.angleRange, vertAnim.angleRange, Mathf.PingPong(loopCount / 25f * vertAnim.speed, 1f));
                    Vector3 jitterOffset = new Vector3(Random.Range(-.25f, .25f), Random.Range(-.25f, .25f), 0);

                    matrix = Matrix4x4.TRS(jitterOffset * CurveScale, Quaternion.Euler(0, 0, Random.Range(-5f, 5f) * AngleMultiplier), Vector3.one);

                    destinationVertices[vertexIndex + 0] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 0]);
                    destinationVertices[vertexIndex + 1] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 1]);
                    destinationVertices[vertexIndex + 2] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 2]);
                    destinationVertices[vertexIndex + 3] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 3]);

                    destinationVertices[vertexIndex + 0] += offset;
                    destinationVertices[vertexIndex + 1] += offset;
                    destinationVertices[vertexIndex + 2] += offset;
                    destinationVertices[vertexIndex + 3] += offset;

                    vertexAnim[i] = vertAnim;
                }

                // Push changes into meshes
                for (int i = 0; i < textInfo.meshInfo.Length; i++)
                {
                    textInfo.meshInfo[i].mesh.vertices = textInfo.meshInfo[i].vertices;
                    m_TextComponent.UpdateGeometry(textInfo.meshInfo[i].mesh, i);
                }

                loopCount += 1;

                yield return new WaitForSeconds(0.1f);
            }
        }

    }
}

2.103 Текст программы «VertexShakeA.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{

    public class VertexShakeA : MonoBehaviour
    {

        public float AngleMultiplier = 1.0f;
        public float SpeedMultiplier = 1.0f;
        public float ScaleMultiplier = 1.0f;
        public float RotationMultiplier = 1.0f;

        private TMP_Text m_TextComponent;
        private bool hasTextChanged;


        void Awake()
        {
            m_TextComponent = GetComponent<TMP_Text>();
        }

        void OnEnable()
        {
            // Subscribe to event fired when text object has been regenerated.
            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
        }

        void OnDisable()
        {
            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
        }


        void Start()
        {
            StartCoroutine(AnimateVertexColors());
        }


        void ON_TEXT_CHANGED(Object obj)
        {
            if (obj = m_TextComponent)
                hasTextChanged = true;
        }

        /// <summary>
        /// Method to animate vertex colors of a TMP Text object.
        /// </summary>
        /// <returns></returns>
        IEnumerator AnimateVertexColors()
        {

            // We force an update of the text object since it would only be updated at the end of the frame. Ie. before this code is executed on the first frame.
            // Alternatively, we could yield and wait until the end of the frame when the text object will be generated.
            m_TextComponent.ForceMeshUpdate();

            TMP_TextInfo textInfo = m_TextComponent.textInfo;

            Matrix4x4 matrix;
            Vector3[][] copyOfVertices = new Vector3[0][];

            hasTextChanged = true;

            while (true)
            {
                // Allocate new vertices 
                if (hasTextChanged)
                {
                    if (copyOfVertices.Length < textInfo.meshInfo.Length)
                        copyOfVertices = new Vector3[textInfo.meshInfo.Length][];

                    for (int i = 0; i < textInfo.meshInfo.Length; i++)
                    {
                        int length = textInfo.meshInfo[i].vertices.Length;
                        copyOfVertices[i] = new Vector3[length];
                    }

                    hasTextChanged = false;
                }

                int characterCount = textInfo.characterCount;

                // If No Characters then just yield and wait for some text to be added
                if (characterCount == 0)
                {
                    yield return new WaitForSeconds(0.25f);
                    continue;
                }

                int lineCount = textInfo.lineCount;

                // Iterate through each line of the text.
                for (int i = 0; i < lineCount; i++)
                {

                    int first = textInfo.lineInfo[i].firstCharacterIndex;
                    int last = textInfo.lineInfo[i].lastCharacterIndex;

                    // Determine the center of each line
                    Vector3 centerOfLine = (textInfo.characterInfo[first].bottomLeft + textInfo.characterInfo[last].topRight) / 2;
                    Quaternion rotation = Quaternion.Euler(0, 0, Random.Range(-0.25f, 0.25f) * RotationMultiplier);

                    // Iterate through each character of the line.
                    for (int j = first; j <= last; j++)
                    {
                        // Skip characters that are not visible and thus have no geometry to manipulate.
                        if (!textInfo.characterInfo[j].isVisible)
                            continue;

                        // Get the index of the material used by the current character.
                        int materialIndex = textInfo.characterInfo[j].materialReferenceIndex;

                        // Get the index of the first vertex used by this text element.
                        int vertexIndex = textInfo.characterInfo[j].vertexIndex;

                        // Get the vertices of the mesh used by this text element (character or sprite).
                        Vector3[] sourceVertices = textInfo.meshInfo[materialIndex].vertices;

                        // Need to translate all 4 vertices of each quad to aligned with center of character.
                        // This is needed so the matrix TRS is applied at the origin for each character.
                        copyOfVertices[materialIndex][vertexIndex + 0] = sourceVertices[vertexIndex + 0] - centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 1] = sourceVertices[vertexIndex + 1] - centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 2] = sourceVertices[vertexIndex + 2] - centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 3] = sourceVertices[vertexIndex + 3] - centerOfLine;

                        // Determine the random scale change for each character.
                        float randomScale = Random.Range(0.995f - 0.001f * ScaleMultiplier, 1.005f + 0.001f * ScaleMultiplier);

                        // Setup the matrix rotation.
                        matrix = Matrix4x4.TRS(Vector3.one, rotation, Vector3.one * randomScale);

                        // Apply the matrix TRS to the individual characters relative to the center of the current line.
                        copyOfVertices[materialIndex][vertexIndex + 0] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 0]);
                        copyOfVertices[materialIndex][vertexIndex + 1] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 1]);
                        copyOfVertices[materialIndex][vertexIndex + 2] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 2]);
                        copyOfVertices[materialIndex][vertexIndex + 3] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 3]);

                        // Revert the translation change.
                        copyOfVertices[materialIndex][vertexIndex + 0] += centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 1] += centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 2] += centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 3] += centerOfLine;
                    }
                }

                // Push changes into meshes
                for (int i = 0; i < textInfo.meshInfo.Length; i++)
                {
                    textInfo.meshInfo[i].mesh.vertices = copyOfVertices[i];
                    m_TextComponent.UpdateGeometry(textInfo.meshInfo[i].mesh, i);
                }

                yield return new WaitForSeconds(0.1f);
            }
        }

    }
}

2.104 Текст программы «VertexShakeB.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{

    public class VertexShakeB : MonoBehaviour
    {

        public float AngleMultiplier = 1.0f;
        public float SpeedMultiplier = 1.0f;
        public float CurveScale = 1.0f;

        private TMP_Text m_TextComponent;
        private bool hasTextChanged;


        void Awake()
        {
            m_TextComponent = GetComponent<TMP_Text>();
        }

        void OnEnable()
        {
            // Subscribe to event fired when text object has been regenerated.
            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
        }

        void OnDisable()
        {
            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
        }


        void Start()
        {
            StartCoroutine(AnimateVertexColors());
        }


        void ON_TEXT_CHANGED(Object obj)
        {
            if (obj = m_TextComponent)
                hasTextChanged = true;
        }

        /// <summary>
        /// Method to animate vertex colors of a TMP Text object.
        /// </summary>
        /// <returns></returns>
        IEnumerator AnimateVertexColors()
        {

            // We force an update of the text object since it would only be updated at the end of the frame. Ie. before this code is executed on the first frame.
            // Alternatively, we could yield and wait until the end of the frame when the text object will be generated.
            m_TextComponent.ForceMeshUpdate();

            TMP_TextInfo textInfo = m_TextComponent.textInfo;

            Matrix4x4 matrix;
            Vector3[][] copyOfVertices = new Vector3[0][];

            hasTextChanged = true;

            while (true)
            {
                // Allocate new vertices 
                if (hasTextChanged)
                {
                    if (copyOfVertices.Length < textInfo.meshInfo.Length)
                        copyOfVertices = new Vector3[textInfo.meshInfo.Length][];

                    for (int i = 0; i < textInfo.meshInfo.Length; i++)
                    {
                        int length = textInfo.meshInfo[i].vertices.Length;
                        copyOfVertices[i] = new Vector3[length];
                    }

                    hasTextChanged = false;
                }

                int characterCount = textInfo.characterCount;

                // If No Characters then just yield and wait for some text to be added
                if (characterCount == 0)
                {
                    yield return new WaitForSeconds(0.25f);
                    continue;
                }

                int lineCount = textInfo.lineCount;

                // Iterate through each line of the text.
                for (int i = 0; i < lineCount; i++)
                {

                    int first = textInfo.lineInfo[i].firstCharacterIndex;
                    int last = textInfo.lineInfo[i].lastCharacterIndex;

                    // Determine the center of each line
                    Vector3 centerOfLine = (textInfo.characterInfo[first].bottomLeft + textInfo.characterInfo[last].topRight) / 2;
                    Quaternion rotation = Quaternion.Euler(0, 0, Random.Range(-0.25f, 0.25f));

                    // Iterate through each character of the line.
                    for (int j = first; j <= last; j++)
                    {
                        // Skip characters that are not visible and thus have no geometry to manipulate.
                        if (!textInfo.characterInfo[j].isVisible)
                            continue;

                        // Get the index of the material used by the current character.
                        int materialIndex = textInfo.characterInfo[j].materialReferenceIndex;

                        // Get the index of the first vertex used by this text element.
                        int vertexIndex = textInfo.characterInfo[j].vertexIndex;

                        // Get the vertices of the mesh used by this text element (character or sprite).
                        Vector3[] sourceVertices = textInfo.meshInfo[materialIndex].vertices;

                        // Determine the center point of each character at the baseline.
                        Vector3 charCenter = (sourceVertices[vertexIndex + 0] + sourceVertices[vertexIndex + 2]) / 2;

                        // Need to translate all 4 vertices of each quad to aligned with center of character.
                        // This is needed so the matrix TRS is applied at the origin for each character.
                        copyOfVertices[materialIndex][vertexIndex + 0] = sourceVertices[vertexIndex + 0] - charCenter;
                        copyOfVertices[materialIndex][vertexIndex + 1] = sourceVertices[vertexIndex + 1] - charCenter;
                        copyOfVertices[materialIndex][vertexIndex + 2] = sourceVertices[vertexIndex + 2] - charCenter;
                        copyOfVertices[materialIndex][vertexIndex + 3] = sourceVertices[vertexIndex + 3] - charCenter;

                        // Determine the random scale change for each character.
                        float randomScale = Random.Range(0.95f, 1.05f);

                        // Setup the matrix for the scale change.
                        matrix = Matrix4x4.TRS(Vector3.one, Quaternion.identity, Vector3.one * randomScale);

                        // Apply the scale change relative to the center of each character.
                        copyOfVertices[materialIndex][vertexIndex + 0] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 0]);
                        copyOfVertices[materialIndex][vertexIndex + 1] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 1]);
                        copyOfVertices[materialIndex][vertexIndex + 2] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 2]);
                        copyOfVertices[materialIndex][vertexIndex + 3] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 3]);

                        // Revert the translation change.
                        copyOfVertices[materialIndex][vertexIndex + 0] += charCenter;
                        copyOfVertices[materialIndex][vertexIndex + 1] += charCenter;
                        copyOfVertices[materialIndex][vertexIndex + 2] += charCenter;
                        copyOfVertices[materialIndex][vertexIndex + 3] += charCenter;

                        // Need to translate all 4 vertices of each quad to aligned with the center of the line.
                        // This is needed so the matrix TRS is applied from the center of the line.
                        copyOfVertices[materialIndex][vertexIndex + 0] -= centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 1] -= centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 2] -= centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 3] -= centerOfLine;

                        // Setup the matrix rotation.
                        matrix = Matrix4x4.TRS(Vector3.one, rotation, Vector3.one);

                        // Apply the matrix TRS to the individual characters relative to the center of the current line.
                        copyOfVertices[materialIndex][vertexIndex + 0] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 0]);
                        copyOfVertices[materialIndex][vertexIndex + 1] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 1]);
                        copyOfVertices[materialIndex][vertexIndex + 2] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 2]);
                        copyOfVertices[materialIndex][vertexIndex + 3] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 3]);

                        // Revert the translation change.
                        copyOfVertices[materialIndex][vertexIndex + 0] += centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 1] += centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 2] += centerOfLine;
                        copyOfVertices[materialIndex][vertexIndex + 3] += centerOfLine;
                    }
                }

                // Push changes into meshes
                for (int i = 0; i < textInfo.meshInfo.Length; i++)
                {
                    textInfo.meshInfo[i].mesh.vertices = copyOfVertices[i];
                    m_TextComponent.UpdateGeometry(textInfo.meshInfo[i].mesh, i);
                }

                yield return new WaitForSeconds(0.1f);
            }
        }

    }
}

2.105 Текст программы «VertexZoom.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Linq;
using System.Collections;
using System.Collections.Generic;


namespace TMPro.Examples
{

    public class VertexZoom : MonoBehaviour
    {
        public float AngleMultiplier = 1.0f;
        public float SpeedMultiplier = 1.0f;
        public float CurveScale = 1.0f;

        private TMP_Text m_TextComponent;
        private bool hasTextChanged;


        void Awake()
        {
            m_TextComponent = GetComponent<TMP_Text>();
        }

        void OnEnable()
        {
            // Subscribe to event fired when text object has been regenerated.
            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
        }

        void OnDisable()
        {
            // UnSubscribe to event fired when text object has been regenerated.
            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
        }


        void Start()
        {
            StartCoroutine(AnimateVertexColors());
        }


        void ON_TEXT_CHANGED(Object obj)
        {
            if (obj == m_TextComponent)
                hasTextChanged = true;
        }

        /// <summary>
        /// Method to animate vertex colors of a TMP Text object.
        /// </summary>
        /// <returns></returns>
        IEnumerator AnimateVertexColors()
        {

            // We force an update of the text object since it would only be updated at the end of the frame. Ie. before this code is executed on the first frame.
            // Alternatively, we could yield and wait until the end of the frame when the text object will be generated.
            m_TextComponent.ForceMeshUpdate();

            TMP_TextInfo textInfo = m_TextComponent.textInfo;

            Matrix4x4 matrix;
            TMP_MeshInfo[] cachedMeshInfoVertexData = textInfo.CopyMeshInfoVertexData();

            // Allocations for sorting of the modified scales
            List<float> modifiedCharScale = new List<float>();
            List<int> scaleSortingOrder = new List<int>();

            hasTextChanged = true;

            while (true)
            {
                // Allocate new vertices 
                if (hasTextChanged)
                {
                    // Get updated vertex data
                    cachedMeshInfoVertexData = textInfo.CopyMeshInfoVertexData();

                    hasTextChanged = false;
                }

                int characterCount = textInfo.characterCount;

                // If No Characters then just yield and wait for some text to be added
                if (characterCount == 0)
                {
                    yield return new WaitForSeconds(0.25f);
                    continue;
                }

                // Clear list of character scales
                modifiedCharScale.Clear();
                scaleSortingOrder.Clear();

                for (int i = 0; i < characterCount; i++)
                {
                    TMP_CharacterInfo charInfo = textInfo.characterInfo[i];

                    // Skip characters that are not visible and thus have no geometry to manipulate.
                    if (!charInfo.isVisible)
                        continue;

                    // Get the index of the material used by the current character.
                    int materialIndex = textInfo.characterInfo[i].materialReferenceIndex;

                    // Get the index of the first vertex used by this text element.
                    int vertexIndex = textInfo.characterInfo[i].vertexIndex;

                    // Get the cached vertices of the mesh used by this text element (character or sprite).
                    Vector3[] sourceVertices = cachedMeshInfoVertexData[materialIndex].vertices;

                    // Determine the center point of each character at the baseline.
                    //Vector2 charMidBasline = new Vector2((sourceVertices[vertexIndex + 0].x + sourceVertices[vertexIndex + 2].x) / 2, charInfo.baseLine);
                    // Determine the center point of each character.
                    Vector2 charMidBasline = (sourceVertices[vertexIndex + 0] + sourceVertices[vertexIndex + 2]) / 2;

                    // Need to translate all 4 vertices of each quad to aligned with middle of character / baseline.
                    // This is needed so the matrix TRS is applied at the origin for each character.
                    Vector3 offset = charMidBasline;

                    Vector3[] destinationVertices = textInfo.meshInfo[materialIndex].vertices;

                    destinationVertices[vertexIndex + 0] = sourceVertices[vertexIndex + 0] - offset;
                    destinationVertices[vertexIndex + 1] = sourceVertices[vertexIndex + 1] - offset;
                    destinationVertices[vertexIndex + 2] = sourceVertices[vertexIndex + 2] - offset;
                    destinationVertices[vertexIndex + 3] = sourceVertices[vertexIndex + 3] - offset;

                    //Vector3 jitterOffset = new Vector3(Random.Range(-.25f, .25f), Random.Range(-.25f, .25f), 0);

                    // Determine the random scale change for each character.
                    float randomScale = Random.Range(1f, 1.5f);
                    
                    // Add modified scale and index
                    modifiedCharScale.Add(randomScale);
                    scaleSortingOrder.Add(modifiedCharScale.Count - 1);

                    // Setup the matrix for the scale change.
                    //matrix = Matrix4x4.TRS(jitterOffset, Quaternion.Euler(0, 0, Random.Range(-5f, 5f)), Vector3.one * randomScale);
                    matrix = Matrix4x4.TRS(new Vector3(0, 0, 0), Quaternion.identity, Vector3.one * randomScale);

                    destinationVertices[vertexIndex + 0] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 0]);
                    destinationVertices[vertexIndex + 1] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 1]);
                    destinationVertices[vertexIndex + 2] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 2]);
                    destinationVertices[vertexIndex + 3] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 3]);

                    destinationVertices[vertexIndex + 0] += offset;
                    destinationVertices[vertexIndex + 1] += offset;
                    destinationVertices[vertexIndex + 2] += offset;
                    destinationVertices[vertexIndex + 3] += offset;

                    // Restore Source UVS which have been modified by the sorting
                    Vector2[] sourceUVs0 = cachedMeshInfoVertexData[materialIndex].uvs0;
                    Vector2[] destinationUVs0 = textInfo.meshInfo[materialIndex].uvs0;

                    destinationUVs0[vertexIndex + 0] = sourceUVs0[vertexIndex + 0];
                    destinationUVs0[vertexIndex + 1] = sourceUVs0[vertexIndex + 1];
                    destinationUVs0[vertexIndex + 2] = sourceUVs0[vertexIndex + 2];
                    destinationUVs0[vertexIndex + 3] = sourceUVs0[vertexIndex + 3];

                    // Restore Source Vertex Colors
                    Color32[] sourceColors32 = cachedMeshInfoVertexData[materialIndex].colors32;
                    Color32[] destinationColors32 = textInfo.meshInfo[materialIndex].colors32;

                    destinationColors32[vertexIndex + 0] = sourceColors32[vertexIndex + 0];
                    destinationColors32[vertexIndex + 1] = sourceColors32[vertexIndex + 1];
                    destinationColors32[vertexIndex + 2] = sourceColors32[vertexIndex + 2];
                    destinationColors32[vertexIndex + 3] = sourceColors32[vertexIndex + 3];
                }

                // Push changes into meshes
                for (int i = 0; i < textInfo.meshInfo.Length; i++)
                {
                    //// Sort Quads based modified scale
                    scaleSortingOrder.Sort((a, b) => modifiedCharScale[a].CompareTo(modifiedCharScale[b]));

                    textInfo.meshInfo[i].SortGeometry(scaleSortingOrder);

                    // Updated modified vertex attributes
                    textInfo.meshInfo[i].mesh.vertices = textInfo.meshInfo[i].vertices;
                    textInfo.meshInfo[i].mesh.uv = textInfo.meshInfo[i].uvs0;
                    textInfo.meshInfo[i].mesh.colors32 = textInfo.meshInfo[i].colors32;

                    m_TextComponent.UpdateGeometry(textInfo.meshInfo[i].mesh, i);
                }

                yield return new WaitForSeconds(0.1f);
            }
        }

    }
}

2.106 Текст программы «WarpTextExample.cs».
Назначение: исходный код компонента игрового проекта.
Язык программирования: C#.
Код программы:
using UnityEngine;
using System.Collections;


namespace TMPro.Examples
{

    public class WarpTextExample : MonoBehaviour
    {

        private TMP_Text m_TextComponent;

        public AnimationCurve VertexCurve = new AnimationCurve(new Keyframe(0, 0), new Keyframe(0.25f, 2.0f), new Keyframe(0.5f, 0), new Keyframe(0.75f, 2.0f), new Keyframe(1, 0f));
        public float AngleMultiplier = 1.0f;
        public float SpeedMultiplier = 1.0f;
        public float CurveScale = 1.0f;

        void Awake()
        {
            m_TextComponent = gameObject.GetComponent<TMP_Text>();
        }


        void Start()
        {
            StartCoroutine(WarpText());
        }


        private AnimationCurve CopyAnimationCurve(AnimationCurve curve)
        {
            AnimationCurve newCurve = new AnimationCurve();

            newCurve.keys = curve.keys;

            return newCurve;
        }


        /// <summary>
        ///  Method to curve text along a Unity animation curve.
        /// </summary>
        /// <param name="textComponent"></param>
        /// <returns></returns>
        IEnumerator WarpText()
        {
            VertexCurve.preWrapMode = WrapMode.Clamp;
            VertexCurve.postWrapMode = WrapMode.Clamp;

            //Mesh mesh = m_TextComponent.textInfo.meshInfo[0].mesh;

            Vector3[] vertices;
            Matrix4x4 matrix;

            m_TextComponent.havePropertiesChanged = true; // Need to force the TextMeshPro Object to be updated.
            CurveScale *= 10;
            float old_CurveScale = CurveScale;
            AnimationCurve old_curve = CopyAnimationCurve(VertexCurve);

            while (true)
            {
                if (!m_TextComponent.havePropertiesChanged && old_CurveScale == CurveScale && old_curve.keys[1].value == VertexCurve.keys[1].value)
                {
                    yield return null;
                    continue;
                }

                old_CurveScale = CurveScale;
                old_curve = CopyAnimationCurve(VertexCurve);

                m_TextComponent.ForceMeshUpdate(); // Generate the mesh and populate the textInfo with data we can use and manipulate.

                TMP_TextInfo textInfo = m_TextComponent.textInfo;
                int characterCount = textInfo.characterCount;


                if (characterCount == 0) continue;

                //vertices = textInfo.meshInfo[0].vertices;
                //int lastVertexIndex = textInfo.characterInfo[characterCount - 1].vertexIndex;

                float boundsMinX = m_TextComponent.bounds.min.x;  //textInfo.meshInfo[0].mesh.bounds.min.x;
                float boundsMaxX = m_TextComponent.bounds.max.x;  //textInfo.meshInfo[0].mesh.bounds.max.x;



                for (int i = 0; i < characterCount; i++)
                {
                    if (!textInfo.characterInfo[i].isVisible)
                        continue;

                    int vertexIndex = textInfo.characterInfo[i].vertexIndex;

                    // Get the index of the mesh used by this character.
                    int materialIndex = textInfo.characterInfo[i].materialReferenceIndex;

                    vertices = textInfo.meshInfo[materialIndex].vertices;

                    // Compute the baseline mid point for each character
                    Vector3 offsetToMidBaseline = new Vector2((vertices[vertexIndex + 0].x + vertices[vertexIndex + 2].x) / 2, textInfo.characterInfo[i].baseLine);
                    //float offsetY = VertexCurve.Evaluate((float)i / characterCount + loopCount / 50f); // Random.Range(-0.25f, 0.25f);

                    // Apply offset to adjust our pivot point.
                    vertices[vertexIndex + 0] += -offsetToMidBaseline;
                    vertices[vertexIndex + 1] += -offsetToMidBaseline;
                    vertices[vertexIndex + 2] += -offsetToMidBaseline;
                    vertices[vertexIndex + 3] += -offsetToMidBaseline;

                    // Compute the angle of rotation for each character based on the animation curve
                    float x0 = (offsetToMidBaseline.x - boundsMinX) / (boundsMaxX - boundsMinX); // Character's position relative to the bounds of the mesh.
                    float x1 = x0 + 0.0001f;
                    float y0 = VertexCurve.Evaluate(x0) * CurveScale;
                    float y1 = VertexCurve.Evaluate(x1) * CurveScale;

                    Vector3 horizontal = new Vector3(1, 0, 0);
                    //Vector3 normal = new Vector3(-(y1 - y0), (x1 * (boundsMaxX - boundsMinX) + boundsMinX) - offsetToMidBaseline.x, 0);
                    Vector3 tangent = new Vector3(x1 * (boundsMaxX - boundsMinX) + boundsMinX, y1) - new Vector3(offsetToMidBaseline.x, y0);

                    float dot = Mathf.Acos(Vector3.Dot(horizontal, tangent.normalized)) * 57.2957795f;
                    Vector3 cross = Vector3.Cross(horizontal, tangent);
                    float angle = cross.z > 0 ? dot : 360 - dot;

                    matrix = Matrix4x4.TRS(new Vector3(0, y0, 0), Quaternion.Euler(0, 0, angle), Vector3.one);

                    vertices[vertexIndex + 0] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 0]);
                    vertices[vertexIndex + 1] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 1]);
                    vertices[vertexIndex + 2] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 2]);
                    vertices[vertexIndex + 3] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 3]);

                    vertices[vertexIndex + 0] += offsetToMidBaseline;
                    vertices[vertexIndex + 1] += offsetToMidBaseline;
                    vertices[vertexIndex + 2] += offsetToMidBaseline;
                    vertices[vertexIndex + 3] += offsetToMidBaseline;
                }


                // Upload the mesh with the revised information
                m_TextComponent.UpdateVertexData();

                yield return new WaitForSeconds(0.025f);
            }
        }
    }
}

